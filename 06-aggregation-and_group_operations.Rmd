# Aggregation and Group Operations

```{r,echo=FALSE}
knitr::opts_chunk$set(comment = NA, prompt = TRUE, collapse = TRUE)
```

This chapter looks at manipulating and summarizing data by groups.

## Cross tabulation

Cross tabulation is the process of determining frequencies per group (or values based on frequencies, like proportions), with groups delineated by one or more variables (e.g., nationality and sex).

The Python and R examples of cross tabulation below both make use of the following dataset, `dat`:

```{r, echo = F}
set.seed(100)
dat <- data.frame(nationality = c('Canadian', 'French', 'French', 'Egyptian', 'Canadian'),
                  sex = c('m', 'f', 'f', 'm', 'f'))
```
```{python, echo = F}
dat = r.dat
```
```{r}
dat
```

#### Python {-}

The **pandas** package contains a `crosstab()` function for cross tabulation with two or more variables. The `groupby()`, also in **pandas**, facilitates cross tabulation by one or more variables when used in combination with `count()`.

```{python}
import pandas as pd
pd.crosstab(dat.nationality, dat.sex)
dat.groupby(by = 'nationality').nationality.count()
dat.groupby(by = ['nationality', 'sex']).nationality.count()
# Or: dat.groupby(by = ['nationality', 'sex']).sex.count()
```

#### R {-}

The `table()` function performs cross tabulation in R. A user can enter a single grouping variable or enter multiple grouping variables separated by a comma(s). The `xtabs()` function also computes cross-tabs; a user enters the variables to be used for grouping in formula notation.

```{r}
table(dat$nationality)
table(dat$nationality, dat$sex)
xtabs(formula = ~nationality + sex, data = dat)
```

## Group summaries

Computing statistical summaries per group.

#### Python {-}

#### R {-}

The `aggregate()` function allows a user to easily generate by-group statistical summaries based on one or more grouping variables. Grouping variables can be declared as a list in the function's `by` argument. Alternatively, the grouping variables (and the variable to be summarized) can be passed to `aggregate()` in formula notation: `var_to_be_aggregated ~ grouping_var_1 + ... + grouping_var_N`. The summarizing function (e.g., `mean()`; `median()`; etc.) is declared in the `FUN` argument.

```{r}
# One grouping variable
aggregate(x = mtcars$mpg, by = list(mtcars$cyl), FUN = mean) # Calculating mean of `mpg` in each `cyl` group
# Two or more grouping variables
aggregate(x = mtcars$mpg, by = list(mtcars$cyl, mtcars$vs), FUN = max) # Calculating max of `mpg` in each `cyl`*`vs` group
```
```{r, eval = F}
# Or, specify the variable to summarize and the grouping variables in formula notation
aggregate(mpg ~ cyl, data = mtcars, FUN = mean)
aggregate(mpg ~ cyl + vs, data = mtcars, FUN = max)
```

The **tidyverse** also offers a summarizing function, `summarize()` (or `summarise()`, for the Britons), which is in the **dplyr** package. After grouping a data frame/tibble (with, e.g., **dplyr**'s `group_by()` function), a user passes it to `summarize()`, specifying in the function call how the summary statistic should be calculated.

```{r}
library(dplyr)
mtcars %>% group_by(cyl, vs) %>% summarize(avg_mpg = mean(mpg))
# A benefit of `summarize()` is that it allows a user to specify relatively complicated
# summary calculations without needing to write an external function
mtcars %>% group_by(cyl, vs) %>% summarize(avg_mpg = mean(mpg),
                                           complicated_summary_calculation = min(mpg)^0.5 * mean(wt)^0.5 + mean(disp)^(1/mean(hp)))
```
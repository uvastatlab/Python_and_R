# Basics 

```{r,echo=FALSE}
knitr::opts_chunk$set(comment = NA, prompt = TRUE, collapse = TRUE)
```

This chapter covers the very basics of Python and R.

## Math

Mathematical operators are the same except for exponents, integer division, and remainder division (modulo).

#### Python {-}

Python uses `**` for exponentiation, `//` for integer division, and `%` for remainder division.

```{python}
3**2
5 // 2
5 % 2
```

In Python, the `+` operator can also be used to combine strings. See this TBD section.

#### R {-}

Python uses `^` for exponentiation, `%/%` for integer division, and `%%` for remainder division.

```{r}
3^2
5 %/% 2
5 %% 2
```

## Assignment

Python uses `=` for assignment, while R can use either `=` or `<-` for assignment. The latter "assignment arrow" is preferred in most R style guides to distinguish between assignment and setting the value of a function argument. According to R's documentation, "The operator `<-` can be used anywhere, whereas the operator `=` is only allowed at the top level (e.g., in the complete expression typed at the command prompt) or as one of the subexpressions in a braced list of expressions." See `?assignOps`.

#### Python {-}

```{python}
x = 12
```

#### R {-}

```{r}
x <- 12
```

## Printing a value

To see the value of an object created via assignment, you can simply enter the object at the console and hit enter for both Python and R, though it is common in Python to explicitly use the `print()` function.

#### Python {-}

```{python}
x
```

#### R {-}

```{r}
x
```

## Packages

User-created functions can be bundled and distributed as packages. Packages need to be installed only once. Thereafter they're "imported" (Python) or "loaded" (R) in each new session when needed.

Packages with large user bases are often updated to add functionality and fix bugs. The updates are not automatically installed. Staying apprised of library/package updates can be challenging. Some suggestions are following developers on Twitter, signing up for newsletters, or periodically checking to see what updates are available.

Packages often depend on other packages. These are known as "dependencies." Sometimes packages are updated to accommodate changes to other packages they depend on.

#### Python {-}

When you download Python and open a script, you have access to The Python Standard Library. This library includes several datatypes and functions for storing data, performing mathematical operations, and beyond. Commonly used datatypes include list and range. As you can see below, you do not need to import data types from the Standard Python Library.

```{python}
my_list = []
for idx in range(5):
  my_list.append(idx)
print(my_list)
```

Libraries contain modules, groups of functions. To use functions from modules in the Standard Python Library, users must import the appropriate module. Examples include math and itertools, which both include several functions for a range of operations.

```{python}
import math
one = 1
two = 2
print(math.pow(two, one))
```

Users can also download 100s of libraries outside of the Standard Python Library. Popular libraries include numpy, used for operations on arrays/vectors and pandas, used for data analysis.

```{python}
import numpy as np

my_array = np.array([1,2,3])
print(my_array)
```

#### R {-}

The main repository for R packages is the [Comprehensive R Archive Network](https://cran.r-project.org/) (CRAN). Another repository is [Bioconductor](https://www.bioconductor.org/), which provides tools for working with genomic data. Many packages are also distributed on [GitHub](https://github.com/).

To install packages from CRAN use the `install.packages()` function. In RStudio, you can also go to Tools...Install Packages... for a dialog that will auto-complete package names as you type.

```{r eval=FALSE}
# install the vcd package, a package for Visualizing Categorical Data
install.packages("vcd")

# load the package
library(vcd)

# see which packages on your computer have updates available
old.packages()

# download and install available package updates;
# set ask = TRUE to verify installation of each package
update.packages(ask = FALSE)
```

To install R packages from GitHub use the `install_github()` function from the **devtools** package. You need to include the username of the repo owner followed by a forward slash and the name of the package. Typing two colons between a package and a function in the package allows you to use that function without loading the package. That's how we use `install_github()` below.

```{r eval=FALSE}
install.packages("devtools")
devtools::install_github("username/packagename")
```

Occasionally when installing package updates you will be asked, "Do you want to install from sources the package which needs compilation?" R packages on CRAN are _compiled_ for Mac and Windows operating systems. That can take a day or two after a package has been submitted to CRAN. If you try to install a package that has not been compiled then you'll get asked the question above. If you click _Yes_, R will try to compile the package on your computer. This will only work if you have the required build tools on your computer. For Windows this means having [Rtools](https://cran.r-project.org/bin/windows/Rtools/) installed. Mac users should already have the necessary build tools. Unless you absolutely need the latest version of a package, it's probably fine to click _No_.

## Logic

Python and R share the same relational operators for making comparisons: 

- `==` (equals)
- `!=` (not equal to)
- `<` (less than)
- `<=` (less than or equal to)
- `>` (greater than)
- `>=` (greater than or equal to)

Likewise they share the same operators for logical AND and OR:

- `&` (AND)
- `|` (OR)

However R also has `&&` and `||` operators for programming control-flow.

Python and R have different operators for negation. Python uses `not`. R uses `!`.

#### Python {-}

#### R {-}

R's relational operators allow comparisons between a vector and a single value, or comparisons between two vectors. The result is a vector of TRUE/FALSE values.

```{r}
# vector compared with value
x1 <- c(1, 5, 9, 12, 11, 6)
x1 < 8

# vector compared with vector
x2 <- c(2, 4, 6, 14, 15, 7)
x1 > x2
```

Comparisons with NA (missing value) results in NA.

```{r}
x1 <- c(1, 5, 9, NA, 11, 6)
x1 < 8
```

Multiple comparisons can be made with AND (`&`) and OR (`|`) operators.

```{r}
x2 > 3 & x2 < 10
x2 < 3 | x2 > 10
```

TRUE/FALSE values in R have numeric values of 1/0. This allows us to sum and average them. (Note: an average of 0 and 1 values is the proportion of 1's.)

```{r}
# sum of values greater than 10
sum(x2 > 10)

# proportion of values greater than 10
mean(x2 > 10)
```

Use the `!` operator for negation. This allows to check for something that is NOT TRUE.

```{r}
# which value are NOT less than 6
!x2 < 6
```

See the `?Comparison` and `?Logic` help pages for more information.


## Generating a sequence of values

In Python, one option for generating a sequence of values is `arange()` from **NumPy**. In R, a common approach is to use `seq()`. The sequences can be incremented by indicating a `step` argument in `arange()` or a `by` argument in `seq()`. Be aware that the end of the start/stop interval in `arange()` is _open_, but both sides of the from/to interval in `seq()` are _closed_.

#### Python {-}

```{python}
import numpy as np
x = np.arange(start = 1, stop = 11, step = 2)
x
```

#### R {-}

```{r}
x <- seq(from = 1, to = 11, by = 2)
x
```

## Calculating means and medians

The **NumPy** Python library has functions for calculating means and medians, and base R has functions for doing the same.

#### Python {-}

Mean, using function from **NumPy** library

```{python}
import numpy as np
x = [90, 105, 110]
x_avg = np.mean(x)
print(x_avg)
```

Median, using function from **NumPy** library

```{python}
x = [98, 102, 20, 22, 304]
x_med = np.median(x)
print(x_med)
```

#### R {-}

Mean, using function from base R

```{r}
x <- c(90, 105, 110)
x_avg <- mean(x)
x_avg
```

Median, using function from base R

```{r}
x <- c(98, 102, 20, 22, 304)
x_med <- median(x)
x_med
```

## Writing your own functions

Python and R allow and encourage users to create their own functions. Functions can be created, named, and stored in memory and used throughout a session. Or they can be created on-the-fly "anonymously" and used once.

#### Python {-}

Functions in Python are defined by using the `def` keyword followed by the name we choose for our function with its arguments inside parentheses. We must include a `return()` statement after the body of our function to indicate the end of the function. The return statement takes an optional argument in its parentheses that will be the output of the function. Here we create a function to calculate the standard error of a mean (SEM) and call it `SEM`. 

```{python}
def SEM(x):
  import numpy as np # import statement included inside the function to ensure it's always imported
  s = x.std(ddof=1) # find standard deviation of the data, specify delta degrees of freedom as 1 (makes denominator n-1 not n)
  n = x.shape[0] # extract the length of the input array
  sem = s / np.sqrt(n) # calculate the SEM
  return(sem) # return the calculated SEM value
```

Now let's try our function out on some test data.

```{python}
d = np.array([3,4,4,7,9,6,2,5,7])
SEM(d)
```

Oftentimes functions have built-in error-checking that returns messages describing the error. Here we show a simple error-check to ensure that the argument passed to our function is a number. 

```{python}
def SEM(x):
  import numpy as np
  
  if np.issubdtype(x.dtype,np.number)==False:
    raise ValueError("Data must be numeric")
  
  s = x.std(ddof=1) 
  n = x.shape[0] 
  sem = s / np.sqrt(n) 
  return(sem) 
```

Python functions can return more than one result. It will output the results into a `tuple`. A tuple is a data structure very similar to a list, but it is immutable - we cannot change the order of the entries. Here we make our function return both the mean and the SEM of our data. 

```{python}
def SEM(x):
  import numpy as np
  
  if np.issubdtype(x.dtype,np.number)==False:
    raise ValueError("Data must be numeric")
  
  s = x.std(ddof=1) 
  n = x.shape[0] 
  sem = s / np.sqrt(n) 
  
  m = np.mean(x)
  return(sem,m) 
```

#### R {-}

Functions in R can be created and named using `function()`. Add arguments inside the parentheses. Longer functions with multiple lines can be wrapped in curly braces `{}`.

Below we create a function to calculate the standard error of a mean (SEM) and name it `sem`. It takes one argument: `x`, a vector of numbers. Both the function name and argument name(s) can be whatever we like, as long as they follow [R's naming conventions](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#R-commands_003b-case-sensitivity-etc).

```{r}
sem <- function(x){
  s <- sd(x)
  n <- length(x)
  s/sqrt(n)
}

```

Now we can try it out on some test data.

```{r}
d <- c(3,4,4,7,9,6,2,5,7)
sem(d)
```

Functions that will be used on different data and/or by different users often need built-in error-checking to return informative error messages. This simple example checks if the data are not numeric and returns a special error message.

```{r error=TRUE}
sem <- function(x){
  if(!is.numeric(x)) stop("x must be numeric")
  s <- sd(x)
  n <- length(x)
  s/sqrt(n)
}
sem(c(1, 4, 6, "a"))
```

R functions can also return more than one result. Below we return a list that holds the mean and SEM, but we could also return a vector, a data frame, or other data structure. Notice we also add an additional argument, `...`, known as the three dots argument. This allows us to pass arguments for `sd` and `mean` directly through our own function. Below we pass through `na.rm = TRUE` to drop missing values.
 

```{r}
sem <- function(x, ...){
  if(!is.numeric(x)) stop("x must be numeric")
  s <- sd(x, ...)
  n <- length(x)
  se <- s/sqrt(n)
  mean <- mean(x, ...)
  list(mean = mean, SEM = se)
}

d <- c(1, 4, 6, 8, NA, 4, 4, 8, 6)
sem(d, na.rm = TRUE)
```

Functions can also be created on-the-fly as "anonymous" functions. This simply means the functions are not saved as objects in memory. These are often used with R's family of `apply` functions. As before, the functions can be created with `function()`. We can also use the backslash `\` as a shorthand for `function()`. We demonstrate both below with a data frame.

```{r}
# generate some example data
d <- data.frame(x1 = c(3, 5, 7, 1, 5, 4),
                x2 = c(6, 9, 8, 9, 2, 5),
                x3 = c(1, 9, 9, 7, 8, 4))
d
```

Now find the standard error of the mean for the three columns using an anonymous function with `lapply()`. The "l" means the result will be a list. We apply the function to each column of the data frame.

```{r}
lapply(d, function(x)sd(x)/sqrt(length(x)))
```

We can also use the backslash as a shorthand for `function()`.

```{r}
lapply(d, \(x)sd(x)/sqrt(length(x)))
```


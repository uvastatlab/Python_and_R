# Data Structures 

```{r,echo=FALSE}
knitr::opts_chunk$set(comment = NA, prompt = TRUE, collapse = TRUE)
```

This chapter compares and contrasts data structures in Python and R.

## One-dimensional data

A one-dimensional data structure can be visualized as a column in a spreadsheet or as a list of values. 

#### Python {-}

There are many ways to organize one-dimensional data in Python. The of the most common one-dimensional data structures are lists, numpy arrays, and pandas Series. All three are ordered and mutable, and can contain data of different types. 

Lists in Python do not need to be explicitly declared, they are indicated by the use of square brackets.

```{python}
l = [1,2,3,'hello']
```

Values in lists can be accessed by using square brackets. Python indexing begins at 0, so to extract the first element, we would use the index 0. Python also allows for negative indexing, using an index of -1 will return the last value in the list. Indexing a range in Python is not inclusive of the last index. 

```{python}
# extract first element
l[0]

#extract last element
l[-1]

# extract 2nd and 3rd elements
l[1:3]

```

Numpy arrays, on the other hand, need to be declared using the `numpy.array()` function and the `numpy` package needs to be imported. 

```{python}
import numpy as np

arr = np.array([1,2,3,'hello'])
print(arr)
```

Accessing data in a numpy array is the same as indexing a list. 

```{python}
# extract first element 
arr[0]

# extract last element
arr[-1]

# extract 2nd and 3rd elements
arr[1:3]
```

Pandas Series also need to be declared using the `pandas.Series()` function. Like `numpy`, the `pandas`package must be imported as well. The pandas package is built on numpy, so we can input data into a pandas Series using a numpy array. We can extract data from the Series by using the index similar to indexing a list and numpy array. Indexing a range 

```{python}
import pandas as pd 
import numpy as np

data = np.array([1,2,3,"hello"])
ser1 = pd.Series(data)
print(ser1)

# extract first element 
ser1[0]

# extract last element 
ser1[-1]


# extract 2nd and 3rd elements 
ser1[1:3]
```

We can relabel the indices of the Series to whatever we like using the `index` attribute within the `Series` function. 

```{python}
import pandas as pd 
import numpy as np

ser2 = pd.Series(data, index=['a','b','c','d'])
print(ser2)
```

We can then use our own specified indices to select and index our data. Indexing with our labels can be done in two ways. One similar to indexing arrays and lists with square brackets using the `.loc` function, and the other follows this form: `Series.label_name`.

```{python}

# extract element in row b
ser2.loc["b"]

# extract elements from row b to the end
ser2.loc["b":]

# extract element in row "d"
ser2.d

# extract element in row "b"
ser2.b
```

One thing to note is that mathematical operations cannot be carried out on lists, but can be carried out on numpy arrays and pandas Series. In general, lists are better for short data sets that you will not be operating on mathematically. Numpy arrays and pandas Series are better for long data sets, and for data sets that will be operated on mathematically. 

#### R {-}

In R a one-dimensional data structure is called a _vector_. We can create a vector using the `c()` function. A vector in R can only contain one type of data (all numbers, all strings, etc). The columns of data frames are vectors. If multiple types of data are put into a vector, the data will be coerced according to the hierarchy `logical` < `integer` < `double` < `complex` < `character`. This means if you mix, say, integers and character data, all the data will be coerced to character. 

```{r}
x1 <- c(23, 43, 55)
x1

# all values coerced to character
x2 <- c(23, 43, 'hi')
x2
```

Values in a vector can be accessed by position using indexing brackets. 

```{r}
# extract the 2nd value
x1[2]

# extract the 2nd and 3rd value
x1[2:3]

```


## Two-dimensional data

Two-dimensional data are rectangular in nature, consisting of rows and columns. These can be the type of data you might find in a spreadsheet with a mix of data types in columns; they can also be matrices as you might encounter in matrix algebra.

#### Python {-}
In Python, two common two-dimensional data structures include the _numpy array_ and the _pandas DataFrame_. 

A two-dimensional numpy array is made in a similar way to the one-dimensional array using the `numpy.array` function. 

```{python}
import numpy as np

arr2d = np.array([[1,2,3,"hello"],[4,5,6,"world"]])
print(arr2d)
```

Selecting data for a two-dimensional numpy array follows the same form as indexing a one-dimensional array. 

```{python}
import numpy as np

# extract first element 
arr2d[0,0]

# extract last element 
arr2d[-1, -1]

# extract 2nd and 3rd columns
arr2d[:,1:3]

```

A pandas DataFrame is made using the `pandas.DataFrame` function in a similar way to the pandas Series. 

```{python}
import pandas as pd
import numpy as np

data = np.array([[1,2,3,"hello"],[4,5,6,"world"]])
df = pd.DataFrame(data)
print(df)
```

Selecting data from a DataFrame is similar to that of the Series. 

```{python}
# extract first element 
df.loc[0,0]

# extract column 1
df.loc[0]

# extract row 1
df.loc[0,0]
```

Like the pandas Series, we can change the indices and the column names of the DataFrame and can use those to select and index our data. 

We change the indices again using the `index` attribute in the `pandas.DataFrame` function:

```{python}
import pandas as pd
import numpy as np

data = np.array([[1,2,3,"hello"],[4,5,6,"world"]])
df = pd.DataFrame(data, index=["a","b"])
print(df)
```

We can change the column names using the `columns` attribute in the `pandas.DataFrame` function:

```{python}
import pandas as pd
import numpy as np

data = np.array([[1,2,3,"hello"],[4,5,6,"world"]])
df = pd.DataFrame(data, index=["a","b"], columns=["column 1","column 2", "column 3", "column 4"])
print(df)
```

One thing to note is that numpy arrays can actually have N dimensions, whereas pandas DataFrames can only have two. Numpy arrays will be the better choice for data with more than two dimensions. 

#### R {-}

Two-dimensional data structures in R include the _matrix_ and _data frame_. A matrix can contain only one data type. A data frame can contain multiple vectors each of which can consist of different data types. 

Create a matrix with the `matrix()` function. Create a data frame with the `data.frame()` function. Most imported data comes into R as a data frame.

```{r}
# matrix; populated down by column by default
m <- matrix(data = c(1,3,5,7), nrow = 2, ncol = 2)
m

# data frame
d <- data.frame(name = c("Rob", "Cindy"),
                age = c(35, 37))
d
```

Values in a matrix and data frame can be accessed by position using indexing brackets. The first number(s) refers to rows; the second number(s) refers to columns. Leaving row or column numbers empty selects all rows or columns.

```{r}
# extract value in row 1, column 2
m[1,2]

# extract values in row 2
d[2,]
```


## Three-dimensional and higher data

Three-dimensional and higher data can be visualized as multiple rectangular structures stratified by extra variables. These are sometimes referred to as _arrays_. Analysts usually prefer two-dimensional data frames to arrays. Data frames can accommodate multidimensional data by including the additional dimensions as variables.

#### Python {-}


#### R {-}

The `array()` function in R can create three-dimensional and higher data structures. Specify the dimension number and size using the `dim` argument. Below we specify 2 rows, 3 columns, and 2 strata using a vector: `c(2,3,2)`. This creates a three-dimensional data structure. The data are simply the numbers 1 through 12.

```{r}
a1 <- array(data = 1:12, dim = c(2,3,2))
a1
```

Values in arrays can be accessed by position using indexing brackets.

```{r}
# extract value in row 1, column 2, strata 1
a1[1,2,1]

# extract column 2 in both strata
# result is returned as matrix
a1[,2,]
```

The dimensions can be named using the `dimnames()` function. Notice the names must be a _list_.

```{r}
dimnames(a1) <- list("X" = c("x1", "x2"), 
                     "Y" = c("y1", "y2", "y3"), 
                     "Z" = c("z1", "z2"))
a1
```

The `as.data.frame.table()` function can collapse an array into a two-dimensional structure that may be easier to use with standard statistical and graphical routines. The `responseName` argument allows you to provide a suitable column name for the values in the array.

```{r}
as.data.frame.table(a1, responseName = "value")
```


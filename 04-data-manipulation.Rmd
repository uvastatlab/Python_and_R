# Data Manipulation

```{r,echo=FALSE}
knitr::opts_chunk$set(comment = NA, prompt = TRUE, collapse = TRUE)
```

This chapter looks at various strategies for filtering, selecting, modifying and deriving variables in data. Unless otherwise stated, examples are for DataFrames (Python) and data frames (R) and use the mtcars data frame that is included with R.

```{python}
# Python
import pandas
mtcars = pandas.read_csv('data/mtcars.csv')
```


```{r}
# R
data(mtcars)
# drop row names to match Python version of data
rownames(mtcars) <- NULL
```


## Names of variables and their types

View and inspect the names of variables and their type (numeric, string, logical, etc.) This is useful to ensure that variables have the expected type. 

#### Python {-}

The `.info()` function in pandas lists information on the DataFrame.


Setting the argument `verbose` to `True` prints the name of the columns, their length excluding `NULL` values, and their data type (`dtype`) in a table. The function lists the unique data types in the DataFrame, and it prints how much memory the DataFrame takes up.

```{python}
mtcars.info(verbose=True)
```

By default, the `verbose` argument is set to `False`. Then, the function lists the unique data types in the DataFrame, and it prints how much memory the DataFrame takes up. This setting excludes the table describing each column.

```{python}
mtcars.info()
```


#### R {-}

The `str()` function in R lists the names of the variables, their type, the first few values, and the dimensions of the data frame.  

```{r}
str(mtcars)
```

To see just the names of the data frame, use the `names()` function.

```{r}
names(mtcars)
```

To see just the dimensions of the data frame, use the `dim()` function. It returns the number of rows and columns, respectively.


```{r}
dim(mtcars)
```

## Select variables

How to select specific columns of data frames.

#### Python {-}
The period operator `.` provides access to a column in a DataFrame as a vector. This returns pandas series. A pandas series can do everything a numpy array can do.

```{python}
mtcars.mpg
```

Indexing also provides access to columns as a pandas Series. Single and double quotations both work.

```{python}
mtcars['mpg']
```

Operations on numpy arrays are faster than operations on pandas series. But using pandas series should be fine, in terms of performance, in many cases. This is important for large data sets on which many operations are performed. The `.values` function returns a numpy array.

```{python}
mtcars['mpg'].values
```

Double indexing returns a pandas DataFrame, instead of a numpy array or pandas series.

```{python}
mtcars[['mpg']]
```

The `head()` and `tail()` functions return the first 5 or last 5 values. Use the `n` argument to change the number of values. This function works on numpy array, pandas series and pandas DataFrames.

```{python}
# first 6 values
mtcars.mpg.head()
```

```{python}
# last row of DataFrame
mtcars.tail(n=1)
```

#### R {-}

The dollar sign operator, `$`, provides access to a column in a data frame as a vector.

```{r}
mtcars$mpg
```

Double indexing brackets also provide access to columns as a vector.

```{r}
mtcars[["mpg"]]
```

Single indexing brackets work as well, but return a data frame instead of a vector (if used with a data frame).

```{r}
mtcars["mpg"]
```


Single indexing brackets also allow selection of rows when used with a comma. The syntax is `rows, columns`

```{r}
# first three rows
mtcars[1:3, "mpg"]
```

Finally single indexing brackets allow us to select multiple columns. Request columns either by name or position using a vector.

```{r}
mtcars[c("mpg", "cyl")] 
# same as mtcars[1:2] 
```

The `head()` and `tail()` functions return the first 6 or last 6 values. Use the `n` argument to change the number of values. They work with vectors or data frames.

```{r}
# first 6 values
head(mtcars$mpg)
```

```{r}
# last row of data frame
tail(mtcars, n = 1)
```


## Filter/Subset variables

How to view certain rows of a data frame that meet certain conditions.

#### Python {-}

#### R {-}


## Rename variables

How to rename variables or "column headers".

#### Python {-}

Column names can be changed using the function `.rename()`. Below, we change the column names "cyl" and "wt" to "cylinder" and "WT", respectively.

```{python}
mtcars.rename(columns={"cyl":"cylinder", "wt":"WT"})
```

Alternatively, column names can be changed by replacing the vector of column names with a new vector. Below, we create a vector of columns that replaces "drat" with "axle_ratio" using conditional match and indexing and "disp" with "DISP" using indexing.

```{python}
column_names = mtcars.columns.values

# using conditional match
column_names[column_names == "drat"] = "axle_ratio"

# using indexing
column_names[2] = "DISP"

mtcars.columns = column_names
mtcars.columns
```



#### R {-}

Variable names can be changed by their index (ie, order of columns in the data frame). Below the second column is "cyl". We change the name to "cylinder".

```{r}
names(mtcars)[2]
names(mtcars)[2] <- "cylinders"
names(mtcars)
```

Variable names can also be changed by conditional match. Below we find the variable name that matches "drat" and change to "axle_ratio".

```{r}
names(mtcars)[names(mtcars) == "drat"]
names(mtcars)[names(mtcars) == "drat"] <- "axle_ratio"
names(mtcars)
```

More than one variable name can be changed using a vector of positions or matches.

```{r}
names(mtcars)[c(6,8)] <- c("weight", "engine")

# or
# names(mtcars)[names(mtcars) %in% c("wt", "vs")] <- c("weight", "engine")

names(mtcars)
```

See also the `rename()` function in the **dplyr** package. 

## Create, replace and remove variables

We often need to create variables that are functions of other variables, or replace existing variables with an updated version.

#### Python {-}
Adding a new variable using the indexing notation and assigning a result adds a new column.

```{python}
# add column for Kilometer per liter
mtcars['kpl'] = mtcars.mpg/2.352
```

Doing the same with an _existing_ column name updates the values in a column.

```{python}
# update to liters per 100 Kilometers
mtcars['kpl'] = 100/mtcars.kpl 
```

Alternatively, the `.` notation can be used to update the values in a column.
```{python}
# update to liters per 50 Kilometers
mtcars.kpl = 50/mtcars.kpl 
```

To remove a column, use the `.drop()` function.

```{python}
# drop the kpl variable
mtcars.drop(columns=['kpl'])
```


#### R {-}

Adding a new variable name after the dollar sign notation and assigning a result adds a new column.

```{r}
# add column for Kilometer per liter
mtcars$kpl <- mtcars$mpg/2.352
```

Doing the same with an _existing_ variable updates the values in a column. 

```{r}
# update to liters per 100 Kilometers
mtcars$kpl <- 100/mtcars$kpl 
```

To remove a variable, assign it `NULL`.

```{r}
# drop the kpl variable
mtcars$kpl <- NULL
```


## Create strings from numbers

You may have data that is numeric but that needs to be treated as a string. 

#### Python {-}
You can change the data type of a column in a DataFrame using the `astype` function.

```{python}
mtcars['am'] = mtcars['am'].astype(str)
type(mtcars.am[0]) # check the type of the first item in 'am' column
```

#### R {-}

The `as.character()` function takes a vector and converts it to string format.

```{r}
head(mtcars$am)
head(as.character(mtcars$am))
```

Note we just demonstrated conversion. To save the conversion we need to _assign_ the result to the data frame.

```{r}
# add new string variable am_ch
mtcars$am_ch <- as.character(mtcars$am)
head(mtcars$am_ch)
```


The `factor()` function can also be used to convert a numeric vector into a  categorical variable. The result is not exactly a string, however. A factor is made of integers with character labels. Factors are useful for character data that have a fixed set of levels (eg, "grade 1", grade 2", etc)

```{r}
# convert to factor
head(mtcars$am)
head(factor(mtcars$am))

# convert to factor with labels
head(factor(mtcars$am, labels = c("automatic", "manual")))
```

Again we just demonstrated factor conversion. To save the conversion we need to assign to the data frame.

```{r}
# create factor variable am_fac
mtcars$am_fac <- factor(mtcars$am, labels = c("automatic", "manual"))
head(mtcars$am_fac)
```


TODO: add zip code conversion using `str_pad()` (or base R option?)

## Create numbers from strings

String variables that ought to be numbers usually have some character data in the values such as units (eg, "4 cm"). To create numbers from strings it's important to remove any character data that cannot be converted to a number.


#### Python {-}
The `astype(float)` or `astype(int)` function will coerce strings to numerical representation.

For demonstration, let's say we have the following numpy array.

```{python}
import numpy as np
weight = np.array(["125 lbs.", "132 lbs.", "156 lbs."])
```

The `astype(float)` function throws an error due to the presence of strings. The `astype()` function is for numpy arrays.

```{python}
try:
  weight.astype(float)
except ValueError:
  print("ValueError: could not convert string to float: '125 lbs.'")
```

One way to approach this is to first remove the strings from the objects and then use `astype(float)`. Below we use the `strip()` function to find " lbs." using a list comprehension.


```{python}
# [] indicates a list in python
# np.array() changes the list back into an array
weight = np.array([w.strip(" lbs.") for w in weight])
```

Now we can use the `astype()` function to change the elements in weight from `str` to `float`.

```{python}
weight.astype(float)
```

#### R {-}

The `as.numeric()` function will attempt to coerce strings to numeric type _if possible_. Any non-numeric values are coerced to NA.

For demonstration, let's say we have the following vector.

```{r}
weight <- c("125 lbs.", "132 lbs.", "156 lbs.")
```

The `as.numeric()` function returns all NA due to presence of character data.

```{r}
as.numeric(weight)
```

There are many ways to approach this. A common approach is to first remove the characters and then use `as.numeric()`. Below we use the `sub` function to find "lbs." and replace with nothing.

```{r}
weightN <- gsub("lbs.", "", weight)
as.numeric(weightN)
```

The `parse_number()` function in the **readr** package can often take care of these situations automatically.

```{r}
readr::parse_number(weight)
```



## Change case

How to change the case of strings. The most common case transformations are lower case, upper case, and title case.

#### Python {-}

The `lower()`, `upper()`, and `title()` functions convert case to lower, upper, and title, respectively. We can use a list comprehension to apply these functions to each string in a list.

```{python}
col_names = [col.upper() for col in mtcars.columns]
mtcars.columns = col_names
```

#### R {-}

The `tolower()` and `toupper()` functions convert case to lower and upper, respectively.

```{r}
names(mtcars) <- toupper(names(mtcars))
names(mtcars)
```

```{r}
names(mtcars) <- tolower(names(mtcars))
names(mtcars)
```

The **stringr** package provides a convenient title case conversion function, `str_to_title()`, which capitalizes the first letter of each string.

```{r}
stringr::str_to_title(names(mtcars))
```

## Drop duplicate rows

How to find and drop duplicate elements.

#### Python {-}

The `duplicated()` function determines which rows of a DataFrame are duplicates of previous rows. 

First, we create a DataFrame with a duplicate row by using the pandas `concat()` function. `concat()` combines DataFrames by rows or columns, row by default.

```{python}
# create DataFrame with duplicate rows
import pandas as pd
mtcars2 = pd.concat([mtcars.iloc[0:3,0:6], mtcars.iloc[0:1,0:6]])
```

The `duplicated()` function returns a logical vector. TRUE indicates a row is a duplicate of a previous row.

```{python}
# create DataFrame with duplicate rows
mtcars2.duplicated()
```


#### R {-}

The `duplicated()` function "determines which elements of a vector or data frame are duplicates of elements with smaller subscripts". (from `?duplicated`)

```{r}
# create data frame with duplicate rows
mtcars2 <- rbind(mtcars[1:3,1:6], mtcars[1,1:6])
# last row is duplicate of first
mtcars2
```

The `duplicated()` function returns a logical vector. TRUE indicates a row is a duplicate of a previous row.

```{r}
# last row is duplicate
duplicated(mtcars2)
```

The TRUE/FALSE vector can be used to extract or drop duplicate rows. Since TRUE in indexing brackets will keep a row, we can use `!` to negate the logicals and keep those that are "NOT TRUE"

```{r}
# drop the duplicate and update the data frame
mtcars3 <- mtcars2[!duplicated(mtcars2),]
mtcars3
```

```{r}
# extract and investigate the duplicate row
mtcars2[duplicated(mtcars2),]
```

The `anyDuplicated()` function returns the row number of duplicate rows.

```{r}
anyDuplicated(mtcars2)
```


## Randomly sample rows

How to take a random sample of rows from a data frame. The sample is usually either a fixed size or a proportion.

#### Python {-}

The pandas package provide a function for taking a sample of fixed size or a proportion. To sample with replacement, set `replace = TRUE`. 

Additionally, the random sample will change every time the code is run. To always generate the same "random" sample, set `random_state` to any positive integer.

To create a sample with a fixed number of rows, use the `n` argument.
```{python}
# sample 5 rows from mtcars
mtcars.sample(n=5, replace=True)
```

To create a sample of a proportion, use the `frac` argument.
```{python}
# sample 20% of rows from mtcars
mtcars.sample(frac = 0.20, random_state=1)
```

The numpy function `random.choice()` in combination with the `loc()` function can be used to sample from a DataFrame. 

The `random.choice()` function creates a random sample according to the given parameters. The `loc()` function is used to access rows and columns by index. 

```{python}
# import the numpy package
import numpy as np

# create a random sample of size 5 with replacement
random_sample = np.random.choice(len(mtcars), (5,), replace=True)

# use random_sample to sample from mtcars
mtcars.loc[random_sample,]
```

The random sample will change every time the code is run. To always generate the same "random" sample, use the `random.seed()` function with any positive integer.

```{python}
# setting seed to always get same random sample
np.random.seed(123)

# create a random sample of size 5 with replacement
sample = np.random.choice(len(mtcars), (5,), replace=True)
mtcars.loc[sample,]
```

#### R {-}

There are many ways to sample rows from a data frame in R. The **dplyr** package provides a convenience function, `slice_sample()`, for taking either a fixed sample size or a proportion.

```{r}
# sample 5 rows from mtcars
dplyr::slice_sample(mtcars, n = 5)

# sample 20% of rows from mtcars
dplyr::slice_sample(mtcars, prop = 0.20)

```

To sample with replacement, set `replace = TRUE`.

The base R functions `sample()` and `runif()` can be combined to sample sizes or approximate proportions.

```{r}
# sample 5 rows from mtcars
# get random row numbers
i <- sample(nrow(mtcars), size = 5)
# use i to select rows
mtcars[i,]
```

```{r}
# sample about 20% of rows from mtcars
# generate random values on range of [0,1]
i <- runif(nrow(mtcars))
# use i < 0.20 logical vector to 
# select rows that correspond to TRUE
mtcars[i < 0.20,]
```

The random sample will change every time the code is run. To always generate the same "random" sample, use the `set.seed()` function with any positive integer.

```{r}
# always get the same random sample
set.seed(123)
i <- runif(nrow(mtcars))
mtcars[i < 0.20,]
```


# Data Manipulation

```{r,echo=FALSE}
knitr::opts_chunk$set(comment = NA, prompt = TRUE, collapse = TRUE)
```

This chapter looks at various strategies for modifying and deriving variables in data. Unless otherwise stated, examples are for DataFrames (Python) and data frames (R) and use the mtcars data frame that is included with R.

```{python}
# Python
import pandas
mtcars = pandas.read_csv('data/mtcars.csv')
```


```{r}
# R
data(mtcars)
```


## Names of variables and their types

View and inspect the names of variables and their type (numeric, string, logical, etc.) This is useful to ensure that variables have the expected type. 

#### Python {-}


#### R {-}

The `str()` function in R lists the names of the variables, their type, the first few values, and the dimensions of the data frame.  

```{r}
str(mtcars)
```

To see just the names of the data frame, use the `names()` function.

```{r}
names(mtcars)
```

To see just the dimensions of the data frame, use the `dim()` function. It returns the number of rows and columns, respectively.


```{r}
dim(mtcars)
```

## Access variables

How to work with a specific column of data.

#### Python {-}


#### R {-}

The dollar sign operator, `$`, provides access to a column in a data frame as a vector.

```{r}
mtcars$mpg
```

Double indexing brackets also provide access to columns as a vector.

```{r}
mtcars[["mpg"]]
```

Single indexing brackets work as well, but return a data frame instead of a vector (if used with a data frame).

```{r}
mtcars["mpg"]
```


Single indexing brackets also allow selection of rows when used with a comma. The syntax is `rows, columns`

```{r}
# first three rows
mtcars[1:3, "mpg"]
```

Finally single indexing brackets allow us to select multiple columns. Request columns either by name or position using a vector.

```{r}
mtcars[c("mpg", "cyl")] 
# same as mtcars[1:2] 
```

The `head()` and `tail()` functions return the first 6 or last 6 values. Use the `n` argument to change the number of values. They work with vectors or data frames.

```{r}
# first 6 values
head(mtcars$mpg)
```

```{r}
# last row of data frame
tail(mtcars, n = 1)
```


## Rename variables

How to rename variables or "column headers".

#### Python {-}


#### R {-}

Variable names can be changed by their index (ie, order of columns in the data frame). Below the second column is "cyl". We change the name to "cylinder".

```{r}
names(mtcars)[2]
names(mtcars)[2] <- "cylinders"
names(mtcars)
```

Variable names can also be changed by conditional match. Below we find the variable name that matches "drat" and change to "axle_ratio".

```{r}
names(mtcars)[names(mtcars) == "drat"]
names(mtcars)[names(mtcars) == "drat"] <- "axle_ratio"
names(mtcars)
```

More than one variable name can be changed using a vector of positions or matches.

```{r}
names(mtcars)[c(6,8)] <- c("weight", "engine")

# or
# names(mtcars)[names(mtcars) %in% c("wt", "vs")] <- c("weight", "engine")

names(mtcars)
```

See also the `rename()` function in the **dplyr** package. 

## Create, replace and remove variables

We often need to create variables that are functions of other variables, or replace existing variables with an updated version.

#### Python {-}


#### R {-}

Adding a new variable name after the dollar sign notation and assigning a result adds a new column.

```{r}
# add column for Kilometer per liter
mtcars$kpl <- mtcars$mpg/2.352
```

Doing the same with an _existing_ variable updates the values in a column. 

```{r}
# update to liters per 100 Kilometers
mtcars$kpl <- 100/mtcars$kpl 
```

To remove a variable, assign it `NULL`.

```{r}
# drop the kpl variable
mtcars$kpl <- NULL
```


## Create strings from numbers

You may have data that is numeric but that needs to be treated as a string. 

#### Python {-}


#### R {-}

The `as.character()` function takes a vector and converts it to string format.

```{r}
head(mtcars$am)
head(as.character(mtcars$am))
```

Note we just demonstrated conversion. To save the conversion we need to _assign_ the result to the data frame.

```{r}
# add new string variable am_ch
mtcars$am_ch <- as.character(mtcars$am)
head(mtcars$am_ch)
```


The `factor()` function can also be used to convert a numeric vector into a  categorical variable. The result is not exactly a string, however. A factor is made of integers with character labels. Factors are useful for character data that have a fixed set of levels (eg, "grade 1", grade 2", etc)

```{r}
# convert to factor
head(mtcars$am)
head(factor(mtcars$am))

# convert to factor with labels
head(factor(mtcars$am, labels = c("automatic", "manual")))
```

Again we just demonstrated factor conversion. To save the conversion we need to assign to the data frame.

```{r}
# create factor variable am_fac
mtcars$am_fac <- factor(mtcars$am, labels = c("automatic", "manual"))
head(mtcars$am_fac)
```


TODO: add zip code conversion using `str_pad()` (or base R option?)

## Create numbers from strings

String variables that ought to be numbers usually have some character data in the values such as units (eg, "4 cm"). To create numbers from strings it's important to remove any character data that cannot be converted to a number.


#### Python {-}


#### R {-}

The `as.numeric()` function will attempt to coerce strings to numeric type _if possible_. Any non-numeric values are coerced to NA.

For demonstration, let's say we have the following vector.

```{r}
weight <- c("125 lbs.", "132 lbs.", "156 lbs.")
```

The `as.numeric()` function returns all NA due to presence of character data.

```{r}
as.numeric(weight)
```

There are many ways to approach this. A common approach is to first remove the characters and then use `as.numeric()`. Below we use the `sub` function to find "lbs." and replace with nothing.

```{r}
weightN <- gsub("lbs.", "", weight)
as.numeric(weightN)
```

The `parse_number()` function in the **readr** package can often take care of these situations automatically.

```{r}
readr::parse_number(weight)
```



## Change case


#### Python {-}


#### R {-}

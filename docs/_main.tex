% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Python and R},
  pdfauthor={Clay Ford, Jacob Goldstein-Greenwood, Oyinkansola Adenekan, Samantha Lomuscio},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{plainnat}
\nocite{*}

\title{Python and R}
\author{Clay Ford, Jacob Goldstein-Greenwood, Oyinkansola Adenekan, Samantha Lomuscio}
\date{2022-04-21}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{welcome}{%
\chapter*{Welcome}\label{welcome}}
\addcontentsline{toc}{chapter}{Welcome}

This book provides parallel examples in Python and R to help users of one platform more easily learn how the other platform ``works'' when it comes to data analysis.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

\hypertarget{basics}{%
\chapter{Basics}\label{basics}}

This chapter covers the very basics of Python and R.

\hypertarget{math}{%
\section{Math}\label{math}}

Mathematical operators are the same except for exponents, integer division, and remainder division (modulo).

\hypertarget{python}{%
\subsubsection*{Python}\label{python}}
\addcontentsline{toc}{subsubsection}{Python}

Python uses \texttt{**} for exponentiation, \texttt{//} for integer division, and \texttt{\%} for remainder division.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3}\OperatorTok{**}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{//} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{\%} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1
\end{verbatim}

In Python, the \texttt{+} operator can also be used to combine strings. See this TBD section.

\hypertarget{r}{%
\subsubsection*{R}\label{r}}
\addcontentsline{toc}{subsubsection}{R}

Python uses \texttt{\^{}} for exponentiation, \texttt{\%/\%} for integer division, and \texttt{\%\%} for remainder division.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3}\SpecialCharTok{\^{}}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \SpecialCharTok{\%/\%} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \SpecialCharTok{\%\%} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\hypertarget{missing-values}{%
\section{Missing values}\label{missing-values}}

Python and R represent missing values differently, and the distinction is worth keeping in mind, as missing values will crop up throughout this book---some code examples intake or output data that are entirely or partially missing. In Python, a standard indicator for a missing value in a data set is \texttt{NaN}.* In R, missing values are generally indicated by \texttt{NA}. \texttt{NaN} does appear in R as well, but R reserves \texttt{NaN} to indicate values that are not technically absent but that are not defined and/or that can't be represented with numbers; e.g., \texttt{Inf/Inf}.

\hypertarget{assignment}{%
\section{Assignment}\label{assignment}}

Python uses \texttt{=} for assignment, while R can use either \texttt{=} or \texttt{\textless{}-} for assignment. The latter ``assignment arrow'' is preferred in most R style guides to distinguish between assignment and setting the value of a function argument. According to R's documentation, ``The operator \texttt{\textless{}-} can be used anywhere, whereas the operator \texttt{=} is only allowed at the top level (e.g., in the complete expression typed at the command prompt) or as one of the subexpressions in a braced list of expressions.'' See \texttt{?assignOps}.

\hypertarget{python-1}{%
\subsubsection*{Python}\label{python-1}}
\addcontentsline{toc}{subsubsection}{Python}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{12}
\end{Highlighting}
\end{Shaded}

\hypertarget{r-1}{%
\subsubsection*{R}\label{r-1}}
\addcontentsline{toc}{subsubsection}{R}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{12}
\end{Highlighting}
\end{Shaded}

\hypertarget{printing-a-value}{%
\section{Printing a value}\label{printing-a-value}}

To see the value of an object created via assignment, you can simply enter the object at the console and hit enter for both Python and R, though it is common in Python to explicitly use the \texttt{print()} function.

\hypertarget{python-2}{%
\subsubsection*{Python}\label{python-2}}
\addcontentsline{toc}{subsubsection}{Python}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 12
\end{verbatim}

\hypertarget{r-2}{%
\subsubsection*{R}\label{r-2}}
\addcontentsline{toc}{subsubsection}{R}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 12
\end{verbatim}

\hypertarget{packages}{%
\section{Packages}\label{packages}}

User-created functions can be bundled and distributed as packages. Packages need to be installed only once. Thereafter they're ``imported'' (Python) or ``loaded'' (R) in each new session when needed.

Packages with large user bases are often updated to add functionality and fix bugs. The updates are not automatically installed. Staying apprised of library/package updates can be challenging. Some suggestions are following developers on Twitter, signing up for newsletters, or periodically checking to see what updates are available.

Packages often depend on other packages. These are known as ``dependencies.'' Sometimes packages are updated to accommodate changes to other packages they depend on.

\hypertarget{python-3}{%
\subsubsection*{Python}\label{python-3}}
\addcontentsline{toc}{subsubsection}{Python}

When you download Python, you gain access to The Python Standard Library. This library includes several datatypes and functions for storing data, performing mathematical operations, and beyond. Commonly used datatypes include \emph{list} and \emph{range}. As you can see below, you do not need to import data types from the Standard Python Library.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_list }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ idx }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{):}
\NormalTok{  my\_list.append(idx)}
\BuiltInTok{print}\NormalTok{(my\_list)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [0, 1, 2, 3, 4]
\end{verbatim}

Libraries contain modules, groups of functions. To use functions from modules in the Python Standard Library, users must import the appropriate module. Examples include math and itertools, which both include several functions for a range of operations.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ math}
\NormalTok{one }\OperatorTok{=} \DecValTok{1}
\NormalTok{two }\OperatorTok{=} \DecValTok{2}
\BuiltInTok{print}\NormalTok{(math.}\BuiltInTok{pow}\NormalTok{(two, one))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2.0
\end{verbatim}

Users can also download 100s of libraries outside of the Standard Python Library. Python libraries are also called packages. Popular libraries include numpy, used for operations on arrays/vectors and pandas, used for data analysis. The following code is an example of importing a Python library, NumPy, into a Python script.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{my\_array }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(my\_array)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1 2 3]
\end{verbatim}

To use Python libraries outside the Python Standard Library, they must be installed in the Python environment.

Anaconda is the most popular Python library manager. Anaconda allows you to use and create Python virtual environments and install libraries to these environments. A Python virtual environment is a collection of libraries isolated from other virtual environments. These environments allow users to seamlessly organize programming projects.

You can download Anaconda from the following link: \url{https://www.anaconda.com/products/individual}. When you download Anaconda, you have access to the Anaconda Navigator, a graphical user interface, and the Anaconda Prompt, a command prompt. Anaconda comes with an automatic environment called ``base''.

The following screenshot illustrates how to install a library to an environment using the Anaconda GUI. Using the drop down menu, navigate to ``Not installed''. Then, select the desired library from the list. The search bar can be used to search for libraries. Finally, click the green ``Apply'' button to install the package.

\includegraphics[width=26.67in]{images/anaconda_gui_install}

The following screenshot illustrates how to install a library to the ``base'' environment using the Anaconda Command Prompt.

\includegraphics[width=26.67in]{images/anaconda_command_install}

Sometimes the commands to download libraries are not as simple as shown in the above example. The Anaconda website provides commands for how to download popular Python libraries.

\hypertarget{r-3}{%
\subsubsection*{R}\label{r-3}}
\addcontentsline{toc}{subsubsection}{R}

The main repository for R packages is the \href{https://cran.r-project.org/}{Comprehensive R Archive Network} (CRAN). Another repository is \href{https://www.bioconductor.org/}{Bioconductor}, which provides tools for working with genomic data. Many packages are also distributed on \href{https://github.com/}{GitHub}.

To install packages from CRAN use the \texttt{install.packages()} function. In RStudio, you can also go to Tools\ldots Install Packages\ldots{} for a dialog that will auto-complete package names as you type.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# install the vcd package, a package for Visualizing Categorical Data}
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"vcd"}\NormalTok{)}

\CommentTok{\# load the package}
\FunctionTok{library}\NormalTok{(vcd)}

\CommentTok{\# see which packages on your computer have updates available}
\FunctionTok{old.packages}\NormalTok{()}

\CommentTok{\# download and install available package updates;}
\CommentTok{\# set ask = TRUE to verify installation of each package}
\FunctionTok{update.packages}\NormalTok{(}\AttributeTok{ask =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To install R packages from GitHub use the \texttt{install\_github()} function from the \textbf{devtools} package. You need to include the username of the repo owner followed by a forward slash and the name of the package. Typing two colons between a package and a function in the package allows you to use that function without loading the package. That's how we use \texttt{install\_github()} below.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"devtools"}\NormalTok{)}
\NormalTok{devtools}\SpecialCharTok{::}\FunctionTok{install\_github}\NormalTok{(}\StringTok{"username/packagename"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Occasionally when installing package updates you will be asked, ``Do you want to install from sources the package which needs compilation?'' R packages on CRAN are \emph{compiled} for Mac and Windows operating systems. That can take a day or two after a package has been submitted to CRAN. If you try to install a package that has not been compiled then you'll get asked the question above. If you click \emph{Yes}, R will try to compile the package on your computer. This will only work if you have the required build tools on your computer. For Windows this means having \href{https://cran.r-project.org/bin/windows/Rtools/}{Rtools} installed. Mac users should already have the necessary build tools. Unless you absolutely need the latest version of a package, it's probably fine to click \emph{No}.

\hypertarget{logic}{%
\section{Logic}\label{logic}}

Python and R share the same relational operators for making comparisons:

\begin{itemize}
\tightlist
\item
  \texttt{==} (equals)
\item
  \texttt{!=} (not equal to)
\item
  \texttt{\textless{}} (less than)
\item
  \texttt{\textless{}=} (less than or equal to)
\item
  \texttt{\textgreater{}} (greater than)
\item
  \texttt{\textgreater{}=} (greater than or equal to)
\end{itemize}

Likewise they share the same operators for logical AND and OR:

\begin{itemize}
\tightlist
\item
  \texttt{\&} (AND)
\item
  \texttt{\textbar{}} (OR)
\end{itemize}

However R also has \texttt{\&\&} and \texttt{\textbar{}\textbar{}} operators for programming control-flow.

Python and R have different operators for negation. Python uses \texttt{not}. R uses \texttt{!}.

\hypertarget{python-4}{%
\subsubsection*{Python}\label{python-4}}
\addcontentsline{toc}{subsubsection}{Python}

These Python operators can be used to compare arrays to single values or other arrays. This operation returns an array containing true and false values.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np }

\CommentTok{\# Comparison of array to single value}
\NormalTok{x1 }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{9}\NormalTok{,}\DecValTok{12}\NormalTok{,}\DecValTok{11}\NormalTok{,}\DecValTok{6}\NormalTok{])}
\NormalTok{x1 }\OperatorTok{\textless{}} \DecValTok{8}

\CommentTok{\# Comparison of array to another array }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array([ True,  True, False, False, False,  True])
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x2 }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{14}\NormalTok{,}\DecValTok{15}\NormalTok{,}\DecValTok{7}\NormalTok{])}
\NormalTok{x1 }\OperatorTok{\textgreater{}}\NormalTok{ x2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array([False,  True,  True, False, False, False])
\end{verbatim}

We can make multiple comparisons with the AND (\texttt{and}) and OR (\texttt{or}) operators. An important thing to note is that the \texttt{and} operator is inclusive, meaning that all statements must be true to return \texttt{True}. The \texttt{or} operator is exclusive, meaning that at least one of the statements joined by \texttt{or} must be true to return \texttt{True}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{=}\DecValTok{5} 
\NormalTok{y}\OperatorTok{=} \DecValTok{4}

\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{6} \KeywordTok{and}\NormalTok{ y }\OperatorTok{\textless{}} \DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## False
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{6} \KeywordTok{or}\NormalTok{ y }\OperatorTok{\textless{}} \DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## True
\end{verbatim}

True and False operators have numeric values of 1 and 0, respectively. We can sum and average these values.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Sum of values greater than 10 in array x2}
\NormalTok{np.}\BuiltInTok{sum}\NormalTok{(x2 }\OperatorTok{\textgreater{}} \DecValTok{10}\NormalTok{)}

\CommentTok{\# Portion of values greater than 10 in array x2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.mean(x2 }\OperatorTok{\textgreater{}} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0.3333333333333333
\end{verbatim}

\hypertarget{r-4}{%
\subsubsection*{R}\label{r-4}}
\addcontentsline{toc}{subsubsection}{R}

R's relational operators allow comparisons between a vector and a single value, or comparisons between two vectors. The result is a vector of TRUE/FALSE values.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# vector compared with value}
\NormalTok{x1 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{x1 }\SpecialCharTok{\textless{}} \DecValTok{8}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE  TRUE FALSE FALSE FALSE  TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# vector compared with vector}
\NormalTok{x2 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\NormalTok{x1 }\SpecialCharTok{\textgreater{}}\NormalTok{ x2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE  TRUE  TRUE FALSE FALSE FALSE
\end{verbatim}

Comparisons with NA (missing value) results in NA.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{9}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{x1 }\SpecialCharTok{\textless{}} \DecValTok{8}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE  TRUE FALSE    NA FALSE  TRUE
\end{verbatim}

Multiple comparisons can be made with AND (\texttt{\&}) and OR (\texttt{\textbar{}}) operators.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x2 }\SpecialCharTok{\textgreater{}} \DecValTok{3} \SpecialCharTok{\&}\NormalTok{ x2 }\SpecialCharTok{\textless{}} \DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE  TRUE  TRUE FALSE FALSE  TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x2 }\SpecialCharTok{\textless{}} \DecValTok{3} \SpecialCharTok{|}\NormalTok{ x2 }\SpecialCharTok{\textgreater{}} \DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE FALSE FALSE  TRUE  TRUE FALSE
\end{verbatim}

TRUE/FALSE values in R have numeric values of 1/0. This allows us to sum and average them. (Note: an average of 0 and 1 values is the proportion of 1's.)

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# sum of values greater than 10}
\FunctionTok{sum}\NormalTok{(x2 }\SpecialCharTok{\textgreater{}} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# proportion of values greater than 10}
\FunctionTok{mean}\NormalTok{(x2 }\SpecialCharTok{\textgreater{}} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.3333333
\end{verbatim}

Use the \texttt{!} operator for negation. This allows to check for something that is NOT TRUE.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# which value are NOT less than 6}
\SpecialCharTok{!}\NormalTok{x2 }\SpecialCharTok{\textless{}} \DecValTok{6}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE FALSE  TRUE  TRUE  TRUE  TRUE
\end{verbatim}

See the \texttt{?Comparison} and \texttt{?Logic} help pages for more information.

\hypertarget{generating-a-sequence-of-values}{%
\section{Generating a sequence of values}\label{generating-a-sequence-of-values}}

In Python, one option for generating a sequence of values is \texttt{arange()} from \textbf{NumPy}. In R, a common approach is to use \texttt{seq()}. The sequences can be incremented by indicating a \texttt{step} argument in \texttt{arange()} or a \texttt{by} argument in \texttt{seq()}. Be aware that the end of the start/stop interval in \texttt{arange()} is \emph{open}, but both sides of the from/to interval in \texttt{seq()} are \emph{closed}.

\hypertarget{python-5}{%
\subsubsection*{Python}\label{python-5}}
\addcontentsline{toc}{subsubsection}{Python}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(start }\OperatorTok{=} \DecValTok{1}\NormalTok{, stop }\OperatorTok{=} \DecValTok{11}\NormalTok{, step }\OperatorTok{=} \DecValTok{2}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array([1, 3, 5, 7, 9])
\end{verbatim}

\hypertarget{r-5}{%
\subsubsection*{R}\label{r-5}}
\addcontentsline{toc}{subsubsection}{R}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\AttributeTok{from =} \DecValTok{1}\NormalTok{, }\AttributeTok{to =} \DecValTok{11}\NormalTok{, }\AttributeTok{by =} \DecValTok{2}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  3  5  7  9 11
\end{verbatim}

\hypertarget{calculating-means-and-medians}{%
\section{Calculating means and medians}\label{calculating-means-and-medians}}

The \textbf{NumPy} Python library has functions for calculating means and medians, and base R has functions for doing the same.

\hypertarget{python-6}{%
\subsubsection*{Python}\label{python-6}}
\addcontentsline{toc}{subsubsection}{Python}

Mean, using function from \textbf{NumPy} library

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{90}\NormalTok{, }\DecValTok{105}\NormalTok{, }\DecValTok{110}\NormalTok{]}
\NormalTok{x\_avg }\OperatorTok{=}\NormalTok{ np.mean(x)}
\BuiltInTok{print}\NormalTok{(x\_avg)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 101.66666666666667
\end{verbatim}

Median, using function from \textbf{NumPy} library

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{98}\NormalTok{, }\DecValTok{102}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{304}\NormalTok{]}
\NormalTok{x\_med }\OperatorTok{=}\NormalTok{ np.median(x)}
\BuiltInTok{print}\NormalTok{(x\_med)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 98.0
\end{verbatim}

\hypertarget{r-6}{%
\subsubsection*{R}\label{r-6}}
\addcontentsline{toc}{subsubsection}{R}

Mean, using function from base R

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{90}\NormalTok{, }\DecValTok{105}\NormalTok{, }\DecValTok{110}\NormalTok{)}
\NormalTok{x\_avg }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(x)}
\NormalTok{x\_avg}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 101.6667
\end{verbatim}

Median, using function from base R

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{98}\NormalTok{, }\DecValTok{102}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{304}\NormalTok{)}
\NormalTok{x\_med }\OtherTok{\textless{}{-}} \FunctionTok{median}\NormalTok{(x)}
\NormalTok{x\_med}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 98
\end{verbatim}

\hypertarget{writing-your-own-functions}{%
\section{Writing your own functions}\label{writing-your-own-functions}}

Python and R allow and encourage users to create their own functions. Functions can be created, named, and stored in memory and used throughout a session. Or they can be created on-the-fly ``anonymously'' and used once.

\hypertarget{python-7}{%
\subsubsection*{Python}\label{python-7}}
\addcontentsline{toc}{subsubsection}{Python}

Functions in Python are defined by using the \texttt{def} keyword followed by the name we choose for our function with its arguments inside parentheses. We must include a \texttt{return()} statement after the body of our function to indicate the end of the function. The return statement takes an optional argument in its parentheses that will be the output of the function. Here we create a function to calculate the standard error of a mean (SEM) and call it \texttt{SEM}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ SEM(x):}
  \ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np }\CommentTok{\# import statement included inside the function to ensure it\textquotesingle{}s always imported}
\NormalTok{  s }\OperatorTok{=}\NormalTok{ x.std(ddof}\OperatorTok{=}\DecValTok{1}\NormalTok{) }\CommentTok{\# find standard deviation of the data, specify delta degrees of freedom as 1 (makes denominator n{-}1 not n)}
\NormalTok{  n }\OperatorTok{=}\NormalTok{ x.shape[}\DecValTok{0}\NormalTok{] }\CommentTok{\# extract the length of the input array}
\NormalTok{  sem }\OperatorTok{=}\NormalTok{ s }\OperatorTok{/}\NormalTok{ np.sqrt(n) }\CommentTok{\# calculate the SEM}
  \ControlFlowTok{return}\NormalTok{(sem) }\CommentTok{\# return the calculated SEM value}
\end{Highlighting}
\end{Shaded}

Now let's try our function out on some test data.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{7}\NormalTok{,}\DecValTok{9}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{7}\NormalTok{])}
\NormalTok{SEM(d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0.7412035591181296
\end{verbatim}

Oftentimes functions have built-in error-checking that returns messages describing the error. Here we show a simple error-check to ensure that the argument passed to our function is a number.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ SEM(x):}
  \ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
  
  \ControlFlowTok{if}\NormalTok{ np.issubdtype(x.dtype,np.number)}\OperatorTok{==}\VariableTok{False}\NormalTok{:}
    \ControlFlowTok{raise} \PreprocessorTok{ValueError}\NormalTok{(}\StringTok{"Data must be numeric"}\NormalTok{)}
  
\NormalTok{  s }\OperatorTok{=}\NormalTok{ x.std(ddof}\OperatorTok{=}\DecValTok{1}\NormalTok{) }
\NormalTok{  n }\OperatorTok{=}\NormalTok{ x.shape[}\DecValTok{0}\NormalTok{] }
\NormalTok{  sem }\OperatorTok{=}\NormalTok{ s }\OperatorTok{/}\NormalTok{ np.sqrt(n) }
  \ControlFlowTok{return}\NormalTok{(sem) }
\end{Highlighting}
\end{Shaded}

Python functions can return more than one result. It will output the results into a \texttt{tuple}. A tuple is a data structure very similar to a list, but it is immutable - we cannot change the order of the entries. Here we make our function return both the mean and the SEM of our data.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ SEM(x):}
  \ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
  
  \ControlFlowTok{if}\NormalTok{ np.issubdtype(x.dtype,np.number)}\OperatorTok{==}\VariableTok{False}\NormalTok{:}
    \ControlFlowTok{raise} \PreprocessorTok{ValueError}\NormalTok{(}\StringTok{"Data must be numeric"}\NormalTok{)}
  
\NormalTok{  s }\OperatorTok{=}\NormalTok{ x.std(ddof}\OperatorTok{=}\DecValTok{1}\NormalTok{) }
\NormalTok{  n }\OperatorTok{=}\NormalTok{ x.shape[}\DecValTok{0}\NormalTok{] }
\NormalTok{  sem }\OperatorTok{=}\NormalTok{ s }\OperatorTok{/}\NormalTok{ np.sqrt(n) }
  
\NormalTok{  m }\OperatorTok{=}\NormalTok{ np.mean(x)}
  \ControlFlowTok{return}\NormalTok{(sem,m) }
\end{Highlighting}
\end{Shaded}

\hypertarget{r-7}{%
\subsubsection*{R}\label{r-7}}
\addcontentsline{toc}{subsubsection}{R}

Functions in R can be created and named using \texttt{function()}. Add arguments inside the parentheses. Longer functions with multiple lines can be wrapped in curly braces \texttt{\{\}}.

Below we create a function to calculate the standard error of a mean (SEM) and name it \texttt{sem}. It takes one argument: \texttt{x}, a vector of numbers. Both the function name and argument name(s) can be whatever we like, as long as they follow \href{https://cran.r-project.org/doc/manuals/r-release/R-intro.html\#R-commands_003b-case-sensitivity-etc}{R's naming conventions}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sem }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  s }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(x)}
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(x)}
\NormalTok{  s}\SpecialCharTok{/}\FunctionTok{sqrt}\NormalTok{(n)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now we can try it out on some test data.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{7}\NormalTok{,}\DecValTok{9}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{7}\NormalTok{)}
\FunctionTok{sem}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.7412036
\end{verbatim}

Functions that will be used on different data and/or by different users often need built-in error-checking to return informative error messages. This simple example checks if the data are not numeric and returns a special error message.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sem }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x)\{}
  \ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.numeric}\NormalTok{(x)) }\FunctionTok{stop}\NormalTok{(}\StringTok{"x must be numeric"}\NormalTok{)}
\NormalTok{  s }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(x)}
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(x)}
\NormalTok{  s}\SpecialCharTok{/}\FunctionTok{sqrt}\NormalTok{(n)}
\NormalTok{\}}
\FunctionTok{sem}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{, }\StringTok{"a"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in sem(c(1, 4, 6, "a")): x must be numeric
\end{verbatim}

R functions can also return more than one result. Below we return a list that holds the mean and SEM, but we could also return a vector, a data frame, or other data structure. Notice we also add an additional argument, \texttt{...}, known as the three dots argument. This allows us to pass arguments for \texttt{sd} and \texttt{mean} directly through our own function. Below we pass through \texttt{na.rm\ =\ TRUE} to drop missing values.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sem }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, ...)\{}
  \ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.numeric}\NormalTok{(x)) }\FunctionTok{stop}\NormalTok{(}\StringTok{"x must be numeric"}\NormalTok{)}
\NormalTok{  s }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(x, ...)}
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(x)}
\NormalTok{  se }\OtherTok{\textless{}{-}}\NormalTok{ s}\SpecialCharTok{/}\FunctionTok{sqrt}\NormalTok{(n)}
\NormalTok{  mean }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(x, ...)}
  \FunctionTok{list}\NormalTok{(}\AttributeTok{mean =}\NormalTok{ mean, }\AttributeTok{SEM =}\NormalTok{ se)}
\NormalTok{\}}

\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{8}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\FunctionTok{sem}\NormalTok{(d, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $mean
## [1] 5.125
## 
## $SEM
## [1] 0.7855339
\end{verbatim}

Functions can also be created on-the-fly as ``anonymous'' functions. This simply means the functions are not saved as objects in memory. These are often used with R's family of \texttt{apply} functions. As before, the functions can be created with \texttt{function()}. We can also use the backslash \texttt{\textbackslash{}} as a shorthand for \texttt{function()}. We demonstrate both below with a data frame.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# generate some example data}
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x1 =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{),}
                \AttributeTok{x2 =} \FunctionTok{c}\NormalTok{(}\DecValTok{6}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{),}
                \AttributeTok{x3 =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{4}\NormalTok{))}
\NormalTok{d}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   x1 x2 x3
## 1  3  6  1
## 2  5  9  9
## 3  7  8  9
## 4  1  9  7
## 5  5  2  8
## 6  4  5  4
\end{verbatim}

Now find the standard error of the mean for the three columns using an anonymous function with \texttt{lapply()}. The ``l'' means the result will be a list. We apply the function to each column of the data frame.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{lapply}\NormalTok{(d, }\ControlFlowTok{function}\NormalTok{(x)}\FunctionTok{sd}\NormalTok{(x)}\SpecialCharTok{/}\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{length}\NormalTok{(x)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $x1
## [1] 0.8333333
## 
## $x2
## [1] 1.118034
## 
## $x3
## [1] 1.308094
\end{verbatim}

We can also use the backslash as a shorthand for \texttt{function()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{lapply}\NormalTok{(d, \textbackslash{}(x)}\FunctionTok{sd}\NormalTok{(x)}\SpecialCharTok{/}\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{length}\NormalTok{(x)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $x1
## [1] 0.8333333
## 
## $x2
## [1] 1.118034
## 
## $x3
## [1] 1.308094
\end{verbatim}

\hypertarget{data-structures}{%
\chapter{Data Structures}\label{data-structures}}

This chapter compares and contrasts data structures in Python and R.

\hypertarget{one-dimensional-data}{%
\section{One-dimensional data}\label{one-dimensional-data}}

A one-dimensional data structure can be visualized as a column in a spreadsheet or as a list of values.

\hypertarget{python-8}{%
\subsubsection*{Python}\label{python-8}}
\addcontentsline{toc}{subsubsection}{Python}

There are many ways to organize one-dimensional data in Python. Three of the most common one-dimensional data structures are lists, numpy arrays, and pandas Series. All three are ordered and mutable, and can contain data of different types.

Lists in Python do not need to be explicitly declared; they are indicated by the use of square brackets.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\StringTok{\textquotesingle{}hello\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Values in lists can be accessed by using square brackets. Python indexing begins at 0, so to extract the first element, we would use the index 0. Python also allows for negative indexing; using an index of -1 will return the last value in the list. Indexing a range in Python is not inclusive of the last index.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# extract first element}
\NormalTok{l[}\DecValTok{0}\NormalTok{]}

\CommentTok{\#extract last element}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}

\CommentTok{\# extract 2nd and 3rd elements}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'hello'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l[}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [2, 3]
\end{verbatim}

Numpy arrays, on the other hand, need to be declared using the \texttt{numpy.array()} function, and the \textbf{numpy} package needs to be imported.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{arr }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\StringTok{\textquotesingle{}hello\textquotesingle{}}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(arr)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## ['1' '2' '3' 'hello']
\end{verbatim}

Accessing data in a numpy array is the same as indexing a list.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# extract first element }
\NormalTok{arr[}\DecValTok{0}\NormalTok{]}

\CommentTok{\# extract last element}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## '1'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}

\CommentTok{\# extract 2nd and 3rd elements}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'hello'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr[}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array(['2', '3'], dtype='<U11')
\end{verbatim}

Pandas Series also need to be declared using the \texttt{pandas.Series()} function. Like \textbf{numpy}, the \textbf{pandas} package must be imported as well. The pandas package is built on numpy, so we can input data into a pandas Series using a numpy array. We can extract data from the Series by using the index similar to indexing a list and numpy array.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd }
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{data }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\StringTok{"hello"}\NormalTok{])}
\NormalTok{ser1 }\OperatorTok{=}\NormalTok{ pd.Series(data)}
\BuiltInTok{print}\NormalTok{(ser1)}

\CommentTok{\# extract first element }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0        1
## 1        2
## 2        3
## 3    hello
## dtype: object
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ser1[}\DecValTok{0}\NormalTok{]}

\CommentTok{\# extract 2nd and 3rd elements }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## '1'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ser1[}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1    2
## 2    3
## dtype: object
\end{verbatim}

To extract the last element of a pandas Series using \texttt{-1}, we need to use the \texttt{iloc} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ser1.iloc[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'hello'
\end{verbatim}

We can relabel the indices of the Series to whatever we like using the \texttt{index} attribute within the \texttt{Series} function.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd }
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{ser2 }\OperatorTok{=}\NormalTok{ pd.Series(data, index}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(ser2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## a        1
## b        2
## c        3
## d    hello
## dtype: object
\end{verbatim}

We can then use our own specified indices to select and index our data. Indexing with our labels can be done in two ways. One similar to indexing arrays and lists with square brackets using the \texttt{.loc} function, and the other follows this form: \texttt{Series.label\_name}.

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{\# extract element in row b}
\NormalTok{ser2.loc[}\StringTok{"b"}\NormalTok{]}

\CommentTok{\# extract elements from row b to the end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## '2'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ser2.loc[}\StringTok{"b"}\NormalTok{:]}

\CommentTok{\# extract element in row "d"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## b        2
## c        3
## d    hello
## dtype: object
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ser2.d}

\CommentTok{\# extract element in row "b"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'hello'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ser2.b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## '2'
\end{verbatim}

One thing to note is that mathematical operations cannot be carried out on lists, but they can be carried out on numpy arrays and pandas Series. In general, lists are better for short data sets that you will not be operating on mathematically. Numpy arrays and pandas Series are better for long data sets, and for data sets that will be operated on mathematically.

\hypertarget{r-8}{%
\subsubsection*{R}\label{r-8}}
\addcontentsline{toc}{subsubsection}{R}

In R a one-dimensional data structure is called a \emph{vector}. We can create a vector using the \texttt{c()} function. A vector in R can only contain one type of data (all numbers, all strings, etc). The columns of data frames are vectors. If multiple types of data are put into a vector, the data will be coerced according to the hierarchy \texttt{logical} \textless{} \texttt{integer} \textless{} \texttt{double} \textless{} \texttt{complex} \textless{} \texttt{character}. This means if you mix, say, integers and character data, all the data will be coerced to character.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{23}\NormalTok{, }\DecValTok{43}\NormalTok{, }\DecValTok{55}\NormalTok{)}
\NormalTok{x1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 23 43 55
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# all values coerced to character}
\NormalTok{x2 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{23}\NormalTok{, }\DecValTok{43}\NormalTok{, }\StringTok{\textquotesingle{}hi\textquotesingle{}}\NormalTok{)}
\NormalTok{x2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "23" "43" "hi"
\end{verbatim}

Values in a vector can be accessed by position using indexing brackets. R indexes elements of a vector starting at 1. Index values are inclusive. For example, \texttt{2:3} selects the second and third elements.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# extract the 2nd value}
\NormalTok{x1[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 43
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# extract the 2nd and 3rd value}
\NormalTok{x1[}\DecValTok{2}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 43 55
\end{verbatim}

\hypertarget{two-dimensional-data}{%
\section{Two-dimensional data}\label{two-dimensional-data}}

Two-dimensional data are rectangular in nature, consisting of rows and columns. These can be the type of data you might find in a spreadsheet with a mix of data types in columns; they can also be matrices as you might encounter in matrix algebra.

\hypertarget{python-9}{%
\subsubsection*{Python}\label{python-9}}
\addcontentsline{toc}{subsubsection}{Python}

In Python, two common two-dimensional data structures include the \emph{numpy array} and the \emph{pandas DataFrame}.

A two-dimensional numpy array is made in a similar way to the one-dimensional array using the \texttt{numpy.array} function.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{arr2d }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\StringTok{"hello"}\NormalTok{],[}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{,}\StringTok{"world"}\NormalTok{]])}
\BuiltInTok{print}\NormalTok{(arr2d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [['1' '2' '3' 'hello']
##  ['4' '5' '6' 'world']]
\end{verbatim}

Selecting data for a two-dimensional numpy array follows the same form as indexing a one-dimensional array.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\CommentTok{\# extract first element }
\NormalTok{arr2d[}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{]}

\CommentTok{\# extract last element }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## '1'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr2d[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}

\CommentTok{\# extract 2nd and 3rd columns}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'world'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr2d[:,}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array([['2', '3'],
##        ['5', '6']], dtype='<U11')
\end{verbatim}

A pandas DataFrame is made using the \texttt{pandas.DataFrame} function in a similar way to the pandas Series.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{data }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\StringTok{"hello"}\NormalTok{],[}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{,}\StringTok{"world"}\NormalTok{]])}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(data)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    0  1  2      3
## 0  1  2  3  hello
## 1  4  5  6  world
\end{verbatim}

Selecting data from a DataFrame is similar to that of the Series.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# extract first element }
\NormalTok{df.loc[}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{]}

\CommentTok{\# extract column 1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## '1'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.loc[}\DecValTok{0}\NormalTok{]}

\CommentTok{\# extract row 1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0        1
## 1        2
## 2        3
## 3    hello
## Name: 0, dtype: object
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.loc[}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## '1'
\end{verbatim}

Like the pandas Series, we can change the indices and the column names of the DataFrame and can use those to select and index our data.

We change the indices again using the \texttt{index} attribute in the \texttt{pandas.DataFrame} function:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{data }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\StringTok{"hello"}\NormalTok{],[}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{,}\StringTok{"world"}\NormalTok{]])}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(data, index}\OperatorTok{=}\NormalTok{[}\StringTok{"a"}\NormalTok{,}\StringTok{"b"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    0  1  2      3
## a  1  2  3  hello
## b  4  5  6  world
\end{verbatim}

We can change the column names using the \texttt{columns} attribute in the \texttt{pandas.DataFrame} function:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{data }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\StringTok{"hello"}\NormalTok{],[}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{,}\StringTok{"world"}\NormalTok{]])}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(data, index}\OperatorTok{=}\NormalTok{[}\StringTok{"a"}\NormalTok{,}\StringTok{"b"}\NormalTok{], columns}\OperatorTok{=}\NormalTok{[}\StringTok{"column 1"}\NormalTok{,}\StringTok{"column 2"}\NormalTok{, }\StringTok{"column 3"}\NormalTok{, }\StringTok{"column 4"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   column 1 column 2 column 3 column 4
## a        1        2        3    hello
## b        4        5        6    world
\end{verbatim}

One thing to note is that numpy arrays can actually have N dimensions, whereas pandas DataFrames can only have two. Numpy arrays will be the better choice for data with more than two dimensions.

\hypertarget{r-9}{%
\subsubsection*{R}\label{r-9}}
\addcontentsline{toc}{subsubsection}{R}

Two-dimensional data structures in R include the \emph{matrix} and \emph{data frame}. A matrix can contain only one data type. A data frame can contain multiple vectors, each of which can consist of different data types.

Create a matrix with the \texttt{matrix()} function. Create a data frame with the \texttt{data.frame()} function. Most imported data comes into R as a data frame.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# matrix; populated down by column by default}
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\AttributeTok{data =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{7}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{2}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{2}\NormalTok{)}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    5
## [2,]    3    7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# data frame}
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{name =} \FunctionTok{c}\NormalTok{(}\StringTok{"Rob"}\NormalTok{, }\StringTok{"Cindy"}\NormalTok{),}
                \AttributeTok{age =} \FunctionTok{c}\NormalTok{(}\DecValTok{35}\NormalTok{, }\DecValTok{37}\NormalTok{))}
\NormalTok{d}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    name age
## 1   Rob  35
## 2 Cindy  37
\end{verbatim}

Values in a matrix and data frame can be accessed by position using indexing brackets. The first number(s) refers to rows; the second number(s) refers to columns. Leaving row or column numbers empty selects all rows or columns.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# extract value in row 1, column 2}
\NormalTok{m[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# extract values in row 2}
\NormalTok{d[}\DecValTok{2}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    name age
## 2 Cindy  37
\end{verbatim}

\hypertarget{three-dimensional-and-higher-data}{%
\section{Three-dimensional and higher data}\label{three-dimensional-and-higher-data}}

Three-dimensional and higher data can be visualized as multiple rectangular structures stratified by extra variables. These are sometimes referred to as \emph{arrays}. Analysts usually prefer two-dimensional data frames to arrays. Data frames can accommodate multidimensional data by including the additional dimensions as variables.

\hypertarget{python-10}{%
\subsubsection*{Python}\label{python-10}}
\addcontentsline{toc}{subsubsection}{Python}

To create a three-dimensional and higher data structure in Python, we again use a numpy array. We can think of the three-dimensional array as a stack of two-dimensional arrays. We construct this in the same way as the one- and two-dimensional arrays.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np }

\NormalTok{arr3d }\OperatorTok{=}\NormalTok{ np.array([[[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]], [[}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{], [}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]]])}
\NormalTok{arr3d}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array([[[ 1,  2,  3],
##         [ 4,  5,  6]],
## 
##        [[ 7,  8,  9],
##         [10, 11, 12]]])
\end{verbatim}

We can also construct a three-dimensional numpy array using the \texttt{reshape} function on an existing array. The argument of \texttt{reshape} is where you input your desired dimensions - strata, rows, columns. Here, the \texttt{arange} function is used to create a numpy array containing the numbers 1 through 12 (to recreate the same array shown above).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr3d\_2 }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{1}\NormalTok{,}\DecValTok{13}\NormalTok{).reshape(}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\NormalTok{arr3d\_2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array([[[ 1,  2,  3],
##         [ 4,  5,  6]],
## 
##        [[ 7,  8,  9],
##         [10, 11, 12]]])
\end{verbatim}

Indexing the three-dimensional array follows the same format as the two-dimensional arrays. Since we can think of the three-dimensional array as a stack of two-dimensional arrays, we can extract each ``stacked'' two-dimensional array. Here we extract the first of the ``stacked'' two-dimensional arrays:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# extract first strata (first "stacked" 2{-}D array)}
\NormalTok{arr3d[}\DecValTok{0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array([[1, 2, 3],
##        [4, 5, 6]])
\end{verbatim}

We can also extract entire rows and columns, and individual array elements:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# extract 1st row of 2nd strata (second "stacked" 2{-}D array)}
\NormalTok{arr3d[}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{]}

\CommentTok{\# extract 1st column of 2nd strata }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array([7, 8, 9])
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr3d[}\DecValTok{1}\NormalTok{, :, }\DecValTok{0}\NormalTok{]}

\CommentTok{\# extract the number 6 (1st strata, 2nd row, 3rd column)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array([ 7, 10])
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr3d[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 6
\end{verbatim}

The three-dimensional arrays can be converted to two-dimensional arrays again using the \texttt{reshape} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr3d\_2d }\OperatorTok{=}\NormalTok{ arr3d.reshape(}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\NormalTok{arr3d\_2d}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array([[ 1,  2,  3],
##        [ 4,  5,  6],
##        [ 7,  8,  9],
##        [10, 11, 12]])
\end{verbatim}

\hypertarget{r-10}{%
\subsubsection*{R}\label{r-10}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{array()} function in R can create three-dimensional and higher data structures. Arrays are like vectors and matrices in that they can only contain one data type. In fact matrices and arrays are sometimes described as vectors with instructions on how to layout the data.

We can specify the dimension number and size using the \texttt{dim} argument. Below we specify 2 rows, 3 columns, and 2 strata using a vector: \texttt{c(2,3,2)}. This creates a three-dimensional data structure. The data in the example are simply the numbers 1 through 12.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a1 }\OtherTok{\textless{}{-}} \FunctionTok{array}\NormalTok{(}\AttributeTok{data =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{12}\NormalTok{, }\AttributeTok{dim =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\NormalTok{a1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## , , 1
## 
##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6
## 
## , , 2
## 
##      [,1] [,2] [,3]
## [1,]    7    9   11
## [2,]    8   10   12
\end{verbatim}

Values in arrays can be accessed by position using indexing brackets.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# extract value in row 1, column 2, strata 1}
\NormalTok{a1[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# extract column 2 in both strata}
\CommentTok{\# result is returned as matrix}
\NormalTok{a1[,}\DecValTok{2}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    3    9
## [2,]    4   10
\end{verbatim}

The dimensions can be named using the \texttt{dimnames()} function. Notice the names must be a \emph{list}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dimnames}\NormalTok{(a1) }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\StringTok{"X"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"x1"}\NormalTok{, }\StringTok{"x2"}\NormalTok{), }
                     \StringTok{"Y"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"y1"}\NormalTok{, }\StringTok{"y2"}\NormalTok{, }\StringTok{"y3"}\NormalTok{), }
                     \StringTok{"Z"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"z1"}\NormalTok{, }\StringTok{"z2"}\NormalTok{))}
\NormalTok{a1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## , , Z = z1
## 
##     Y
## X    y1 y2 y3
##   x1  1  3  5
##   x2  2  4  6
## 
## , , Z = z2
## 
##     Y
## X    y1 y2 y3
##   x1  7  9 11
##   x2  8 10 12
\end{verbatim}

The \texttt{as.data.frame.table()} function can collapse an array into a two-dimensional structure that may be easier to use with standard statistical and graphical routines. The \texttt{responseName} argument allows you to provide a suitable column name for the values in the array.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.data.frame.table}\NormalTok{(a1, }\AttributeTok{responseName =} \StringTok{"value"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     X  Y  Z value
## 1  x1 y1 z1     1
## 2  x2 y1 z1     2
## 3  x1 y2 z1     3
## 4  x2 y2 z1     4
## 5  x1 y3 z1     5
## 6  x2 y3 z1     6
## 7  x1 y1 z2     7
## 8  x2 y1 z2     8
## 9  x1 y2 z2     9
## 10 x2 y2 z2    10
## 11 x1 y3 z2    11
## 12 x2 y3 z2    12
\end{verbatim}

\hypertarget{general-data-structures}{%
\section{General data structures}\label{general-data-structures}}

Both R and Python provide general ``catch-all'' data structures that can contain any number, shape, and type of data.

\hypertarget{python-11}{%
\subsubsection*{Python}\label{python-11}}
\addcontentsline{toc}{subsubsection}{Python}

The most general data structures in Python include the \emph{list} and the \emph{tuple}. Both lists and tuples are ordered collections of objects called \emph{elements}. The elements can be other lists/tuples, arrays, integers, objects, etc.

Lists are mutable objects; elements can be reordered or deleted and new elements can be added after the list has been created. Tuples, on the other hand, are immutable; once a tuple is created it cannot be changed.

Lists are created using square brackets. Here we create a list and add an element to the list after it is created using the \texttt{append} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, [}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]]}
\NormalTok{lst }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1, 2, 'a', 'b', [3, 4, 5]]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst.append(}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{)}
\NormalTok{lst}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1, 2, 'a', 'b', [3, 4, 5], 'c']
\end{verbatim}

Tuples are created using parenthesis. Here we create a tuple.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{tuple} \OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, [}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\BuiltInTok{tuple} 
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## (1, 2, 'a', 'b', [3, 4, 5])
\end{verbatim}

Let's try to use the append function to explore the immutability of the tuple. We expect to get an error.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{tuple}\NormalTok{.append(}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: 'tuple' object has no attribute 'append'
## 
## Detailed traceback:
##   File "<string>", line 1, in <module>
\end{verbatim}

We can refer to specific list/tuple elements by using square brackets. In the square brackets we put the index number of the element. The element in the first position is at index 0.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Extract the first element of the list and the tuple}
\NormalTok{lst[}\DecValTok{0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{tuple}\NormalTok{[}\DecValTok{0}\NormalTok{]}

\CommentTok{\# Extract the last element of each }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'c'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{tuple}\NormalTok{[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [3, 4, 5]
\end{verbatim}

\hypertarget{r-11}{%
\subsubsection*{R}\label{r-11}}
\addcontentsline{toc}{subsubsection}{R}

The most general data structure in R is the \emph{list}. A list is an ordered collection of objects, which are referred to as the \emph{components}. The components can be vectors, matrices, arrays, data frames, and other lists. The components are always numbered but can also have names. The results of statistical functions are often returned as lists.

We can create lists with the \texttt{list()} function. The list below contains three components: a vector named ``x'', a matrix named ``y'', and a data frame named ``z''. Notice the \texttt{m} and \texttt{d} objects were created in the two-dimensional data section earlier in this chapter.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{),}
          \AttributeTok{y =}\NormalTok{ m,}
          \AttributeTok{z =}\NormalTok{ d)}
\NormalTok{l}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $x
## [1] 1 2 3
## 
## $y
##      [,1] [,2]
## [1,]    1    5
## [2,]    3    7
## 
## $z
##    name age
## 1   Rob  35
## 2 Cindy  37
\end{verbatim}

We can refer to list components by their order number or name (if present). To use order number, use indexing brackets. Single brackets returns a list. Double brackets return the component itself.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# second element returned as list}
\NormalTok{l[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $y
##      [,1] [,2]
## [1,]    1    5
## [2,]    3    7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# second element returned as itself (matrix)}
\NormalTok{l[[}\DecValTok{2}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    5
## [2,]    3    7
\end{verbatim}

Use the \texttt{\$} operator to refer to components by name. This returns the component itself.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l}\SpecialCharTok{$}\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    5
## [2,]    3    7
\end{verbatim}

Finally it is worth noting that a data frame is a special case of a list consisting of components with the same length. The \texttt{is.list()} function returns TRUE if an object is a list and FALSE otherwise.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# object d is data frame}
\NormalTok{d}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    name age
## 1   Rob  35
## 2 Cindy  37
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    2 obs. of  2 variables:
##  $ name: chr  "Rob" "Cindy"
##  $ age : num  35 37
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# but a data frame is a list}
\FunctionTok{is.list}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\hypertarget{import-export-and-save-data}{%
\chapter{Import, Export, and Save Data}\label{import-export-and-save-data}}

This chapter reviews importing external data into Python and R, including CSV, Excel, and other structured data files. There is often more than one way to import data into Python and R. Each example below highlights one way per file type.

The data set we use for demonstration is the New York State Math Test Results by Grade from 2006 - 2011, downloaded from \href{https://catalog.data.gov/dataset/2006-2011-nys-math-test-results-by-grade-citywide-by-race-ethnicity}{data.gov} on September 30, 2021.

The final section presents approaches to exporting and saving data.

\hypertarget{csv}{%
\section{CSV}\label{csv}}

Comma separated value (CSV) files are text files with fields separated by commas. They are useful for ``rectangular'' data, where rows represent observations and columns represent variables or features.

\hypertarget{python-12}{%
\subsubsection*{Python}\label{python-12}}
\addcontentsline{toc}{subsubsection}{Python}

The \textbf{pandas} function \texttt{read\_csv()} is a common approach to importing CSV files into Python.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\NormalTok{d }\OperatorTok{=}\NormalTok{ pd.read\_csv(}\StringTok{\textquotesingle{}data/ny\_math\_test.csv\textquotesingle{}}\NormalTok{)}
\NormalTok{d.loc[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{, [}\StringTok{"Grade"}\NormalTok{, }\StringTok{"Year"}\NormalTok{, }\StringTok{"Mean Scale Score"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Grade  Year  Mean Scale Score
## 0     3  2006               700
## 1     4  2006               699
## 2     5  2006               691
\end{verbatim}

\hypertarget{r-12}{%
\subsubsection*{R}\label{r-12}}
\addcontentsline{toc}{subsubsection}{R}

There are many ways to import a csv file. A common way is to use the base R function \texttt{read.csv()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{read.csv}\NormalTok{(}\StringTok{"data/ny\_math\_test.csv"}\NormalTok{)}
\NormalTok{d[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\StringTok{"Grade"}\NormalTok{, }\StringTok{"Year"}\NormalTok{, }\StringTok{"Mean.Scale.Score"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Grade Year Mean.Scale.Score
## 1     3 2006              700
## 2     4 2006              699
## 3     5 2006              691
\end{verbatim}

Notice the spaces in the column names have been replaced with periods.

Two packages that provide alternatives to \texttt{read.csv()} are \textbf{readr} and \textbf{data.table}. The \textbf{readr} function \texttt{read\_csv()} returns a \href{https://r4ds.had.co.nz/tibbles.html}{tibble}. The \textbf{data.table} function \texttt{fread()} returns a \href{https://rdatatable.gitlab.io/data.table/articles/datatable-intro.html}{data.table}.

\hypertarget{xlsxlsx-excel}{%
\section{XLS/XLSX (Excel)}\label{xlsxlsx-excel}}

Excel files are native to Microsoft Excel. Prior to 2007, Excel files had an extension of XLS. With the launch of Excel 2007, the extension was changed to XLSX. Excel files can have multiple sheets of data. This needs to be accounted for when importing into Python and R.

\hypertarget{python-13}{%
\subsubsection*{Python}\label{python-13}}
\addcontentsline{toc}{subsubsection}{Python}

The \textbf{pandas} function \texttt{read\_excel()} is a common approach to importing Excel files into Python. The \texttt{sheet\_name} argument allows you to specify which sheet you want to import. You can specify sheet by its (zero-indexed) ordering or by its name. Since this Excel file only has one sheet we do not need to use the argument. In addition, specifying \texttt{sheet\_name=None} will read in all sheets and return a dict data structure where the \emph{key} is the sheet name and the \emph{value} is a DataFrame.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd  }
\NormalTok{d }\OperatorTok{=}\NormalTok{ pd.read\_excel(}\StringTok{\textquotesingle{}data/ny\_math\_test.xlsx\textquotesingle{}}\NormalTok{)  }
\NormalTok{d.loc[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{, [}\StringTok{"Grade"}\NormalTok{, }\StringTok{"Year"}\NormalTok{, }\StringTok{"Mean Scale Score"}\NormalTok{]]  }
\end{Highlighting}
\end{Shaded}

\hypertarget{r-13}{%
\subsubsection*{R}\label{r-13}}
\addcontentsline{toc}{subsubsection}{R}

\textbf{readxl} is a well-documented and actively maintained package for importing Excel files into R. The workhorse function is \texttt{read\_excel()}. The \texttt{sheet} argument allows you to specify which sheet you want to import. You can specify sheet by its ordering or by its name. Since this Excel file only has one sheet we do not need to use the argument.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(readxl)}
\NormalTok{d\_xls }\OtherTok{\textless{}{-}} \FunctionTok{read\_excel}\NormalTok{(}\StringTok{"data/ny\_math\_test.xlsx"}\NormalTok{)}
\NormalTok{d\_xls[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\StringTok{"Grade"}\NormalTok{, }\StringTok{"Year"}\NormalTok{, }\StringTok{"Mean Scale Score"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 3
##   Grade  Year `Mean Scale Score`
##   <chr> <dbl>              <dbl>
## 1 3      2006                700
## 2 4      2006                699
## 3 5      2006                691
\end{verbatim}

The result is a \emph{tibble}, a \href{https://tibble.tidyverse.org/}{tidyverse data frame}.

It's worth noting we can use the \texttt{range} argument to specify a range of cells to import. For example, if the top left corner of the data was B5 and the bottom right corner of the data was J54, we could enter \texttt{range="B5:J54"} to just import that section of data.

\hypertarget{json}{%
\section{JSON}\label{json}}

JSON (\textbf{J}ava\textbf{S}cript \textbf{O}bject \textbf{N}otation) is a flexible format for storing data. JSON files are text and can be viewed in any text editor. Because of their flexibility JSON files can be quite complex in the way they store data. Therefore there is no one-size-fits-all method for importing JSON files into Python or R.

\hypertarget{python-14}{%
\subsubsection*{Python}\label{python-14}}
\addcontentsline{toc}{subsubsection}{Python}

Below is one approach to importing our ``ny\_math\_test.json'' example file. We first import Python's built-in \textbf{json} package and use its \texttt{loads()} function to read in the lines of the json file. The file is accessed using the \texttt{open} function and its associated \texttt{read} method.

Next we use the \textbf{pandas} function \texttt{json\_normalize()} to convert the `data' structure of the json data into a DataFrame.

Finally we add column names to the DataFrame.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ json}
\CommentTok{\# load data using Python JSON module}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{\textquotesingle{}data/ny\_math\_test.json\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{) }\ImportTok{as}\NormalTok{ f:}
\NormalTok{    data }\OperatorTok{=}\NormalTok{ json.loads(f.read())}

\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd  }
\NormalTok{d\_json }\OperatorTok{=}\NormalTok{ pd.json\_normalize(data, record\_path }\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}data\textquotesingle{}}\NormalTok{])}

\CommentTok{\# add column names}
\NormalTok{names }\OperatorTok{=} \BuiltInTok{list}\NormalTok{()}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{23}\NormalTok{): }
\NormalTok{  names.append(data[}\StringTok{\textquotesingle{}meta\textquotesingle{}}\NormalTok{][}\StringTok{\textquotesingle{}view\textquotesingle{}}\NormalTok{][}\StringTok{\textquotesingle{}columns\textquotesingle{}}\NormalTok{][i][}\StringTok{\textquotesingle{}name\textquotesingle{}}\NormalTok{])}
\NormalTok{d\_json.columns }\OperatorTok{=}\NormalTok{ names}

\NormalTok{d\_json.loc[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{, [}\StringTok{"Grade"}\NormalTok{, }\StringTok{"Year"}\NormalTok{, }\StringTok{"Mean Scale Score"}\NormalTok{]]  }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Grade  Year Mean Scale Score
## 0     3  2006              700
## 1     4  2006              699
## 2     5  2006              691
\end{verbatim}

Again, this is just one approach that assumes we want a DataFrame.

\hypertarget{r-14}{%
\subsubsection*{R}\label{r-14}}
\addcontentsline{toc}{subsubsection}{R}

\textbf{jsonlite} is one of several R packages available for importing JSON files into R. The \texttt{read\_json()} function takes a JSON file and returns a list or data frame depending on the structure of the data file and its arguments. We set \texttt{simplifyVector\ =\ TRUE} so the data is simplified into a matrix.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(jsonlite)}
\NormalTok{d\_json }\OtherTok{\textless{}{-}} \FunctionTok{read\_json}\NormalTok{(}\StringTok{\textquotesingle{}data/ny\_math\_test.json\textquotesingle{}}\NormalTok{, }\AttributeTok{simplifyVector =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{d\_json} object is a list with two elements: ``meta'' and ``data''. The ``data'' element is a matrix that contains the data of interest. The ``meta'' element contains the column names for the data (among much else). Notice we had to ``drill down'' in the list to find the column names. We assign column names to the matrix using the \texttt{colnames()} function and then convert the matrix to a data frame using the \texttt{as.data.frame()} function.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{colnames}\NormalTok{(d\_json}\SpecialCharTok{$}\NormalTok{data) }\OtherTok{\textless{}{-}}\NormalTok{ d\_json}\SpecialCharTok{$}\NormalTok{meta}\SpecialCharTok{$}\NormalTok{view}\SpecialCharTok{$}\NormalTok{columns}\SpecialCharTok{$}\NormalTok{fieldName}
\NormalTok{d\_json }\OtherTok{\textless{}{-}} \FunctionTok{as.data.frame}\NormalTok{(d\_json}\SpecialCharTok{$}\NormalTok{data)}
\NormalTok{d\_json[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{,}\FunctionTok{c}\NormalTok{(}\StringTok{"grade"}\NormalTok{, }\StringTok{"year"}\NormalTok{, }\StringTok{"mean\_scale\_score"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   grade year mean_scale_score
## 1     3 2006              700
## 2     4 2006              699
## 3     5 2006              691
\end{verbatim}

\hypertarget{xml}{%
\section{XML}\label{xml}}

XML (e\textbf{X}tensible \textbf{M}arkup \textbf{L}anguage) is a markup language that was designed to store data. XML files are text and can be viewed in any text editor or a web browser. Because of their flexibility, XML files can be quite complex in the way they store data. Therefore there is no one-size-fits-all approach for importing XML files into Python or R.

\hypertarget{python-15}{%
\subsubsection*{Python}\label{python-15}}
\addcontentsline{toc}{subsubsection}{Python}

The \textbf{pandas} library provides the \texttt{read\_xml} function for importing XML files. The \texttt{ny\_math\_test.xml} file identifies records with nodes named ``row''. The 168 rows are nested in one node also called ``row''. Therefore we use the \texttt{xpath} argument to specify that we want to elect all row elements that are descendant of the single row element.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\NormalTok{d\_xml }\OperatorTok{=}\NormalTok{ pd.read\_xml(}\StringTok{\textquotesingle{}data/ny\_math\_test.xml\textquotesingle{}}\NormalTok{, xpath}\OperatorTok{=}\StringTok{"row//row"}\NormalTok{)}

\NormalTok{d\_xml.loc[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{, [}\StringTok{"grade"}\NormalTok{, }\StringTok{"year"}\NormalTok{, }\StringTok{"mean\_scale\_score"}\NormalTok{]]  }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   grade  year  mean_scale_score
## 0     3  2006               700
## 1     4  2006               699
## 2     5  2006               691
\end{verbatim}

\hypertarget{r-15}{%
\subsubsection*{R}\label{r-15}}
\addcontentsline{toc}{subsubsection}{R}

\textbf{xml2} is a relatively small but powerful package for importing and working with XML files. The \texttt{read\_xml()} function imports an XML file and returns a list of \emph{pointers} to XML \emph{nodes}. There are a number of ways to proceed once you import an XML file, such as using the \texttt{xml\_find\_all()} function to find nodes that match an \href{https://www.w3schools.com/xml/xpath_intro.asp}{xpath} expression. Below we take a simple approach and convert the XML nodes into a list using the \texttt{as\_list()} function that is part of the \textbf{xml2} package. Once we have the XML nodes in a list, we can use the \texttt{bind\_rows()} function in the \textbf{dplyr} package to create a data frame. Notice we have to drill down into the list to select the element that contains the data. After this we need to do one more thing: \emph{unlist} each the columns into vectors. We do this by applying the \texttt{unlist} function to each column of \texttt{d}. We save the result by assigning to \texttt{d{[}{]}}, which overwrites each element (or column) of \texttt{d} with the unlisted result.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(xml2)}
\NormalTok{d\_xml }\OtherTok{\textless{}{-}} \FunctionTok{read\_xml}\NormalTok{(}\StringTok{\textquotesingle{}data/ny\_math\_test.xml\textquotesingle{}}\NormalTok{)}
\NormalTok{d\_list }\OtherTok{\textless{}{-}} \FunctionTok{as\_list}\NormalTok{(d\_xml)}
\NormalTok{d }\OtherTok{\textless{}{-}}\NormalTok{ dplyr}\SpecialCharTok{::}\FunctionTok{bind\_rows}\NormalTok{(d\_list}\SpecialCharTok{$}\NormalTok{response}\SpecialCharTok{$}\NormalTok{row)}
\NormalTok{d[] }\OtherTok{\textless{}{-}} \FunctionTok{lapply}\NormalTok{(d, unlist)}
\NormalTok{d[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{,}\FunctionTok{c}\NormalTok{(}\StringTok{"grade"}\NormalTok{, }\StringTok{"year"}\NormalTok{, }\StringTok{"mean\_scale\_score"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 3
##   grade year  mean_scale_score
##   <chr> <chr> <chr>           
## 1 3     2006  700             
## 2 4     2006  699             
## 3 5     2006  691
\end{verbatim}

The result is a \emph{tibble}, a \href{https://tibble.tidyverse.org/}{tidyverse data frame}. We would most likely want to proceed to converting certain columns to numeric.

\hypertarget{exportingwritingsaving-data-and-variables}{%
\section{Exporting/Writing/Saving data and variables}\label{exportingwritingsaving-data-and-variables}}

There are several ways to export/write/save files from Python and R. The following examples highlight some of these ways.

\hypertarget{python-16}{%
\subsubsection*{Python}\label{python-16}}
\addcontentsline{toc}{subsubsection}{Python}

The pandas function \texttt{to\_csv()} saves a pandas DataFrame as a csv file.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# pass a file name to the function}
\NormalTok{d.to\_csv(}\StringTok{"data.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The Python package \textbf{pickle} allows you to write (save) any object from the Python environment and read (load) any object you have written into the Python environment.

The following code writes to a pickle file. The first line opens the file object being written to. In the \texttt{open} function, `file\_name' specifies the file path of the file object. Then, `wb' stands for `write binary', which means the file is being written in binary form (1s and 0s). After the \emph{as} keyword, `file\_', is the user selected name of the file object.

The second line uses the \texttt{pickle.dump()} function. This function requires two arguments: the object being written and the name of the file object.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pickle}

\CommentTok{\# define the file name}
\NormalTok{file\_name }\OperatorTok{=} \StringTok{\textquotesingle{}data.pickle\textquotesingle{}}

\CommentTok{\# write the variable to the file system}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(file\_name, }\StringTok{\textquotesingle{}wb\textquotesingle{}}\NormalTok{) }\ImportTok{as}\NormalTok{ file\_:}
\NormalTok{    pickle.dump(d, file\_)}
\end{Highlighting}
\end{Shaded}

The following code reads to a pickle file. The first line opens the file object being read from. In the \texttt{open} function, `data.pickle' specifies the file path of the file object. Then, `rb' stands for `read binary', which means the file is being read in binary form (1s and 0s). After the \emph{as} keyword, `my\_file', is the user selected name of the file object.

The second line uses the \texttt{pickle.load()} function. This function requires one argument: the name of the file object.

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{\# read the specified file from the file system and load into variable}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{\textquotesingle{}data.pickle\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}rb\textquotesingle{}}\NormalTok{) }\ImportTok{as}\NormalTok{ my\_file:}
\NormalTok{    d }\OperatorTok{=}\NormalTok{ pickle.load(my\_file)}
\end{Highlighting}
\end{Shaded}

\hypertarget{r-16}{%
\subsubsection*{R}\label{r-16}}
\addcontentsline{toc}{subsubsection}{R}

To export a matrix or data frame to a CSV file, use the \texttt{write.csv()} function. To export to a file with a different field separator, such as a tab, use \texttt{write.table()}. The minimal arguments for \texttt{write.csv()} are the object and the file name. To export a data frame named \texttt{dat} to a file named \texttt{dat.csv} to your current working directory:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{write.csv}\NormalTok{(dat, }\AttributeTok{file =} \StringTok{"dat.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

By default a column for row names or numbers is included in the exported csv file. To turn that off, set \texttt{row.names\ =\ FALSE}, like so:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{write.csv}\NormalTok{(dat, }\AttributeTok{file =} \StringTok{"dat.csv"}\NormalTok{, }\AttributeTok{row.names =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To append a matrix or data frame to an existing csv file, set \texttt{append\ =\ TRUE}.

See also \texttt{sink()}, \texttt{cat()}, and \texttt{writeLines()} for sending text and output to a file.

To save and load R objects for future use in R, there are two options:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Save and load a single object using \texttt{saveRDS()} and \texttt{readRDS()}.
\item
  Save multiple objects using \texttt{save()} and \texttt{load()}.
\end{enumerate}

\hypertarget{save-and-load-a-single-object}{%
\paragraph*{Save and load a single object}\label{save-and-load-a-single-object}}
\addcontentsline{toc}{paragraph}{Save and load a single object}

The minimal arguments for \texttt{saveRDS()} are the object and a file name with an \texttt{.rds} extension. For example, to save a single data frame named \texttt{dat} to your current working directory as \texttt{dat.rds}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{saveRDS}\NormalTok{(dat, }\AttributeTok{file =} \StringTok{"dat.rds"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To load the rds file into R from your current working directory, use the \texttt{readRDS()} function. Notice we must assign the result of \texttt{readRDS()} to an object. The object name need not match the file name.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{readRDS}\NormalTok{(}\StringTok{"dat.rds"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The advantage of saving and loading native R objects is the preservation of characteristics such as factors, attributes, classes, etc. Any object can be saved, including model objects, functions, vectors, lists, etc.

\hypertarget{save-multiple-objects}{%
\paragraph*{Save multiple objects}\label{save-multiple-objects}}
\addcontentsline{toc}{paragraph}{Save multiple objects}

The minimal arguments for \texttt{save()} are the objects to save and a file name with a \texttt{.rda} extension. Objects can also be specified as a character vector to the \texttt{list} argument. For example, to save a data frame named \texttt{dat}, a model object named \texttt{m}, and a plot object called \texttt{p}, to your current working directory as \texttt{work.rda}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{save}\NormalTok{(dat, m, p, }\AttributeTok{file =} \StringTok{"work.rda"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Or with objects specified as a character vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{save}\NormalTok{(}\AttributeTok{list =} \FunctionTok{c}\NormalTok{(}\StringTok{"dat"}\NormalTok{, }\StringTok{"m"}\NormalTok{, }\StringTok{"p"}\NormalTok{), }\AttributeTok{file =} \StringTok{"work.rda"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To load the rda file from your current working directory, use the \texttt{load()} function. Notice we do not assign the result to an object name. The result of the \texttt{load()} function is to load the objects into your global environment.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{load}\NormalTok{(}\StringTok{"work.rda"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Upon successful execution of the \texttt{load()} function, the \texttt{dat}, \texttt{m}, and \texttt{p} objects will be loaded into your global environment. Any objects already in your global environment with the same name will be overwritten without warning.

You can also save \emph{everything} in your global environment into a \texttt{rda} file using the \texttt{save.image()} function. It works just like the \texttt{save()} function except you do not specify which objects to save. You simply provide a file name. If you do not specify a file name, a default name of \texttt{.Rdata} is used. To load the file use the \texttt{load()} function. Again, all objects will be loaded into the gloabal environment, overwriting any existing objects with the same name.

\hypertarget{data-manipulation}{%
\chapter{Data Manipulation}\label{data-manipulation}}

This chapter looks at various strategies for filtering, selecting, modifying and deriving variables in data. Unless otherwise stated, examples are for DataFrames (Python) and data frames (R) and use the mtcars data frame that is included with R.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Python}
\ImportTok{import}\NormalTok{ pandas}
\NormalTok{mtcars }\OperatorTok{=}\NormalTok{ pandas.read\_csv(}\StringTok{\textquotesingle{}data/mtcars.csv\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# R}
\FunctionTok{data}\NormalTok{(mtcars)}
\CommentTok{\# drop row names to match Python version of data}
\FunctionTok{rownames}\NormalTok{(mtcars) }\OtherTok{\textless{}{-}} \ConstantTok{NULL}
\end{Highlighting}
\end{Shaded}

\hypertarget{names-of-variables-and-their-types}{%
\section{Names of variables and their types}\label{names-of-variables-and-their-types}}

View and inspect the names of variables and their type (numeric, string, logical, etc.) This is useful to ensure that variables have the expected type.

\hypertarget{python-17}{%
\subsubsection*{Python}\label{python-17}}
\addcontentsline{toc}{subsubsection}{Python}

The \texttt{.info()} function in pandas lists information on the DataFrame.

Setting the argument \texttt{verbose} to \texttt{True} prints the name of the columns, their length excluding \texttt{NULL} values, and their data type (\texttt{dtype}) in a table. The function lists the unique data types in the DataFrame, and it prints how much memory the DataFrame takes up.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars.info(verbose}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <class 'pandas.core.frame.DataFrame'>
## RangeIndex: 32 entries, 0 to 31
## Data columns (total 11 columns):
##  #   Column  Non-Null Count  Dtype  
## ---  ------  --------------  -----  
##  0   mpg     32 non-null     float64
##  1   cyl     32 non-null     int64  
##  2   disp    32 non-null     float64
##  3   hp      32 non-null     int64  
##  4   drat    32 non-null     float64
##  5   wt      32 non-null     float64
##  6   qsec    32 non-null     float64
##  7   vs      32 non-null     int64  
##  8   am      32 non-null     int64  
##  9   gear    32 non-null     int64  
##  10  carb    32 non-null     int64  
## dtypes: float64(5), int64(6)
## memory usage: 2.9 KB
\end{verbatim}

Setting \texttt{verbose} to \texttt{False} excludes the table describing each column.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars.info(verbose}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <class 'pandas.core.frame.DataFrame'>
## RangeIndex: 32 entries, 0 to 31
## Columns: 11 entries, mpg to carb
## dtypes: float64(5), int64(6)
## memory usage: 2.9 KB
\end{verbatim}

If a DataFrame has 100 or fewer columns, the \texttt{verbose} argument defaults to \texttt{True}.

\hypertarget{r-17}{%
\subsubsection*{R}\label{r-17}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{str()} function in R lists the names of the variables, their type, the first few values, and the dimensions of the data frame.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    32 obs. of  11 variables:
##  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
##  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
##  $ disp: num  160 160 108 258 360 ...
##  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
##  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
##  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
##  $ qsec: num  16.5 17 18.6 19.4 17 ...
##  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
##  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
##  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
##  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...
\end{verbatim}

To see just the names of the data frame, use the \texttt{names()} function.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "mpg"  "cyl"  "disp" "hp"   "drat" "wt"   "qsec" "vs"   "am"   "gear"
## [11] "carb"
\end{verbatim}

To see just the dimensions of the data frame, use the \texttt{dim()} function. It returns the number of rows and columns, respectively.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 32 11
\end{verbatim}

\hypertarget{select-variables}{%
\section{Select variables}\label{select-variables}}

How to select specific columns of data frames.

\hypertarget{python-18}{%
\subsubsection*{Python}\label{python-18}}
\addcontentsline{toc}{subsubsection}{Python}

The period operator \texttt{.} provides access to a column in a DataFrame as a vector. This returns pandas Series. A pandas series can do everything a numpy array can do.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars.mpg}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0     21.0
## 1     21.0
## 2     22.8
## 3     21.4
## 4     18.7
## 5     18.1
## 6     14.3
## 7     24.4
## 8     22.8
## 9     19.2
## 10    17.8
## 11    16.4
## 12    17.3
## 13    15.2
## 14    10.4
## 15    10.4
## 16    14.7
## 17    32.4
## 18    30.4
## 19    33.9
## 20    21.5
## 21    15.5
## 22    15.2
## 23    13.3
## 24    19.2
## 25    27.3
## 26    26.0
## 27    30.4
## 28    15.8
## 29    19.7
## 30    15.0
## 31    21.4
## Name: mpg, dtype: float64
\end{verbatim}

Indexing also provides access to columns as a pandas Series. Single and double quotations both work.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[}\StringTok{\textquotesingle{}mpg\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0     21.0
## 1     21.0
## 2     22.8
## 3     21.4
## 4     18.7
## 5     18.1
## 6     14.3
## 7     24.4
## 8     22.8
## 9     19.2
## 10    17.8
## 11    16.4
## 12    17.3
## 13    15.2
## 14    10.4
## 15    10.4
## 16    14.7
## 17    32.4
## 18    30.4
## 19    33.9
## 20    21.5
## 21    15.5
## 22    15.2
## 23    13.3
## 24    19.2
## 25    27.3
## 26    26.0
## 27    30.4
## 28    15.8
## 29    19.7
## 30    15.0
## 31    21.4
## Name: mpg, dtype: float64
\end{verbatim}

Operations on numpy arrays are faster than operations on pandas Series. But using pandas series should be fine, in terms of performance, in many cases. This is important for large data sets on which many operations are performed. The \texttt{.values} function returns a numpy array.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[}\StringTok{\textquotesingle{}mpg\textquotesingle{}}\NormalTok{].values}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array([21. , 21. , 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,
##        16.4, 17.3, 15.2, 10.4, 10.4, 14.7, 32.4, 30.4, 33.9, 21.5, 15.5,
##        15.2, 13.3, 19.2, 27.3, 26. , 30.4, 15.8, 19.7, 15. , 21.4])
\end{verbatim}

Double indexing returns a pandas DataFrame, instead of a numpy array or pandas series.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[[}\StringTok{\textquotesingle{}mpg\textquotesingle{}}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      mpg
## 0   21.0
## 1   21.0
## 2   22.8
## 3   21.4
## 4   18.7
## 5   18.1
## 6   14.3
## 7   24.4
## 8   22.8
## 9   19.2
## 10  17.8
## 11  16.4
## 12  17.3
## 13  15.2
## 14  10.4
## 15  10.4
## 16  14.7
## 17  32.4
## 18  30.4
## 19  33.9
## 20  21.5
## 21  15.5
## 22  15.2
## 23  13.3
## 24  19.2
## 25  27.3
## 26  26.0
## 27  30.4
## 28  15.8
## 29  19.7
## 30  15.0
## 31  21.4
\end{verbatim}

The \texttt{head()} and \texttt{tail()} functions return the first 5 or last 5 values. Use the \texttt{n} argument to change the number of values. This function works on numpy arrays, pandas series and pandas DataFrames.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# first 6 values}
\NormalTok{mtcars.mpg.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0    21.0
## 1    21.0
## 2    22.8
## 3    21.4
## 4    18.7
## Name: mpg, dtype: float64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# last row of DataFrame}
\NormalTok{mtcars.tail(n}\OperatorTok{=}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      mpg  cyl   disp   hp  drat    wt  qsec  vs  am  gear  carb
## 31  21.4    4  121.0  109  4.11  2.78  18.6   1   1     4     2
\end{verbatim}

\hypertarget{r-18}{%
\subsubsection*{R}\label{r-18}}
\addcontentsline{toc}{subsubsection}{R}

The dollar sign operator, \texttt{\$}, provides access to a column in a data frame as a vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars}\SpecialCharTok{$}\NormalTok{mpg}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4
## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7
## [31] 15.0 21.4
\end{verbatim}

Double-indexing brackets also provide access to columns as a vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[[}\StringTok{"mpg"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4
## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7
## [31] 15.0 21.4
\end{verbatim}

Single-indexing brackets work as well, but they return a data frame instead of a vector (if used with a data frame).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[}\StringTok{"mpg"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg
## 1  21.0
## 2  21.0
## 3  22.8
## 4  21.4
## 5  18.7
## 6  18.1
## 7  14.3
## 8  24.4
## 9  22.8
## 10 19.2
## 11 17.8
## 12 16.4
## 13 17.3
## 14 15.2
## 15 10.4
## 16 10.4
## 17 14.7
## 18 32.4
## 19 30.4
## 20 33.9
## 21 21.5
## 22 15.5
## 23 15.2
## 24 13.3
## 25 19.2
## 26 27.3
## 27 26.0
## 28 30.4
## 29 15.8
## 30 19.7
## 31 15.0
## 32 21.4
\end{verbatim}

Single-indexing brackets also allow selection of rows when used with a comma. The syntax is \texttt{rows,\ columns}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# first three rows}
\NormalTok{mtcars[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }\StringTok{"mpg"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 21.0 21.0 22.8
\end{verbatim}

Finally single-indexing brackets allow us to select multiple columns. Request columns either by name or position using a vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[}\FunctionTok{c}\NormalTok{(}\StringTok{"mpg"}\NormalTok{, }\StringTok{"cyl"}\NormalTok{)] }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg cyl
## 1  21.0   6
## 2  21.0   6
## 3  22.8   4
## 4  21.4   6
## 5  18.7   8
## 6  18.1   6
## 7  14.3   8
## 8  24.4   4
## 9  22.8   4
## 10 19.2   6
## 11 17.8   6
## 12 16.4   8
## 13 17.3   8
## 14 15.2   8
## 15 10.4   8
## 16 10.4   8
## 17 14.7   8
## 18 32.4   4
## 19 30.4   4
## 20 33.9   4
## 21 21.5   4
## 22 15.5   8
## 23 15.2   8
## 24 13.3   8
## 25 19.2   8
## 26 27.3   4
## 27 26.0   4
## 28 30.4   4
## 29 15.8   8
## 30 19.7   6
## 31 15.0   8
## 32 21.4   4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# same as mtcars[1:2] }
\end{Highlighting}
\end{Shaded}

The \texttt{head()} and \texttt{tail()} functions return the first 6 or last 6 values. Use the \texttt{n} argument to change the number of values. They work with vectors or data frames.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# first 6 values}
\FunctionTok{head}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{mpg)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 21.0 21.0 22.8 21.4 18.7 18.1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# last row of data frame}
\FunctionTok{tail}\NormalTok{(mtcars, }\AttributeTok{n =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg cyl disp  hp drat   wt qsec vs am gear carb
## 32 21.4   4  121 109 4.11 2.78 18.6  1  1    4    2
\end{verbatim}

\hypertarget{filtersubset-variables}{%
\section{Filter/Subset variables}\label{filtersubset-variables}}

How to view rows of a data frame that meet certain conditions.

\hypertarget{python-19}{%
\subsubsection*{Python}\label{python-19}}
\addcontentsline{toc}{subsubsection}{Python}

We can filter rows of a DataFrame based on a condition to subset. The data type returned depends on the filtration method.

The following code returns a DataFrame, not a Series, as there is more than one column selected from the DataFrame. Use a list, square brackets {[}{]}, to subset more than one column.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars[}\StringTok{"mpg"}\NormalTok{] }\OperatorTok{\textgreater{}} \DecValTok{30}\NormalTok{][[}\StringTok{"mpg"}\NormalTok{, }\StringTok{"cyl"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      mpg  cyl
## 17  32.4    4
## 18  30.4    4
## 19  33.9    4
## 27  30.4    4
\end{verbatim}

Both pandas Series and NumPy arrays can be used for faster performance or vector operations. Many functions require a vector as input.

The following code returns one column, mpg, as a pandas Series. A pandas Series is one column from a pandas DataFrame.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars[}\StringTok{"mpg"}\NormalTok{] }\OperatorTok{\textgreater{}} \DecValTok{30}\NormalTok{][}\StringTok{"mpg"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 17    32.4
## 18    30.4
## 19    33.9
## 27    30.4
## Name: mpg, dtype: float64
\end{verbatim}

The following code also returns a pandas Series, but using the \texttt{.} operator to select for a column, rather than square brackets {[}{]}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars[}\StringTok{"mpg"}\NormalTok{] }\OperatorTok{\textgreater{}} \DecValTok{30}\NormalTok{].mpg}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 17    32.4
## 18    30.4
## 19    33.9
## 27    30.4
## Name: mpg, dtype: float64
\end{verbatim}

Both of the following lines of code return NumPy arrays using the \texttt{.values} function. \texttt{df1} is one dimension, for the one column, and \texttt{df1} is two dimensions, for the two columns.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df1 }\OperatorTok{=}\NormalTok{ mtcars[mtcars[}\StringTok{"mpg"}\NormalTok{] }\OperatorTok{\textgreater{}} \DecValTok{30}\NormalTok{][}\StringTok{"mpg"}\NormalTok{].values}
\NormalTok{df2 }\OperatorTok{=}\NormalTok{ mtcars[mtcars[}\StringTok{"mpg"}\NormalTok{] }\OperatorTok{\textgreater{}} \DecValTok{30}\NormalTok{][[}\StringTok{"mpg"}\NormalTok{, }\StringTok{"cyl"}\NormalTok{]].values}
\end{Highlighting}
\end{Shaded}

You can also filter with multiple row conditions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars[}\StringTok{"mpg"}\NormalTok{] }\OperatorTok{\textgreater{}} \DecValTok{30}\NormalTok{][mtcars[}\StringTok{"hp"}\NormalTok{] }\OperatorTok{\textless{}} \DecValTok{66}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      mpg  cyl  disp  hp  drat     wt   qsec  vs  am  gear  carb
## 18  30.4    4  75.7  52  4.93  1.615  18.52   1   1     4     2
## 19  33.9    4  71.1  65  4.22  1.835  19.90   1   1     4     1
## 
## <string>:1: UserWarning: Boolean Series key will be reindexed to match DataFrame index.
\end{verbatim}

\hypertarget{r-19}{%
\subsubsection*{R}\label{r-19}}
\addcontentsline{toc}{subsubsection}{R}

In base R, we can use subsetting brackets or the \texttt{subset()} function to select rows based on some condition. Below we demonstrate both approaches to view only those rows with ``mpg'' greater than 30. First we begin with subsetting brackets.

The subsetting brackets take three arguments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{i}: the condition to subset on.
\item
  \texttt{j}: the columns to show. If none specified, all columns are returned
\item
  \texttt{drop}: an optional logical argument (TRUE/FALSE) to determine whether or not to coerce the output to the lowest possible dimension. The default is TRUE.
\end{enumerate}

We rarely type the first two argument names, \texttt{i} and \texttt{j}, when using subsetting brackets.

This example returns only the rows with mpg \textgreater{} 30 and all columns. Notice we need to preface mpg with \texttt{mtcars\$} to tell R where to find the ``mpg'' column and that we need to provide a comma after the condition.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\SpecialCharTok{$}\NormalTok{mpg }\SpecialCharTok{\textgreater{}} \DecValTok{30}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg cyl disp  hp drat    wt  qsec vs am gear carb
## 18 32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1
## 19 30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2
## 20 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1
## 28 30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2
\end{verbatim}

We can select what columns to see in the second argument as a vector. Notice we only need to specify the column names as a character vector. We can also use numbers corresponding to the column number as well as conditional statements.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\SpecialCharTok{$}\NormalTok{mpg }\SpecialCharTok{\textgreater{}} \DecValTok{30}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\StringTok{"mpg"}\NormalTok{, }\StringTok{"wt"}\NormalTok{, }\StringTok{"gear"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg    wt gear
## 18 32.4 2.200    4
## 19 30.4 1.615    4
## 20 33.9 1.835    4
## 28 30.4 1.513    5
\end{verbatim}

Show first three columns.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\SpecialCharTok{$}\NormalTok{mpg }\SpecialCharTok{\textgreater{}} \DecValTok{30}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg cyl disp
## 18 32.4   4 78.7
## 19 30.4   4 75.7
## 20 33.9   4 71.1
## 28 30.4   4 95.1
\end{verbatim}

Show columns with names consisting of only two characters. The \texttt{nchar()} function counts the number of characters in a string. The expression \texttt{nchar(names(mtcars))\ ==\ 2} returns a vector of TRUE/FALSE values where TRUE indicates the column name is only two characters in length.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\SpecialCharTok{$}\NormalTok{mpg }\SpecialCharTok{\textgreater{}} \DecValTok{30}\NormalTok{, }\FunctionTok{nchar}\NormalTok{(}\FunctionTok{names}\NormalTok{(mtcars)) }\SpecialCharTok{==} \DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     hp    wt vs am
## 18  66 2.200  1  1
## 19  52 1.615  1  1
## 20  65 1.835  1  1
## 28 113 1.513  1  1
\end{verbatim}

Notice when we specify only one column, the brackets return a vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\SpecialCharTok{$}\NormalTok{mpg }\SpecialCharTok{\textgreater{}} \DecValTok{30}\NormalTok{, }\StringTok{"mpg"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 32.4 30.4 33.9 30.4
\end{verbatim}

To get a data frame, set the \texttt{drop} argument to FALSE.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\SpecialCharTok{$}\NormalTok{mpg }\SpecialCharTok{\textgreater{}} \DecValTok{30}\NormalTok{, }\StringTok{"mpg"}\NormalTok{, drop }\OtherTok{=} \ConstantTok{FALSE}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg
## 18 32.4
## 19 30.4
## 20 33.9
## 28 30.4
\end{verbatim}

The \texttt{subset()} function allows us to refer to column names without using the \texttt{\$} extractor function or quoting column names. It also has a drop argument but its default is FALSE. It has four arguments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{x}: the data frame to subset.
\item
  \texttt{subset}: the condition to subset on.
\item
  \texttt{select}: the columns to select.
\item
  \texttt{drop}: an optional logical argument (TRUE/FALSE) to determine whether or not to coerce the output to the lowest possible dimension. The default is FALSE.
\end{enumerate}

We rarely type the first three argument names, \texttt{x}, \texttt{subset} and \texttt{select}, when using \texttt{subset()}.

Below we replicate the previous examples using \texttt{subset()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# rows where mpg \textgreater{} 30 and all columns}
\FunctionTok{subset}\NormalTok{(mtcars, mpg }\SpecialCharTok{\textgreater{}} \DecValTok{30}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg cyl disp  hp drat    wt  qsec vs am gear carb
## 18 32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1
## 19 30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2
## 20 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1
## 28 30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# rows where mpg \textgreater{} 30 and the mpg, wt, and gear columns}
\FunctionTok{subset}\NormalTok{(mtcars, mpg }\SpecialCharTok{\textgreater{}} \DecValTok{30}\NormalTok{, }\FunctionTok{c}\NormalTok{(mpg, wt, gear))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg    wt gear
## 18 32.4 2.200    4
## 19 30.4 1.615    4
## 20 33.9 1.835    4
## 28 30.4 1.513    5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# rows where mpg \textgreater{} 30 and the first three columns}
\FunctionTok{subset}\NormalTok{(mtcars, mpg }\SpecialCharTok{\textgreater{}} \DecValTok{30}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg cyl disp
## 18 32.4   4 78.7
## 19 30.4   4 75.7
## 20 33.9   4 71.1
## 28 30.4   4 95.1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# rows where mpg \textgreater{} 30 and columns consisting of two characters}
\FunctionTok{subset}\NormalTok{(mtcars, mpg }\SpecialCharTok{\textgreater{}} \DecValTok{30}\NormalTok{, }\FunctionTok{nchar}\NormalTok{(}\FunctionTok{names}\NormalTok{(mtcars)) }\SpecialCharTok{==} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     hp    wt vs am
## 18  66 2.200  1  1
## 19  52 1.615  1  1
## 20  65 1.835  1  1
## 28 113 1.513  1  1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# rows where mpg \textgreater{} 30 and mpg column, as a vector}
\FunctionTok{subset}\NormalTok{(mtcars, mpg }\SpecialCharTok{\textgreater{}} \DecValTok{30}\NormalTok{, mpg, }\AttributeTok{drop =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 32.4 30.4 33.9 30.4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# rows where mpg \textgreater{} 30 and mpg column, as a data frame}
\FunctionTok{subset}\NormalTok{(mtcars, mpg }\SpecialCharTok{\textgreater{}} \DecValTok{30}\NormalTok{, mpg)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg
## 18 32.4
## 19 30.4
## 20 33.9
## 28 30.4
\end{verbatim}

Another difference between subsetting brackets and the \texttt{subset()} function is how they handle missing values. Subsetting brackets return missing values while \texttt{subset()} does not. We demonstrate with a toy data frame. Notice the ``x'' column has a missing value.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dframe }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{5}\NormalTok{), }
                     \AttributeTok{y =} \FunctionTok{c}\NormalTok{(}\DecValTok{12}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{34}\NormalTok{))}
\NormalTok{dframe}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    x  y
## 1  1 12
## 2 NA 21
## 3  5 34
\end{verbatim}

When we condition on x \textless{} 3, the subsetting bracket approach returns a row with NA values.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dframe[dframe}\SpecialCharTok{$}\NormalTok{x }\SpecialCharTok{\textless{}} \DecValTok{3}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     x  y
## 1   1 12
## NA NA NA
\end{verbatim}

The \texttt{subset()} approach ignores the missing value.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{subset}\NormalTok{(dframe, x }\SpecialCharTok{\textless{}} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   x  y
## 1 1 12
\end{verbatim}

To replicate the \texttt{subset()} result with the subsetting brackets, we need to include an additional condition to only show rows where x is NOT missing. We can do that with the \texttt{is.na()} function. The \texttt{is.na()} function returns TRUE if a value is missing and FALSE otherwise. If we preface with \texttt{!}, we get TRUE if a value is NOT missing and FALSE otherwise.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dframe[dframe}\SpecialCharTok{$}\NormalTok{x }\SpecialCharTok{\textless{}} \DecValTok{3} \SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(dframe}\SpecialCharTok{$}\NormalTok{x),]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   x  y
## 1 1 12
\end{verbatim}

See also the \texttt{filter()} function in the \href{https://dplyr.tidyverse.org/}{\textbf{dplyr}} package and the enhanced subsetting brackets in the \href{https://rdatatable.gitlab.io/data.table/}{\textbf{data.table}} package.

\hypertarget{rename-variables}{%
\section{Rename variables}\label{rename-variables}}

How to rename variables or ``column headers''.

\hypertarget{python-20}{%
\subsubsection*{Python}\label{python-20}}
\addcontentsline{toc}{subsubsection}{Python}

Column names can be changed using the function \texttt{.rename()}. Below, we change the column names ``cyl'' and ``wt'' to ``cylinder'' and ``WT'', respectively.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars.rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{"cyl"}\NormalTok{:}\StringTok{"cylinder"}\NormalTok{, }\StringTok{"wt"}\NormalTok{:}\StringTok{"WT"}\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      mpg  cylinder   disp   hp  drat     WT   qsec  vs  am  gear  carb
## 0   21.0         6  160.0  110  3.90  2.620  16.46   0   1     4     4
## 1   21.0         6  160.0  110  3.90  2.875  17.02   0   1     4     4
## 2   22.8         4  108.0   93  3.85  2.320  18.61   1   1     4     1
## 3   21.4         6  258.0  110  3.08  3.215  19.44   1   0     3     1
## 4   18.7         8  360.0  175  3.15  3.440  17.02   0   0     3     2
## 5   18.1         6  225.0  105  2.76  3.460  20.22   1   0     3     1
## 6   14.3         8  360.0  245  3.21  3.570  15.84   0   0     3     4
## 7   24.4         4  146.7   62  3.69  3.190  20.00   1   0     4     2
## 8   22.8         4  140.8   95  3.92  3.150  22.90   1   0     4     2
## 9   19.2         6  167.6  123  3.92  3.440  18.30   1   0     4     4
## 10  17.8         6  167.6  123  3.92  3.440  18.90   1   0     4     4
## 11  16.4         8  275.8  180  3.07  4.070  17.40   0   0     3     3
## 12  17.3         8  275.8  180  3.07  3.730  17.60   0   0     3     3
## 13  15.2         8  275.8  180  3.07  3.780  18.00   0   0     3     3
## 14  10.4         8  472.0  205  2.93  5.250  17.98   0   0     3     4
## 15  10.4         8  460.0  215  3.00  5.424  17.82   0   0     3     4
## 16  14.7         8  440.0  230  3.23  5.345  17.42   0   0     3     4
## 17  32.4         4   78.7   66  4.08  2.200  19.47   1   1     4     1
## 18  30.4         4   75.7   52  4.93  1.615  18.52   1   1     4     2
## 19  33.9         4   71.1   65  4.22  1.835  19.90   1   1     4     1
## 20  21.5         4  120.1   97  3.70  2.465  20.01   1   0     3     1
## 21  15.5         8  318.0  150  2.76  3.520  16.87   0   0     3     2
## 22  15.2         8  304.0  150  3.15  3.435  17.30   0   0     3     2
## 23  13.3         8  350.0  245  3.73  3.840  15.41   0   0     3     4
## 24  19.2         8  400.0  175  3.08  3.845  17.05   0   0     3     2
## 25  27.3         4   79.0   66  4.08  1.935  18.90   1   1     4     1
## 26  26.0         4  120.3   91  4.43  2.140  16.70   0   1     5     2
## 27  30.4         4   95.1  113  3.77  1.513  16.90   1   1     5     2
## 28  15.8         8  351.0  264  4.22  3.170  14.50   0   1     5     4
## 29  19.7         6  145.0  175  3.62  2.770  15.50   0   1     5     6
## 30  15.0         8  301.0  335  3.54  3.570  14.60   0   1     5     8
## 31  21.4         4  121.0  109  4.11  2.780  18.60   1   1     4     2
\end{verbatim}

Alternatively, column names can be changed by replacing the vector of column names with a new vector. Below, we create a vector of columns that replaces ``drat'' with ``axle\_ratio'' using conditional match and indexing and ``disp'' with ``DISP'' using indexing.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{column\_names }\OperatorTok{=}\NormalTok{ mtcars.columns.values}

\CommentTok{\# using conditional match}
\NormalTok{column\_names[column\_names }\OperatorTok{==} \StringTok{"drat"}\NormalTok{] }\OperatorTok{=} \StringTok{"axle\_ratio"}

\CommentTok{\# using indexing}
\NormalTok{column\_names[}\DecValTok{2}\NormalTok{] }\OperatorTok{=} \StringTok{"DISP"}

\NormalTok{mtcars.columns }\OperatorTok{=}\NormalTok{ column\_names}
\NormalTok{mtcars.columns}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Index(['mpg', 'cyl', 'DISP', 'hp', 'axle_ratio', 'wt', 'qsec', 'vs', 'am',
##        'gear', 'carb'],
##       dtype='object')
\end{verbatim}

\hypertarget{r-20}{%
\subsubsection*{R}\label{r-20}}
\addcontentsline{toc}{subsubsection}{R}

Variable names can be changed by their index (ie, order of columns in the data frame). Below the second column is ``cyl''. We change the name to ``cylinders''.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(mtcars)[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "cyl"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(mtcars)[}\DecValTok{2}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"cylinders"}
\FunctionTok{names}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "mpg"       "cylinders" "disp"      "hp"        "drat"      "wt"       
##  [7] "qsec"      "vs"        "am"        "gear"      "carb"
\end{verbatim}

Variable names can also be changed by conditional match. Below we find the variable name that matches ``drat'' and change to ``axle\_ratio''.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(mtcars)[}\FunctionTok{names}\NormalTok{(mtcars) }\SpecialCharTok{==} \StringTok{"drat"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "drat"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(mtcars)[}\FunctionTok{names}\NormalTok{(mtcars) }\SpecialCharTok{==} \StringTok{"drat"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"axle\_ratio"}
\FunctionTok{names}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "mpg"        "cylinders"  "disp"       "hp"         "axle_ratio"
##  [6] "wt"         "qsec"       "vs"         "am"         "gear"      
## [11] "carb"
\end{verbatim}

More than one variable name can be changed using a vector of positions or matches.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(mtcars)[}\FunctionTok{c}\NormalTok{(}\DecValTok{6}\NormalTok{,}\DecValTok{8}\NormalTok{)] }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"weight"}\NormalTok{, }\StringTok{"engine"}\NormalTok{)}

\CommentTok{\# or}
\CommentTok{\# names(mtcars)[names(mtcars) \%in\% c("wt", "vs")] \textless{}{-} c("weight", "engine")}

\FunctionTok{names}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "mpg"        "cylinders"  "disp"       "hp"         "axle_ratio"
##  [6] "weight"     "qsec"       "engine"     "am"         "gear"      
## [11] "carb"
\end{verbatim}

See also the \texttt{rename()} function in the \href{https://dplyr.tidyverse.org/}{\textbf{dplyr}}.

\hypertarget{create-replace-and-remove-variables}{%
\section{Create, replace and remove variables}\label{create-replace-and-remove-variables}}

We often need to create variables that are functions of other variables, or replace existing variables with an updated version.

\hypertarget{python-21}{%
\subsubsection*{Python}\label{python-21}}
\addcontentsline{toc}{subsubsection}{Python}

Adding a new variable using the indexing notation and assigning a result adds a new column.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# add column for Kilometer per liter}
\NormalTok{mtcars[}\StringTok{\textquotesingle{}kpl\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ mtcars.mpg}\OperatorTok{/}\FloatTok{2.352}
\end{Highlighting}
\end{Shaded}

Doing the same with an \emph{existing} column name updates the values in a column.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# update to liters per 100 Kilometers}
\NormalTok{mtcars[}\StringTok{\textquotesingle{}kpl\textquotesingle{}}\NormalTok{] }\OperatorTok{=} \DecValTok{100}\OperatorTok{/}\NormalTok{mtcars.kpl }
\end{Highlighting}
\end{Shaded}

Alternatively, the \texttt{.} notation can be used to update the values in a column.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# update to liters per 50 Kilometers}
\NormalTok{mtcars.kpl }\OperatorTok{=} \DecValTok{50}\OperatorTok{/}\NormalTok{mtcars.kpl }
\end{Highlighting}
\end{Shaded}

To remove a column, use the \texttt{.drop()} function.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# drop the kpl variable}
\NormalTok{mtcars.drop(columns}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}kpl\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      mpg  cyl   DISP   hp  axle_ratio     wt   qsec  vs  am  gear  carb
## 0   21.0    6  160.0  110        3.90  2.620  16.46   0   1     4     4
## 1   21.0    6  160.0  110        3.90  2.875  17.02   0   1     4     4
## 2   22.8    4  108.0   93        3.85  2.320  18.61   1   1     4     1
## 3   21.4    6  258.0  110        3.08  3.215  19.44   1   0     3     1
## 4   18.7    8  360.0  175        3.15  3.440  17.02   0   0     3     2
## 5   18.1    6  225.0  105        2.76  3.460  20.22   1   0     3     1
## 6   14.3    8  360.0  245        3.21  3.570  15.84   0   0     3     4
## 7   24.4    4  146.7   62        3.69  3.190  20.00   1   0     4     2
## 8   22.8    4  140.8   95        3.92  3.150  22.90   1   0     4     2
## 9   19.2    6  167.6  123        3.92  3.440  18.30   1   0     4     4
## 10  17.8    6  167.6  123        3.92  3.440  18.90   1   0     4     4
## 11  16.4    8  275.8  180        3.07  4.070  17.40   0   0     3     3
## 12  17.3    8  275.8  180        3.07  3.730  17.60   0   0     3     3
## 13  15.2    8  275.8  180        3.07  3.780  18.00   0   0     3     3
## 14  10.4    8  472.0  205        2.93  5.250  17.98   0   0     3     4
## 15  10.4    8  460.0  215        3.00  5.424  17.82   0   0     3     4
## 16  14.7    8  440.0  230        3.23  5.345  17.42   0   0     3     4
## 17  32.4    4   78.7   66        4.08  2.200  19.47   1   1     4     1
## 18  30.4    4   75.7   52        4.93  1.615  18.52   1   1     4     2
## 19  33.9    4   71.1   65        4.22  1.835  19.90   1   1     4     1
## 20  21.5    4  120.1   97        3.70  2.465  20.01   1   0     3     1
## 21  15.5    8  318.0  150        2.76  3.520  16.87   0   0     3     2
## 22  15.2    8  304.0  150        3.15  3.435  17.30   0   0     3     2
## 23  13.3    8  350.0  245        3.73  3.840  15.41   0   0     3     4
## 24  19.2    8  400.0  175        3.08  3.845  17.05   0   0     3     2
## 25  27.3    4   79.0   66        4.08  1.935  18.90   1   1     4     1
## 26  26.0    4  120.3   91        4.43  2.140  16.70   0   1     5     2
## 27  30.4    4   95.1  113        3.77  1.513  16.90   1   1     5     2
## 28  15.8    8  351.0  264        4.22  3.170  14.50   0   1     5     4
## 29  19.7    6  145.0  175        3.62  2.770  15.50   0   1     5     6
## 30  15.0    8  301.0  335        3.54  3.570  14.60   0   1     5     8
## 31  21.4    4  121.0  109        4.11  2.780  18.60   1   1     4     2
\end{verbatim}

\hypertarget{r-21}{%
\subsubsection*{R}\label{r-21}}
\addcontentsline{toc}{subsubsection}{R}

Adding a new variable name after the dollar sign notation and assigning a result adds a new column.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# add column for Kilometer per liter}
\NormalTok{mtcars}\SpecialCharTok{$}\NormalTok{kpl }\OtherTok{\textless{}{-}}\NormalTok{ mtcars}\SpecialCharTok{$}\NormalTok{mpg}\SpecialCharTok{/}\FloatTok{2.352}
\end{Highlighting}
\end{Shaded}

Doing the same with an \emph{existing} variable updates the values in a column.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# update to liters per 100 Kilometers}
\NormalTok{mtcars}\SpecialCharTok{$}\NormalTok{kpl }\OtherTok{\textless{}{-}} \DecValTok{100}\SpecialCharTok{/}\NormalTok{mtcars}\SpecialCharTok{$}\NormalTok{kpl }
\end{Highlighting}
\end{Shaded}

To remove a variable, assign it \texttt{NULL}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# drop the kpl variable}
\NormalTok{mtcars}\SpecialCharTok{$}\NormalTok{kpl }\OtherTok{\textless{}{-}} \ConstantTok{NULL}
\end{Highlighting}
\end{Shaded}

See also the \texttt{mutate()} function in the \href{https://dplyr.tidyverse.org/}{\textbf{dplyr}} package.

\hypertarget{create-strings-from-numbers}{%
\section{Create strings from numbers}\label{create-strings-from-numbers}}

You may have data that is numeric but that needs to be treated as a string.

\hypertarget{python-22}{%
\subsubsection*{Python}\label{python-22}}
\addcontentsline{toc}{subsubsection}{Python}

You can change the data type of a column in a DataFrame using the \texttt{astype} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[}\StringTok{\textquotesingle{}am\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ mtcars[}\StringTok{\textquotesingle{}am\textquotesingle{}}\NormalTok{].astype(}\BuiltInTok{str}\NormalTok{)}
\BuiltInTok{type}\NormalTok{(mtcars.am[}\DecValTok{0}\NormalTok{]) }\CommentTok{\# check the type of the first item in \textquotesingle{}am\textquotesingle{} column}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <class 'str'>
\end{verbatim}

A potential number-to-string conversion task in Python might be formatting 5-digit American zip codes. Some zip codes begin with 0, but if stored as a numeric value, the 0 is dropped. For example, consider the following pandas DataFrame. Notice the leading 0 is dropped from two of the zip codes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zc }\OperatorTok{=}\NormalTok{ pandas.read\_csv(}\StringTok{\textquotesingle{}data/zc.csv\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(zc)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   state    zip
## 0    VT   5001
## 1    VA  22901
## 2    NH   3282
\end{verbatim}

One way to fix this is using the string \texttt{zfill()} method. First we convert the numeric column to string type using the method we just demonstrated. Then we access the ``zip'' column using \texttt{zc.zip} and the \texttt{zfill()} method using \texttt{str.zfill} with the width parameter set to 5. This pads the string with ``0'' on the left to make each value 5 characters wide.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zc[}\StringTok{\textquotesingle{}zip\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ zc[}\StringTok{\textquotesingle{}zip\textquotesingle{}}\NormalTok{].astype(}\BuiltInTok{str}\NormalTok{)}
\NormalTok{zc[}\StringTok{\textquotesingle{}zip\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ zc.}\BuiltInTok{zip}\NormalTok{.}\BuiltInTok{str}\NormalTok{.zfill(}\DecValTok{5}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(zc)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   state    zip
## 0    VT  05001
## 1    VA  22901
## 2    NH  03282
\end{verbatim}

If we knew we were importing zip codes using \texttt{read\_csv}, we could also use the \texttt{dtype} argument to specify which storage type to use for the ``zip'' column. Below we pass a dictionary that maps the ``str'' type to the ``zip'' column. The result is a properly formatted zip code column.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zc }\OperatorTok{=}\NormalTok{ pandas.read\_csv(}\StringTok{\textquotesingle{}data/zc.csv\textquotesingle{}}\NormalTok{, dtype }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}zip\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{\})}
\BuiltInTok{print}\NormalTok{(zc)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   state    zip
## 0    VT  05001
## 1    VA  22901
## 2    NH  03282
\end{verbatim}

\hypertarget{r-22}{%
\subsubsection*{R}\label{r-22}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{as.character()} function takes a vector and converts it to string format.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{am)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 1 1 0 0 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(}\FunctionTok{as.character}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{am))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1" "1" "1" "0" "0" "0"
\end{verbatim}

Note we just demonstrated conversion. To save the conversion we need to \emph{assign} the result to the data frame.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# add new string variable am\_ch}
\NormalTok{mtcars}\SpecialCharTok{$}\NormalTok{am\_ch }\OtherTok{\textless{}{-}} \FunctionTok{as.character}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{am)}
\FunctionTok{head}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{am\_ch)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1" "1" "1" "0" "0" "0"
\end{verbatim}

The \texttt{factor()} function can also be used to convert a numeric vector into a categorical variable. The result is not exactly a string, however. A factor is made of integers with character labels. Factors are useful for character data that have a fixed set of levels (eg, ``grade 1'', grade 2'', etc)

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# convert to factor}
\FunctionTok{head}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{am)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 1 1 0 0 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(}\FunctionTok{factor}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{am))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 1 1 0 0 0
## Levels: 0 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# convert to factor with labels}
\FunctionTok{head}\NormalTok{(}\FunctionTok{factor}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{am, }\AttributeTok{labels =} \FunctionTok{c}\NormalTok{(}\StringTok{"automatic"}\NormalTok{, }\StringTok{"manual"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] manual    manual    manual    automatic automatic automatic
## Levels: automatic manual
\end{verbatim}

Again we just demonstrated factor conversion. To save the conversion we need to assign to the data frame.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# create factor variable am\_fac}
\NormalTok{mtcars}\SpecialCharTok{$}\NormalTok{am\_fac }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{am, }\AttributeTok{labels =} \FunctionTok{c}\NormalTok{(}\StringTok{"automatic"}\NormalTok{, }\StringTok{"manual"}\NormalTok{))}
\FunctionTok{head}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{am\_fac)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] manual    manual    manual    automatic automatic automatic
## Levels: automatic manual
\end{verbatim}

A common number-to-string conversion task in R is formatting 5-digit American zip codes. Some zip codes begin with 0, but if stored as a numeric value, the 0 is dropped.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zip\_codes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{03766}\NormalTok{, }\DecValTok{03748}\NormalTok{, }\DecValTok{22901}\NormalTok{, }\DecValTok{03264}\NormalTok{)}
\NormalTok{zip\_codes}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  3766  3748 22901  3264
\end{verbatim}

We need to store the zip code as a character value so the 0 is preserved. One way to do this is via the \texttt{sprintf()} function in base R. The first argument is the \emph{format string} or \emph{conversion specification}. A conversion specification begins with ``\%''. The following ``0'' and ``5'' says to format the zip\_codes vector as a 5-digit string padded by zeroes on the left. The final ``i'' says we're working with integer values.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sprintf}\NormalTok{(}\StringTok{"\%05i"}\NormalTok{, zip\_codes)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "03766" "03748" "22901" "03264"
\end{verbatim}

See also the \texttt{str\_pad()} function in the \textbf{stringr} package.

\hypertarget{create-numbers-from-strings}{%
\section{Create numbers from strings}\label{create-numbers-from-strings}}

String variables that ought to be numbers usually have some character data in the values such as units (eg, ``4 cm''). To create numbers from strings it's important to remove any character data that cannot be converted to a number.

\hypertarget{python-23}{%
\subsubsection*{Python}\label{python-23}}
\addcontentsline{toc}{subsubsection}{Python}

The \texttt{astype(float)} or \texttt{astype(int)} function will coerce strings to numerical representation.

For demonstration, let's say we have the following numpy array.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\NormalTok{weight }\OperatorTok{=}\NormalTok{ np.array([}\StringTok{"125 lbs."}\NormalTok{, }\StringTok{"132 lbs."}\NormalTok{, }\StringTok{"156 lbs."}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

The \texttt{astype(float)} function throws an error due to the presence of strings. The \texttt{astype()} function is for numpy arrays.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  weight.astype(}\BuiltInTok{float}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{ValueError}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"ValueError: could not convert string to float: \textquotesingle{}125 lbs.\textquotesingle{}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## ValueError: could not convert string to float: '125 lbs.'
\end{verbatim}

One way to approach this is to first remove the strings from the objects and then use \texttt{astype(float)}. Below we use the \texttt{strip()} function to find '' lbs.'' using a list comprehension.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# [] indicates a list in python}
\CommentTok{\# np.array() changes the list back into an array}
\NormalTok{weight }\OperatorTok{=}\NormalTok{ np.array([w.strip(}\StringTok{" lbs."}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ w }\KeywordTok{in}\NormalTok{ weight])}
\end{Highlighting}
\end{Shaded}

Now we can use the \texttt{astype()} function to change the elements in weight from \texttt{str} to \texttt{float}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{weight.astype(}\BuiltInTok{float}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## array([125., 132., 156.])
\end{verbatim}

\hypertarget{r-23}{%
\subsubsection*{R}\label{r-23}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{as.numeric()} function will attempt to coerce strings to numeric type \emph{if possible}. Any non-numeric values are coerced to NA.

For demonstration, let's say we have the following vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{weight }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"125 lbs."}\NormalTok{, }\StringTok{"132 lbs."}\NormalTok{, }\StringTok{"156 lbs."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{as.numeric()} function returns all NA due to presence of character data.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(weight)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: NAs introduced by coercion
\end{verbatim}

\begin{verbatim}
## [1] NA NA NA
\end{verbatim}

There are many ways to approach this. A common approach is to first remove the characters and then use \texttt{as.numeric()}. Below we use the \texttt{gsub()} function to find ``lbs.'' and replace with nothing (find-and-replace procedures are discussed more below).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{weightN }\OtherTok{\textless{}{-}} \FunctionTok{gsub}\NormalTok{(}\StringTok{"lbs."}\NormalTok{, }\StringTok{""}\NormalTok{, weight)}
\FunctionTok{as.numeric}\NormalTok{(weightN)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 125 132 156
\end{verbatim}

The \texttt{parse\_number()} function in the \textbf{readr} package can often take care of these situations automatically.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{readr}\SpecialCharTok{::}\FunctionTok{parse\_number}\NormalTok{(weight)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 125 132 156
\end{verbatim}

\hypertarget{combine-strings}{%
\section{Combine strings}\label{combine-strings}}

String concatenation---turning `Jane' and `Smith' into `Jane Smith'---is easily done in both languages.

\hypertarget{python-24}{%
\subsubsection*{Python}\label{python-24}}
\addcontentsline{toc}{subsubsection}{Python}

The \texttt{+} operator can combine strings in Python.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{species }\OperatorTok{=} \StringTok{\textquotesingle{}yellow{-}bellied sea snake\textquotesingle{}}
\NormalTok{tail\_shape }\OperatorTok{=} \StringTok{\textquotesingle{}paddle{-}shaped\textquotesingle{}}

\NormalTok{statement }\OperatorTok{=} \StringTok{\textquotesingle{}The \textquotesingle{}} \OperatorTok{+}\NormalTok{ species }\OperatorTok{+} \StringTok{\textquotesingle{} has a \textquotesingle{}} \OperatorTok{+}\NormalTok{ tail\_shape }\OperatorTok{+} \StringTok{\textquotesingle{} tail that helps it swim.\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(statement)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## The yellow-bellied sea snake has a paddle-shaped tail that helps it swim.
\end{verbatim}

\hypertarget{r-24}{%
\subsubsection*{R}\label{r-24}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{paste()} and \texttt{paste0()} functions combine strings in R. The former concatenates strings and places spaces between them; the latter concatenates sans spaces.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{species }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}rainbow boa\textquotesingle{}}
\NormalTok{appearance }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}iridescent\textquotesingle{}}
\NormalTok{location }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}Central and South America\textquotesingle{}}

\NormalTok{statement1 }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(}\StringTok{\textquotesingle{}The\textquotesingle{}}\NormalTok{, species, }\StringTok{\textquotesingle{}has an\textquotesingle{}}\NormalTok{, appearance, }\StringTok{\textquotesingle{}sheen.\textquotesingle{}}\NormalTok{)}
\NormalTok{statement1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "The rainbow boa has an iridescent sheen."
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Note that spaces must be provided explicitly when using paste0()}
\NormalTok{statement2 }\OtherTok{\textless{}{-}} \FunctionTok{paste0}\NormalTok{(}\StringTok{\textquotesingle{}The \textquotesingle{}}\NormalTok{, species, }\StringTok{\textquotesingle{} is found in \textquotesingle{}}\NormalTok{, location)}
\NormalTok{statement2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "The rainbow boa is found in Central and South America"
\end{verbatim}

\hypertarget{finding-and-replacing-patterns-within-strings}{%
\section{Finding and replacing patterns within strings}\label{finding-and-replacing-patterns-within-strings}}

This section reviews key functions in Python and R for finding and replacing character patterns. The functions we discuss can search for fixed character patterns (e.g., ``Meredith Rollins'' to case-sensitively match that name and that name alone) or regular expression (regex) patterns (e.g., \texttt{\textbackslash{}w+} to capture all instances of \textgreater=1 word character). Note that in R, meta characters, like \texttt{w} (to match word characters) and \texttt{d} (to match digits), are escaped with \emph{two} backslashes (e.g., \texttt{\textbackslash{}\textbackslash{}w} and \texttt{\textbackslash{}\textbackslash{}d}). In Python, regex patterns are generally headed by \texttt{r}, which allows meta characters in the regex itself to be escaped with just one \texttt{\textbackslash{}} (e.g., \texttt{r"\textbackslash{}w+"}). Regex is an enormous topic, and we don't discuss it at any length here, but you can learn more about regular expressions---and how they're implemented in different programming languages---at these resources: \url{https://www.regular-expressions.info/}; \url{https://regexone.com/}

\hypertarget{python-25}{%
\subsubsection*{Python}\label{python-25}}
\addcontentsline{toc}{subsubsection}{Python}

The \textbf{re} module provides a set of functions for searching and manipulating strings. The \texttt{search()} function does exactly as its name suggests: It identifies matches for a fixed or regex character pattern in a string. \texttt{sub()} searches for and replaces character patterns (fixed or regex). The \texttt{count} argument in \texttt{sub()} allows a user to specify how many instances of the matched pattern they want to to replace; e.g., use \texttt{count\ =\ 1} to replace just the first instance of a match.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ re}
\NormalTok{statement }\OperatorTok{=} \StringTok{\textquotesingle{}Pencils with an HB graphite grade are commonly used for writing. An HB pencil is approximately equal to a \#2 pencil.\textquotesingle{}}

\CommentTok{\# Search for "HB" using fixed and regex patterns}
\NormalTok{search\_result1 }\OperatorTok{=}\NormalTok{ re.search(pattern }\OperatorTok{=} \StringTok{"HB"}\NormalTok{, string }\OperatorTok{=}\NormalTok{ statement)}
\BuiltInTok{print}\NormalTok{(search\_result1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <re.Match object; span=(16, 18), match='HB'>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{search\_result2 }\OperatorTok{=}\NormalTok{ re.search(pattern }\OperatorTok{=} \VerbatimStringTok{r"[H,B]}\SpecialCharTok{\{2\}}\VerbatimStringTok{"}\NormalTok{, string }\OperatorTok{=}\NormalTok{ statement)}
\BuiltInTok{print}\NormalTok{(search\_result2)}

\CommentTok{\# Replace all instances of "HB"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <re.Match object; span=(16, 18), match='HB'>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{all\_replaced }\OperatorTok{=}\NormalTok{ re.sub(pattern }\OperatorTok{=} \StringTok{\textquotesingle{}HB\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}HB (hard black)\textquotesingle{}}\NormalTok{, string }\OperatorTok{=}\NormalTok{ statement)}
\BuiltInTok{print}\NormalTok{(all\_replaced)}

\CommentTok{\# Replace just the first instance of HB}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Pencils with an HB (hard black) graphite grade are commonly used for writing. An HB (hard black) pencil is approximately equal to a #2 pencil.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{one\_replaced }\OperatorTok{=}\NormalTok{ re.sub(pattern }\OperatorTok{=} \StringTok{\textquotesingle{}HB\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}HB (hard black)\textquotesingle{}}\NormalTok{, string }\OperatorTok{=}\NormalTok{ statement, count }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(one\_replaced)}

\CommentTok{\# Search and replace using a regex pattern instead of a fixed string}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Pencils with an HB (hard black) graphite grade are commonly used for writing. An HB pencil is approximately equal to a #2 pencil.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{regex\_replaced }\OperatorTok{=}\NormalTok{ re.sub(pattern }\OperatorTok{=} \VerbatimStringTok{r\textquotesingle{}(?\textless{}=\textbackslash{}.)\textbackslash{}s}\SpecialCharTok{\{1\}}\VerbatimStringTok{\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{, string }\OperatorTok{=}\NormalTok{ statement)}
\BuiltInTok{print}\NormalTok{(regex\_replaced)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Pencils with an HB graphite grade are commonly used for writing.
## An HB pencil is approximately equal to a #2 pencil.
\end{verbatim}

\hypertarget{r-25}{%
\subsubsection*{R}\label{r-25}}
\addcontentsline{toc}{subsubsection}{R}

The standard-issue string-search function is \texttt{grep()}; it returns the index of the elements in a set of one or more strings for which a pattern match was found. (\texttt{grepl()} acts similarly but returns a vector of \texttt{TRUE}/\texttt{FALSE} indicating whether a match was found in each string passed to the function.) The functions \texttt{sub()} and \texttt{gsub()} can be used to find and replace instances of a pattern: The former replaces just the first instance; the latter replaces all instances. The search pattern can be provided as a raw character string or as a regular expression.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{statements }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}Great Pencil Co. primarily sells pencils of the following grades: HB; B; and 3B.\textquotesingle{}}\NormalTok{,}
                \StringTok{\textquotesingle{}Great Pencil Co. has its headquarters in Maine, and Great Pencil Co. has supplied the Northeast for decades.\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Search for pattern and return indexex of elements for which match is found}
\FunctionTok{grep}\NormalTok{(}\AttributeTok{pattern =} \StringTok{\textquotesingle{}pencil\textquotesingle{}}\NormalTok{, }\AttributeTok{x =}\NormalTok{ statements) }\CommentTok{\# When searched for case sensitively, "pencil" is only found in the first string}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{grep}\NormalTok{(}\AttributeTok{pattern =} \StringTok{\textquotesingle{}(?i)pencil\textquotesingle{}}\NormalTok{, }\AttributeTok{x =}\NormalTok{ statements) }\CommentTok{\# When searched for case insensitively, "P/pencil" is found in both strings}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Replace the first instance of a pattern (Co. {-}{-}\textgreater{} Company)}
\NormalTok{revised }\OtherTok{\textless{}{-}} \FunctionTok{sub}\NormalTok{(}\AttributeTok{pattern =} \StringTok{\textquotesingle{}Co.\textquotesingle{}}\NormalTok{, }\AttributeTok{replacement =} \StringTok{\textquotesingle{}Company\textquotesingle{}}\NormalTok{, }\AttributeTok{x =}\NormalTok{ statements)}
\NormalTok{revised}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Great Pencil Company primarily sells pencils of the following grades: HB; B; and 3B."                            
## [2] "Great Pencil Company has its headquarters in Maine, and Great Pencil Co. has supplied the Northeast for decades."
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Replace all instances of a pattern (; {-}{-}\textgreater{} ,)}
\NormalTok{revised2 }\OtherTok{\textless{}{-}} \FunctionTok{gsub}\NormalTok{(}\AttributeTok{pattern =} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{, }\AttributeTok{replacement =} \StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{, }\AttributeTok{x =}\NormalTok{ revised)}
\NormalTok{revised2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Great Pencil Company primarily sells pencils of the following grades: HB, B, and 3B."                            
## [2] "Great Pencil Company has its headquarters in Maine, and Great Pencil Co. has supplied the Northeast for decades."
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Find and replace a pattern using regex (3B {-}{-}\textgreater{} 2B)}
\NormalTok{final }\OtherTok{\textless{}{-}} \FunctionTok{sub}\NormalTok{(}\AttributeTok{pattern =} \StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d\{1\}\textquotesingle{}}\NormalTok{, }\AttributeTok{replacement =} \StringTok{\textquotesingle{}2\textquotesingle{}}\NormalTok{, }\AttributeTok{x =}\NormalTok{ revised2)}
\NormalTok{final}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Great Pencil Company primarily sells pencils of the following grades: HB, B, and 2B."                            
## [2] "Great Pencil Company has its headquarters in Maine, and Great Pencil Co. has supplied the Northeast for decades."
\end{verbatim}

Those functions can be used to trim excess (or all) white space in character strings.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{spaced\_string }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}This      string    started  out with too    many    spaces.\textquotesingle{}}\NormalTok{)}
\CommentTok{\# Replace all instances of \textgreater{}=2 spaces with single spaces}
\FunctionTok{gsub}\NormalTok{(}\AttributeTok{pattern =} \StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s\{2,\}\textquotesingle{}}\NormalTok{, }\AttributeTok{replacement =} \StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{, }\AttributeTok{x =}\NormalTok{ spaced\_string)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "This string started out with too many spaces."
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Remove all white space}
\NormalTok{collapse\_these }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}9:00 {-} 10:15\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}10:15 {-} 11:30\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}11:30 {-} 12:00\textquotesingle{}}\NormalTok{)}
\FunctionTok{gsub}\NormalTok{(}\AttributeTok{pattern =} \StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s\textquotesingle{}}\NormalTok{, }\AttributeTok{replacement =} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, }\AttributeTok{x =}\NormalTok{ collapse\_these)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "9:00-10:15"  "10:15-11:30" "11:30-12:00"
\end{verbatim}

The package \textbf{stringi} also provides an array of string-search and string-manipulation functions, including \texttt{stri\_detect()}, \texttt{stri\_replace()}, and \texttt{stri\_extract()}, all of which easily handle fixed and regex search patterns. For example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(stringi)}
\NormalTok{user\_dat }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{name =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}Shire, Jane E\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Winchester, Marcus L\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Fox, Sal\textquotesingle{}}\NormalTok{), }\AttributeTok{id\_number =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}aaa101\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}aaa102\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}aaa103\textquotesingle{}}\NormalTok{))}
\NormalTok{user\_dat}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                   name id_number
## 1        Shire, Jane E    aaa101
## 2 Winchester, Marcus L    aaa102
## 3             Fox, Sal    aaa103
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Say we want to use regex patterns and the stringi package to eliminate the \textquotesingle{}aaa\textquotesingle{} patterns from}
\CommentTok{\# the user IDs and then add middle initials{-}{-}{-}for those users who have them{-}{-}{-}to the data frame}
\NormalTok{user\_dat}\SpecialCharTok{$}\NormalTok{id\_number }\OtherTok{\textless{}{-}} \FunctionTok{stri\_replace}\NormalTok{(user\_dat}\SpecialCharTok{$}\NormalTok{id\_number, }\AttributeTok{regex =} \StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{w\{3\}(?=}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d+)\textquotesingle{}}\NormalTok{, }\AttributeTok{replacement =} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}
\NormalTok{user\_dat}\SpecialCharTok{$}\NormalTok{middle\_initial }\OtherTok{\textless{}{-}} \FunctionTok{stri\_extract}\NormalTok{(user\_dat}\SpecialCharTok{$}\NormalTok{name, }\AttributeTok{regex =} \StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{b}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{w\{1\}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{b\textquotesingle{}}\NormalTok{)}
\NormalTok{user\_dat}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                   name id_number middle_initial
## 1        Shire, Jane E       101              E
## 2 Winchester, Marcus L       102              L
## 3             Fox, Sal       103           <NA>
\end{verbatim}

\hypertarget{change-case}{%
\section{Change case}\label{change-case}}

How to change the case of strings. The most common case transformations are lower case, upper case, and title case.

\hypertarget{python-26}{%
\subsubsection*{Python}\label{python-26}}
\addcontentsline{toc}{subsubsection}{Python}

The \texttt{lower()}, \texttt{upper()}, and \texttt{title()} functions convert case to lower, upper, and title, respectively. We can use a list comprehension to apply these functions to each string in a list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{col\_names }\OperatorTok{=}\NormalTok{ [col.upper() }\ControlFlowTok{for}\NormalTok{ col }\KeywordTok{in}\NormalTok{ mtcars.columns]}
\NormalTok{mtcars.columns }\OperatorTok{=}\NormalTok{ col\_names}
\end{Highlighting}
\end{Shaded}

\hypertarget{r-26}{%
\subsubsection*{R}\label{r-26}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{tolower()} and \texttt{toupper()} functions convert case to lower and upper, respectively.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(mtcars) }\OtherTok{\textless{}{-}} \FunctionTok{toupper}\NormalTok{(}\FunctionTok{names}\NormalTok{(mtcars))}
\FunctionTok{names}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "MPG"        "CYLINDERS"  "DISP"       "HP"         "AXLE_RATIO"
##  [6] "WEIGHT"     "QSEC"       "ENGINE"     "AM"         "GEAR"      
## [11] "CARB"       "AM_CH"      "AM_FAC"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(mtcars) }\OtherTok{\textless{}{-}} \FunctionTok{tolower}\NormalTok{(}\FunctionTok{names}\NormalTok{(mtcars))}
\FunctionTok{names}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "mpg"        "cylinders"  "disp"       "hp"         "axle_ratio"
##  [6] "weight"     "qsec"       "engine"     "am"         "gear"      
## [11] "carb"       "am_ch"      "am_fac"
\end{verbatim}

The \textbf{stringr} package provides a convenient title case conversion function, \texttt{str\_to\_title()}, which capitalizes the first letter of each string.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stringr}\SpecialCharTok{::}\FunctionTok{str\_to\_title}\NormalTok{(}\FunctionTok{names}\NormalTok{(mtcars))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Mpg"        "Cylinders"  "Disp"       "Hp"         "Axle_ratio"
##  [6] "Weight"     "Qsec"       "Engine"     "Am"         "Gear"      
## [11] "Carb"       "Am_ch"      "Am_fac"
\end{verbatim}

\hypertarget{drop-duplicate-rows}{%
\section{Drop duplicate rows}\label{drop-duplicate-rows}}

How to find and drop duplicate elements.

\hypertarget{python-27}{%
\subsubsection*{Python}\label{python-27}}
\addcontentsline{toc}{subsubsection}{Python}

The \texttt{duplicated()} function determines which rows of a DataFrame are duplicates of previous rows.

First, we create a DataFrame with a duplicate row by using the pandas \texttt{concat()} function. \texttt{concat()} combines DataFrames by rows or columns, row by default.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# create DataFrame with duplicate rows}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\NormalTok{mtcars2 }\OperatorTok{=}\NormalTok{ pd.concat([mtcars.iloc[}\DecValTok{0}\NormalTok{:}\DecValTok{3}\NormalTok{,}\DecValTok{0}\NormalTok{:}\DecValTok{6}\NormalTok{], mtcars.iloc[}\DecValTok{0}\NormalTok{:}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{:}\DecValTok{6}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

The \texttt{duplicated()} function returns a logical vector. TRUE indicates a row is a duplicate of a previous row.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# create DataFrame with duplicate rows}
\NormalTok{mtcars2.duplicated()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0    False
## 1    False
## 2    False
## 0     True
## dtype: bool
\end{verbatim}

\hypertarget{r-27}{%
\subsubsection*{R}\label{r-27}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{duplicated()} function ``determines which elements of a vector or data frame are duplicates of elements with smaller subscripts''. (from \texttt{?duplicated})

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# create data frame with duplicate rows}
\NormalTok{mtcars2 }\OtherTok{\textless{}{-}} \FunctionTok{rbind}\NormalTok{(mtcars[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{], mtcars[}\DecValTok{1}\NormalTok{,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{])}
\CommentTok{\# last row is duplicate of first}
\NormalTok{mtcars2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    mpg cylinders disp  hp axle_ratio weight
## 1 21.0         6  160 110       3.90  2.620
## 2 21.0         6  160 110       3.90  2.875
## 3 22.8         4  108  93       3.85  2.320
## 4 21.0         6  160 110       3.90  2.620
\end{verbatim}

The \texttt{duplicated()} function returns a logical vector. TRUE indicates a row is a duplicate of a previous row.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# last row is duplicate}
\FunctionTok{duplicated}\NormalTok{(mtcars2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE FALSE FALSE  TRUE
\end{verbatim}

The TRUE/FALSE vector can be used to extract or drop duplicate rows. Since TRUE in indexing brackets will keep a row, we can use \texttt{!} to negate the logicals and keep those that are ``NOT TRUE''

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# drop the duplicate and update the data frame}
\NormalTok{mtcars3 }\OtherTok{\textless{}{-}}\NormalTok{ mtcars2[}\SpecialCharTok{!}\FunctionTok{duplicated}\NormalTok{(mtcars2),]}
\NormalTok{mtcars3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    mpg cylinders disp  hp axle_ratio weight
## 1 21.0         6  160 110       3.90  2.620
## 2 21.0         6  160 110       3.90  2.875
## 3 22.8         4  108  93       3.85  2.320
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# extract and investigate the duplicate row}
\NormalTok{mtcars2[}\FunctionTok{duplicated}\NormalTok{(mtcars2),]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   mpg cylinders disp  hp axle_ratio weight
## 4  21         6  160 110        3.9   2.62
\end{verbatim}

The \texttt{anyDuplicated()} function returns the row number of duplicate rows.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{anyDuplicated}\NormalTok{(mtcars2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\hypertarget{format-dates}{%
\section{Format dates}\label{format-dates}}

With formatted dates we can calculate elapsed time, extract components of a date, properly order names of months, and more.

\hypertarget{python-28}{%
\subsubsection*{Python}\label{python-28}}
\addcontentsline{toc}{subsubsection}{Python}

The Python module \texttt{datetime} can be used to create various date and time objects. Here we will discuss 4 of the main classes within \texttt{datetime} that are most useful.

The first class we will go over is the \texttt{date()} class. This creates a ``date'' object whose only attributes are year, month, day.

Here we create a date object using the date class. The attributes are specified as integers in the argument of \texttt{date()} in this order \texttt{date(year,\ month,\ day)}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ datetime }\ImportTok{as}\NormalTok{ dt }

\NormalTok{x }\OperatorTok{=}\NormalTok{ dt.date(}\DecValTok{2001}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{12}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2001-04-12
\end{verbatim}

To get today's date, we can use the \texttt{date.today()} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{today }\OperatorTok{=}\NormalTok{ dt.date.today()}
\BuiltInTok{print}\NormalTok{(today)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2022-04-21
\end{verbatim}

Note that the output of both x and today are only year-month-day because they are date objects.

We can extract each of these attributes (year, month, day) from the date object as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{today.year }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2022
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{today.month}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{today.day}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 21
\end{verbatim}

Next we will discuss the \texttt{time()} class. This class creates time objects containing information about only a time. The attributes that go into the \texttt{time()} class are hours, minutes, seconds in that order. Like the date class, these attributes must be inputted as integers.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=}\NormalTok{ dt.time(}\DecValTok{11}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{56}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 11:34:56
\end{verbatim}

If you want a time object containing only hours and minutes, only seconds, etc. you can specify the attributes by name when creating the time object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{only\_hrs }\OperatorTok{=}\NormalTok{ dt.time(hour }\OperatorTok{=} \DecValTok{10}\NormalTok{)}
\NormalTok{only\_mins }\OperatorTok{=}\NormalTok{ dt.time(minute }\OperatorTok{=} \DecValTok{55}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(only\_hrs)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 10:00:00
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(only\_mins)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 00:55:00
\end{verbatim}

Again similar to the date class, we can extract hour, minute, and second attributes from the time objects:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y.hour}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 11
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y.minute}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 34
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y.second}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 56
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y.microsecond}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0
\end{verbatim}

Now we will talk about the \texttt{datetime()} class that creates a datetime object containing information about both date and time. The attributes must be inputted as integers and are year, month, day, hour, minute, second, in that order. Like the date and time classes, we can speficy specific attributes in the argument using the attrubute names as well. If we don't specify any time components, the datetime object defaults to time 00:00:00.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Input attributes in order}
\NormalTok{z }\OperatorTok{=}\NormalTok{ dt.datetime(}\DecValTok{1981}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{56}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(z)}

\CommentTok{\# Input attributes using attribute names (any order)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1981-04-12 11:34:56
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z2}\OperatorTok{=}\NormalTok{ dt.datetime(year }\OperatorTok{=} \DecValTok{2021}\NormalTok{, day }\OperatorTok{=} \DecValTok{6}\NormalTok{, month }\OperatorTok{=} \DecValTok{12}\NormalTok{, hour }\OperatorTok{=} \DecValTok{6}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(z2)}

\CommentTok{\# No time attributes}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2021-12-06 06:00:00
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z3 }\OperatorTok{=}\NormalTok{ dt.datetime(}\DecValTok{1981}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{12}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(z3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1981-04-12 00:00:00
\end{verbatim}

Again, we can extract attributes in exactly the same way as the date and time classes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z.year}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1981
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z.day}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 12
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z.hour}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 11
\end{verbatim}

The final class we will discuss is the \texttt{timedelta} class. This class is used to store date/time differences between date objects.

The default settings for a timedelta object are as follows: \texttt{timedelta(weeks=0,\ days=0,\ hours=0,minutes=0,\ seconds=0,\ milliseconds=0,\ microseconds=0)}

Here is an example of howto add and subtract datesa and times using these objects.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Create a datetime object for the current time that we will increment}
\NormalTok{d1 }\OperatorTok{=}\NormalTok{ dt.datetime.now()}
\BuiltInTok{print}\NormalTok{(d1)}

\CommentTok{\# Add 550 days to our datetime object }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2022-04-21 12:02:58.678367
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d2 }\OperatorTok{=}\NormalTok{ d1 }\OperatorTok{+}\NormalTok{ dt.timedelta(days }\OperatorTok{=} \DecValTok{550}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(d2)}

\CommentTok{\# Subtract 5 hours from our datetime object }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2023-10-23 12:02:58.678367
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d3 }\OperatorTok{=}\NormalTok{ d1 }\OperatorTok{{-}}\NormalTok{ dt.timedelta(hours }\OperatorTok{=} \DecValTok{5}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(d3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2022-04-21 07:02:58.678367
\end{verbatim}

Finally, we will discuss how to convert strings to datetime objects and vice versa.

The attribute \texttt{strftime()} converts datetime objects to strings. In the argument of \texttt{strftime()} can specify the format you would like.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## datetime.datetime(2022, 4, 21, 12, 2, 58, 678367)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d1.strftime(}\StringTok{"\%A \%m \%Y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'Thursday 04 2022'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d1.strftime(}\StringTok{"\%a \%m \%y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'Thu 04 22'
\end{verbatim}

The attribute \texttt{strptime()} converts strings into datetime objects. In the argument of \texttt{strptime()} you must specify the string and then the format of the string.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d4 }\OperatorTok{=} \StringTok{"27/10/98 11:03:9.033"}

\NormalTok{d1.strptime(d4, }\StringTok{"}\SpecialCharTok{\%d}\StringTok{/\%m/\%y \%H:\%M:\%S.}\SpecialCharTok{\%f}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## datetime.datetime(1998, 10, 27, 11, 3, 9, 33000)
\end{verbatim}

\hypertarget{r-28}{%
\subsubsection*{R}\label{r-28}}
\addcontentsline{toc}{subsubsection}{R}

Dates in R can be stored as a Date class or a Date-Time class. Dates are stored as the number of days since January 1, 1970. Date-Times are stored as the number of seconds since January 1, 1970. With dates stored in this manner we can calculate elapsed time in units such as days, weeks, hours, minutes, and so forth.

Below are the dates of the first five NASA \href{https://en.wikipedia.org/wiki/List_of_Space_Shuttle_missions\#Shuttle_flights}{Columbia Space Shuttle flights} entered as a character vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"12 April 1981"}\NormalTok{, }
          \StringTok{"12 November 1981"}\NormalTok{, }
          \StringTok{"22 March 1982"}\NormalTok{, }
          \StringTok{"27 June 1982"}\NormalTok{, }
          \StringTok{"11 November 1982"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

R does not immediately recognize these as a Date class. To format as a Date class, we can either use the base R \texttt{as.Date()} function or one of the convenience functions in the \textbf{lubridate} package. The \texttt{as.Date()} function requires a specified POSIX conversion specification as documented in \texttt{?strptime}. Below the conversion code ``\%d \%B \%Y'' says Date is entered as two digit day of month (\%d), full month name (\%B), and year with century (\%Y).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date1 }\OtherTok{\textless{}{-}} \FunctionTok{as.Date}\NormalTok{(date, }\AttributeTok{format =} \StringTok{"\%d \%B \%Y"}\NormalTok{)}
\NormalTok{date1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1981-04-12" "1981-11-12" "1982-03-22" "1982-06-27" "1982-11-11"
\end{verbatim}

The dates now print in year-month-date format, however they are stored internally as number of days since January 1, 1970. This can be seen by using \texttt{as.numeric()} on the ``date1'' vector.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(date1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4119 4333 4463 4560 4697
\end{verbatim}

The \textbf{lubridate} package provides a series of functions that are permutations of the letters ``m'', ``d'', and ``y'' to represent the order of date components. To format the original ``date'' vector, we use the \texttt{dmy()} function since the date components are ordered as day, month and year. Notice we must load the \textbf{lubridate} package to use this function.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(lubridate)}
\NormalTok{date2 }\OtherTok{\textless{}{-}} \FunctionTok{dmy}\NormalTok{(date)}
\NormalTok{date2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1981-04-12" "1981-11-12" "1982-03-22" "1982-06-27" "1982-11-11"
\end{verbatim}

When dates are formatted we can easily extract information such as day of week or month. For example to extract the day of week of the launches as an ordered factor, we can use the \textbf{lubridate} function \texttt{wday()} with \texttt{label=TRUE} and \texttt{abbr\ =\ FALSE}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{wday}\NormalTok{(date2, }\AttributeTok{label =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{abbr =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] Sunday   Thursday Monday   Sunday   Thursday
## 7 Levels: Sunday < Monday < Tuesday < Wednesday < Thursday < ... < Saturday
\end{verbatim}

To calculate elapsed time between launches in days we can use the base R \texttt{diff()} function.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{diff}\NormalTok{(date2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Time differences in days
## [1] 214 130  97 137
\end{verbatim}

To store a date as a Date-Time class we need to include a time component. Below are the first five Columbia launch dates with times. UTC refers to \href{https://en.wikipedia.org/wiki/Coordinated_Universal_Time}{Universal Coordinated Time}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datetime }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"12 April 1981 12:00:04 UTC"}\NormalTok{,}
              \StringTok{"12 November 1981 15:10:00 UTC"}\NormalTok{,}
              \StringTok{"22 March 1982 16:00:00 UTC"}\NormalTok{,}
              \StringTok{"27 June 1982 15:00:00 UTC"}\NormalTok{,}
              \StringTok{"11 November 1982 12:19:00 UTC"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To format as a Date-Time class we can use either the base R \texttt{as.POSIXct()} function or one of the convenience functions in the \textbf{lubridate} package. To use \texttt{as.POSIXct()} we need to include additional POSIX conversion specifications for the hour, minute and second of launch. The ``\%H:\%M:\%S'' specification refers to hours, minutes and seconds. The \texttt{tz} argument specifies the time zone of the times.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datetime1 }\OtherTok{\textless{}{-}} \FunctionTok{as.POSIXct}\NormalTok{(datetime, }
                        \AttributeTok{format =} \StringTok{"\%d \%B \%Y \%H:\%M:\%S"}\NormalTok{, }
                        \AttributeTok{tz =} \StringTok{"UTC"}\NormalTok{)}
\NormalTok{datetime1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1981-04-12 12:00:04 UTC" "1981-11-12 15:10:00 UTC"
## [3] "1982-03-22 16:00:00 UTC" "1982-06-27 15:00:00 UTC"
## [5] "1982-11-11 12:19:00 UTC"
\end{verbatim}

When we use \texttt{as.numeric()} on the ``datetime1'' vector we see it is stored as number of seconds since January 1, 1970.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(datetime1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 355924804 374425800 385660800 394038000 405865140
\end{verbatim}

Using \textbf{lubridate} we can append \texttt{\_hms()} to any of the ``mdy'' functions to format dates with time components as a Date-Time class. Notice the default time zone in \textbf{lubridate} is UTC.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datetime2 }\OtherTok{\textless{}{-}} \FunctionTok{dmy\_hms}\NormalTok{(datetime)}
\NormalTok{datetime2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1981-04-12 12:00:04 UTC" "1981-11-12 15:10:00 UTC"
## [3] "1982-03-22 16:00:00 UTC" "1982-06-27 15:00:00 UTC"
## [5] "1982-11-11 12:19:00 UTC"
\end{verbatim}

To calculate elapsed time between launches in hours, we can use the \textbf{lubridate} function \texttt{time\_length()} with the \texttt{unit} set to ``hours''. Below we use \texttt{diff()} and then pipe to \texttt{time\_length()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{diff}\NormalTok{(datetime2) }\SpecialCharTok{|}\ErrorTok{\textgreater{}} \FunctionTok{time\_length}\NormalTok{(}\AttributeTok{unit =} \StringTok{"hours"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5139.166 3120.833 2327.000 3285.317
\end{verbatim}

For more information on working with dates and times in R, see the vignette accompanying the \textbf{lubridate} package.

\hypertarget{randomly-sample-rows}{%
\section{Randomly sample rows}\label{randomly-sample-rows}}

How to take a random sample of rows from a data frame. The sample is usually either a fixed size or a proportion.

\hypertarget{python-29}{%
\subsubsection*{Python}\label{python-29}}
\addcontentsline{toc}{subsubsection}{Python}

The pandas package provide a function for taking a sample of fixed size or a proportion. To sample with replacement, set \texttt{replace\ =\ TRUE}.

Additionally, the random sample will change every time the code is run. To always generate the same ``random'' sample, set \texttt{random\_state} to any positive integer.

To create a sample with a fixed number of rows, use the \texttt{n} argument.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# sample 5 rows from mtcars}
\NormalTok{mtcars.sample(n}\OperatorTok{=}\DecValTok{5}\NormalTok{, replace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      MPG  CYL   DISP   HP  AXLE_RATIO    WT   QSEC  VS AM  GEAR  CARB       KPL
## 2   22.8    4  108.0   93        3.85  2.32  18.61   1  1     4     1  4.846939
## 2   22.8    4  108.0   93        3.85  2.32  18.61   1  1     4     1  4.846939
## 11  16.4    8  275.8  180        3.07  4.07  17.40   0  0     3     3  3.486395
## 10  17.8    6  167.6  123        3.92  3.44  18.90   1  0     4     4  3.784014
## 6   14.3    8  360.0  245        3.21  3.57  15.84   0  0     3     4  3.039966
\end{verbatim}

To create a sample of a proportion, use the \texttt{frac} argument.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# sample 20\% of rows from mtcars}
\NormalTok{mtcars.sample(frac }\OperatorTok{=} \FloatTok{0.20}\NormalTok{, random\_state}\OperatorTok{=}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      MPG  CYL   DISP   HP  AXLE_RATIO  ...  VS  AM  GEAR CARB       KPL
## 27  30.4    4   95.1  113        3.77  ...   1   1     5    2  6.462585
## 3   21.4    6  258.0  110        3.08  ...   1   0     3    1  4.549320
## 22  15.2    8  304.0  150        3.15  ...   0   0     3    2  3.231293
## 18  30.4    4   75.7   52        4.93  ...   1   1     4    2  6.462585
## 23  13.3    8  350.0  245        3.73  ...   0   0     3    4  2.827381
## 17  32.4    4   78.7   66        4.08  ...   1   1     4    1  6.887755
## 
## [6 rows x 12 columns]
\end{verbatim}

The numpy function \texttt{random.choice()} in combination with the \texttt{loc()} function can be used to sample from a DataFrame.

The \texttt{random.choice()} function creates a random sample according to the given parameters. The \texttt{loc()} function is used to access rows and columns by index.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import the numpy package}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\CommentTok{\# create a random sample of size 5 with replacement}
\NormalTok{random\_sample }\OperatorTok{=}\NormalTok{ np.random.choice(}\BuiltInTok{len}\NormalTok{(mtcars), (}\DecValTok{5}\NormalTok{,), replace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}

\CommentTok{\# use random\_sample to sample from mtcars}
\NormalTok{mtcars.loc[random\_sample,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      MPG  CYL   DISP   HP  AXLE_RATIO  ...  VS  AM  GEAR CARB       KPL
## 2   22.8    4  108.0   93        3.85  ...   1   1     4    1  4.846939
## 16  14.7    8  440.0  230        3.23  ...   0   0     3    4  3.125000
## 29  19.7    6  145.0  175        3.62  ...   0   1     5    6  4.187925
## 19  33.9    4   71.1   65        4.22  ...   1   1     4    1  7.206633
## 15  10.4    8  460.0  215        3.00  ...   0   0     3    4  2.210884
## 
## [5 rows x 12 columns]
\end{verbatim}

The random sample will change every time the code is run. To always generate the same ``random'' sample, use the \texttt{random.seed()} function with any positive integer.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# setting seed to always get same random sample}
\NormalTok{np.random.seed(}\DecValTok{123}\NormalTok{)}

\CommentTok{\# create a random sample of size 5 with replacement}
\NormalTok{sample }\OperatorTok{=}\NormalTok{ np.random.choice(}\BuiltInTok{len}\NormalTok{(mtcars), (}\DecValTok{5}\NormalTok{,), replace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{mtcars.loc[sample,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      MPG  CYL   DISP   HP  AXLE_RATIO    WT   QSEC  VS AM  GEAR  CARB       KPL
## 30  15.0    8  301.0  335        3.54  3.57  14.60   0  1     5     8  3.188776
## 13  15.2    8  275.8  180        3.07  3.78  18.00   0  0     3     3  3.231293
## 30  15.0    8  301.0  335        3.54  3.57  14.60   0  1     5     8  3.188776
## 2   22.8    4  108.0   93        3.85  2.32  18.61   1  1     4     1  4.846939
## 28  15.8    8  351.0  264        4.22  3.17  14.50   0  1     5     4  3.358844
\end{verbatim}

\hypertarget{r-29}{%
\subsubsection*{R}\label{r-29}}
\addcontentsline{toc}{subsubsection}{R}

There are many ways to sample rows from a data frame in R. The \href{https://dplyr.tidyverse.org/}{\textbf{dplyr}} package provides a convenience function, \texttt{slice\_sample()}, for taking either a fixed sample size or a proportion.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# sample 5 rows from mtcars}
\NormalTok{dplyr}\SpecialCharTok{::}\FunctionTok{slice\_sample}\NormalTok{(mtcars, }\AttributeTok{n =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    mpg cylinders  disp  hp axle_ratio weight  qsec engine am gear carb am_ch
## 1 26.0         4 120.3  91       4.43  2.140 16.70      0  1    5    2     1
## 2 15.2         8 304.0 150       3.15  3.435 17.30      0  0    3    2     0
## 3 21.0         6 160.0 110       3.90  2.875 17.02      0  1    4    4     1
## 4 13.3         8 350.0 245       3.73  3.840 15.41      0  0    3    4     0
## 5 15.5         8 318.0 150       2.76  3.520 16.87      0  0    3    2     0
##      am_fac
## 1    manual
## 2 automatic
## 3    manual
## 4 automatic
## 5 automatic
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# sample 20\% of rows from mtcars}
\NormalTok{dplyr}\SpecialCharTok{::}\FunctionTok{slice\_sample}\NormalTok{(mtcars, }\AttributeTok{prop =} \FloatTok{0.20}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    mpg cylinders  disp  hp axle_ratio weight  qsec engine am gear carb am_ch
## 1 15.5         8 318.0 150       2.76  3.520 16.87      0  0    3    2     0
## 2 10.4         8 472.0 205       2.93  5.250 17.98      0  0    3    4     0
## 3 21.0         6 160.0 110       3.90  2.620 16.46      0  1    4    4     1
## 4 21.5         4 120.1  97       3.70  2.465 20.01      1  0    3    1     0
## 5 19.2         6 167.6 123       3.92  3.440 18.30      1  0    4    4     0
## 6 30.4         4  75.7  52       4.93  1.615 18.52      1  1    4    2     1
##      am_fac
## 1 automatic
## 2 automatic
## 3    manual
## 4 automatic
## 5 automatic
## 6    manual
\end{verbatim}

To sample with replacement, set \texttt{replace\ =\ TRUE}.

The base R functions \texttt{sample()} and \texttt{runif()} can be combined to sample fixed sizes or approximate proportions.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# sample 5 rows from mtcars}
\CommentTok{\# get random row numbers}
\NormalTok{i }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(mtcars), }\AttributeTok{size =} \DecValTok{5}\NormalTok{)}
\CommentTok{\# use i to select rows}
\NormalTok{mtcars[i,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg cylinders  disp  hp axle_ratio weight  qsec engine am gear carb am_ch
## 12 16.4         8 275.8 180       3.07  4.070 17.40      0  0    3    3     0
## 32 21.4         4 121.0 109       4.11  2.780 18.60      1  1    4    2     1
## 17 14.7         8 440.0 230       3.23  5.345 17.42      0  0    3    4     0
## 23 15.2         8 304.0 150       3.15  3.435 17.30      0  0    3    2     0
## 28 30.4         4  95.1 113       3.77  1.513 16.90      1  1    5    2     1
##       am_fac
## 12 automatic
## 32    manual
## 17 automatic
## 23 automatic
## 28    manual
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# sample about 20\% of rows from mtcars}
\CommentTok{\# generate random values on range of [0,1]}
\NormalTok{i }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(mtcars))}
\CommentTok{\# use i \textless{} 0.20 logical vector to }
\CommentTok{\# select rows that correspond to TRUE}
\NormalTok{mtcars[i }\SpecialCharTok{\textless{}} \FloatTok{0.20}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg cylinders  disp  hp axle_ratio weight  qsec engine am gear carb am_ch
## 24 13.3         8 350.0 245       3.73  3.840 15.41      0  0    3    4     0
## 28 30.4         4  95.1 113       3.77  1.513 16.90      1  1    5    2     1
## 29 15.8         8 351.0 264       4.22  3.170 14.50      0  1    5    4     1
##       am_fac
## 24 automatic
## 28    manual
## 29    manual
\end{verbatim}

The random sample will change every time the code is run. To always generate the same ``random'' sample, use the \texttt{set.seed()} function with any positive integer.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# always get the same random sample}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\NormalTok{i }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(mtcars))}
\NormalTok{mtcars[i }\SpecialCharTok{\textless{}} \FloatTok{0.20}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mpg cylinders  disp  hp axle_ratio weight  qsec engine am gear carb am_ch
## 6  18.1         6 225.0 105       2.76   3.46 20.22      1  0    3    1     0
## 15 10.4         8 472.0 205       2.93   5.25 17.98      0  0    3    4     0
## 18 32.4         4  78.7  66       4.08   2.20 19.47      1  1    4    1     1
## 30 19.7         6 145.0 175       3.62   2.77 15.50      0  1    5    6     1
##       am_fac
## 6  automatic
## 15 automatic
## 18    manual
## 30    manual
\end{verbatim}

\hypertarget{combine-reshape-and-merge}{%
\chapter{Combine, Reshape and Merge}\label{combine-reshape-and-merge}}

This chapter looks at various strategies for combining, reshaping, and merging data.

\hypertarget{combine-rows}{%
\section{Combine rows}\label{combine-rows}}

Combining rows may be thought of as ``stacking'' rectangular data structures.

\hypertarget{python-30}{%
\subsubsection*{Python}\label{python-30}}
\addcontentsline{toc}{subsubsection}{Python}

The pandas function \texttt{concat} function ``binds'' rows. It takes a list of pandas DataFrame objects. The second argument \texttt{axis} specifies a row bind when 0 and a column bind when 1. The default value is 0. The column names of the DataFrames should match, otherwise the DataFrame fills with NaNs. You can bind rows with different column types.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}

\NormalTok{d1 }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{:[}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{], }\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{:[}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{]\})}
\NormalTok{d2 }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{:[}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{], }\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{:[}\StringTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}e\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}f\textquotesingle{}}\NormalTok{]\})}

\CommentTok{\# create list of DataFrame objects}
\NormalTok{frames }\OperatorTok{=}\NormalTok{ [d1, d2]}
\NormalTok{combined\_df }\OperatorTok{=}\NormalTok{ pd.concat(frames)}

\NormalTok{combined\_df}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    x  y
## 0  4  a
## 1  5  b
## 2  6  c
## 0  3  d
## 1  2  e
## 2  1  f
\end{verbatim}

The following code is an example of when column names do not match, resulting in NaNs in the DataFrame.

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{\# DataFrame with different column names}
\NormalTok{d1 }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{:[}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{], }\StringTok{\textquotesingle{}z\textquotesingle{}}\NormalTok{:[}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{]\})}
\NormalTok{d2 }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{:[}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{], }\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{:[}\StringTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}e\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}f\textquotesingle{}}\NormalTok{]\})}

\CommentTok{\# create list of DataFrame objects}
\NormalTok{frames }\OperatorTok{=}\NormalTok{ [d1, d2]}
\NormalTok{combined\_df }\OperatorTok{=}\NormalTok{ pd.concat(frames)}

\NormalTok{combined\_df}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    x    z    y
## 0  4    a  NaN
## 1  5    b  NaN
## 2  6    c  NaN
## 0  3  NaN    d
## 1  2  NaN    e
## 2  1  NaN    f
\end{verbatim}

\hypertarget{r-30}{%
\subsubsection*{R}\label{r-30}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{rbind()} function ``binds'' rows. It takes two or more objects. To row bind data frames, the column names must match, otherwise an error is returned. If columns being stacked have differing variable types, the values will be coerced according to \texttt{logical} \textless{} \texttt{integer} \textless{} \texttt{double} \textless{} \texttt{complex} \textless{} \texttt{character}. (E.g., if you stack a set of rows with type \texttt{logical} in column \emph{J} on a set of rows with type \texttt{character} in column \emph{J}, the output will have column \emph{J} as type \texttt{character}.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d1 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =} \DecValTok{4}\SpecialCharTok{:}\DecValTok{6}\NormalTok{, }\AttributeTok{y =}\NormalTok{ letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{])}
\NormalTok{d2 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =} \DecValTok{3}\SpecialCharTok{:}\DecValTok{1}\NormalTok{, }\AttributeTok{y =}\NormalTok{ letters[}\DecValTok{4}\SpecialCharTok{:}\DecValTok{6}\NormalTok{])}
\FunctionTok{rbind}\NormalTok{(d1, d2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   x y
## 1 4 a
## 2 5 b
## 3 6 c
## 4 3 d
## 5 2 e
## 6 1 f
\end{verbatim}

See also the \texttt{bind\_rows()} function in the \textbf{dplyr} package.

\hypertarget{combine-columns}{%
\section{Combine columns}\label{combine-columns}}

Combining columns may be thought of as setting rectangular data structures next to each other.

\hypertarget{python-31}{%
\subsubsection*{Python}\label{python-31}}
\addcontentsline{toc}{subsubsection}{Python}

The \texttt{concat} function also ``binds'' columns. It takes two or more objects. The second argument \texttt{axis} specifies a row bind when 0 and a column bind when 1. The default value is 0. To column bind data frames, the number of rows must match; otherwise, the function throws an error.

\begin{Shaded}
\begin{Highlighting}[]

\NormalTok{d1 }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{:[}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{], }\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{:[}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{]\})}
\NormalTok{d2 }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}z\textquotesingle{}}\NormalTok{:[}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{], }\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{:[}\StringTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}e\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}f\textquotesingle{}}\NormalTok{]\})}

\CommentTok{\# create list of DataFrame objects}
\NormalTok{frames }\OperatorTok{=}\NormalTok{ [d1, d2]}
\NormalTok{combined\_df }\OperatorTok{=}\NormalTok{ pd.concat(frames, axis}\OperatorTok{=}\DecValTok{1}\NormalTok{)}

\NormalTok{combined\_df}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    x  y  z  a
## 0  4  a  3  d
## 1  5  b  2  e
## 2  6  c  1  f
\end{verbatim}

\hypertarget{r-31}{%
\subsubsection*{R}\label{r-31}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{cbind()} function ``binds'' columns. It takes two or more objects. To column bind data frames, the number of rows must match; otherwise, the object with fewer rows will have rows ``recycled'' (if possible) or an error will be returned.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d1 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =} \DecValTok{10}\SpecialCharTok{:}\DecValTok{13}\NormalTok{, }\AttributeTok{y =}\NormalTok{ letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{])}
\NormalTok{d2 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\DecValTok{23}\NormalTok{,}\DecValTok{34}\NormalTok{,}\DecValTok{45}\NormalTok{,}\DecValTok{44}\NormalTok{))}
\FunctionTok{cbind}\NormalTok{(d1, d2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    x y  x
## 1 10 a 23
## 2 11 b 34
## 3 12 c 45
## 4 13 d 44
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# example of recycled rows (d1 is repeated twice)}
\NormalTok{d1 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =} \DecValTok{10}\SpecialCharTok{:}\DecValTok{13}\NormalTok{, }\AttributeTok{y =}\NormalTok{ letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{])}
\NormalTok{d2 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\DecValTok{23}\NormalTok{,}\DecValTok{34}\NormalTok{,}\DecValTok{45}\NormalTok{,}\DecValTok{44}\NormalTok{,}\DecValTok{99}\NormalTok{,}\DecValTok{99}\NormalTok{,}\DecValTok{99}\NormalTok{,}\DecValTok{99}\NormalTok{))}
\FunctionTok{cbind}\NormalTok{(d1, d2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    x y  x
## 1 10 a 23
## 2 11 b 34
## 3 12 c 45
## 4 13 d 44
## 5 10 a 99
## 6 11 b 99
## 7 12 c 99
## 8 13 d 99
\end{verbatim}

See also the \texttt{bind\_cols()} function in the \textbf{dplyr} package.

\hypertarget{reshaping-data}{%
\section{Reshaping data}\label{reshaping-data}}

The next two sections discuss how to reshape data from wide to long and from long to wide. ``Wide'' data are structured such that multiple values associated with a given unit (e.g., a person, a cell culture, etc.) are placed in the same row:

\begin{verbatim}
##    name time_1_score time_2_score
## 1 larry            3            0
## 2   moe            6            3
## 3 curly            2            1
\end{verbatim}

\emph{Long} data, conversely, are structured such that all values are contained in one column, with another column identifying what value is given in any particular row (``time 1,'' ``time 2,'' etc.):

\begin{verbatim}
##      id time score
## 1 larry    1     3
## 2 larry    2     0
## 3   moe    1     6
## 4   moe    2     3
## 5 curly    1     2
## 6 curly    2     1
\end{verbatim}

Shifting between these two data formats is often necessary for implementing certain statistical techniques or representing data with particular visualizations.

\hypertarget{wide-to-long}{%
\subsection{Wide to long}\label{wide-to-long}}

\hypertarget{python-32}{%
\subsubsection*{Python}\label{python-32}}
\addcontentsline{toc}{subsubsection}{Python}

To reshape a DataFrame from wide to long, we can use the pandas \texttt{melt()} function.

The following is an example of a wide DataFrame.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}

\NormalTok{data }\OperatorTok{=}\NormalTok{ \{}\StringTok{"id"}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{],}
        \StringTok{"wk1"}\NormalTok{: np.random.choice(}\BuiltInTok{range}\NormalTok{(}\DecValTok{20}\NormalTok{), }\DecValTok{3}\NormalTok{),}
        \StringTok{"wk2"}\NormalTok{: np.random.choice(}\BuiltInTok{range}\NormalTok{(}\DecValTok{20}\NormalTok{), }\DecValTok{3}\NormalTok{),}
        \StringTok{"wk3"}\NormalTok{: np.random.choice(}\BuiltInTok{range}\NormalTok{(}\DecValTok{20}\NormalTok{), }\DecValTok{3}\NormalTok{)\}}

\NormalTok{df\_wide }\OperatorTok{=}\NormalTok{ pd.DataFrame(data)}
\BuiltInTok{print}\NormalTok{(df\_wide)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    id  wk1  wk2  wk3
## 0   1    2   19    0
## 1   2    6   10   17
## 2   3   17    1   15
\end{verbatim}

The following code uses the pandas \texttt{melt()} function to reshape the DataFrame from wide to long.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dataL }\OperatorTok{=}\NormalTok{ pd.melt(df\_wide,}

                \CommentTok{\# column(s) that uniquely identifies/y each row}
\NormalTok{                id\_vars }\OperatorTok{=}\NormalTok{ [}\StringTok{"id"}\NormalTok{],}
                
                \CommentTok{\# variables that contain the values to be lengthened}
\NormalTok{                value\_vars }\OperatorTok{=}\NormalTok{ [}\StringTok{"wk1"}\NormalTok{, }\StringTok{"wk2"}\NormalTok{, }\StringTok{"wk3"}\NormalTok{],}
                
                \CommentTok{\# desired name of column in long data that will contain values}
\NormalTok{                value\_name }\OperatorTok{=} \StringTok{"observations"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(dataL)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    id variable  observations
## 0   1      wk1             2
## 1   2      wk1             6
## 2   3      wk1            17
## 3   1      wk2            19
## 4   2      wk2            10
## 5   3      wk2             1
## 6   1      wk3             0
## 7   2      wk3            17
## 8   3      wk3            15
\end{verbatim}

\hypertarget{r-32}{%
\subsubsection*{R}\label{r-32}}
\addcontentsline{toc}{subsubsection}{R}

In base R, the \texttt{reshape()} function can take data from wide to long or long to wide. The \textbf{tidyverse} also provides reshaping functions: \texttt{pivot\_longer()} and \texttt{pivot\_wider()}. The \textbf{tidyverse} functions have a degree of intuitiveness and usability that may make them the go-to reshaping tools for many R users. We give examples below using both base R and \textbf{tidyverse}.

Say we begin with a wide data frame, \texttt{df\_wide}, that looks like this:

\begin{verbatim}
##   id sex wk1 wk2 wk3
## 1  1   m  16   7  15
## 2  2   m  12  19  10
## 3  3   f   8  15   7
\end{verbatim}

To lengthen a data frame using \texttt{reshape()}, a user provides arguments specifying the columns that identify values' origins (person, cell culture, etc.), the columns containing values to be lengthened, and the desired names for new columns in long data:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_long }\OtherTok{\textless{}{-}} \FunctionTok{reshape}\NormalTok{(df\_wide,}
                   \AttributeTok{direction =} \StringTok{\textquotesingle{}long\textquotesingle{}}\NormalTok{,}
                   
                   \CommentTok{\# column(s) that uniquely identifies/y each row}
                   \AttributeTok{idvar =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}id\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}sex\textquotesingle{}}\NormalTok{), }
                   
                   \CommentTok{\# variables that contain the values to be lengthened}
                   \AttributeTok{varying =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}wk1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}wk2\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}wk3\textquotesingle{}}\NormalTok{), }
                   
                   \CommentTok{\# desired name of column in long data that will contain values}
                   \AttributeTok{v.names =} \StringTok{\textquotesingle{}val\textquotesingle{}}\NormalTok{, }
                   
                   \CommentTok{\# desired name of column in long data that will }
                   \CommentTok{\# identify each value\textquotesingle{}s context}
                   \AttributeTok{timevar =} \StringTok{\textquotesingle{}week\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_long}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       id sex week val
## 1.m.1  1   m    1  16
## 2.m.1  2   m    1  12
## 3.f.1  3   f    1   8
## 1.m.2  1   m    2   7
## 2.m.2  2   m    2  19
## 3.f.2  3   f    2  15
## 1.m.3  1   m    3  15
## 2.m.3  2   m    3  10
## 3.f.3  3   f    3   7
\end{verbatim}

The \textbf{tidyverse} function for taking data from wide to long is \texttt{pivot\_longer()}. To lengthen \texttt{df\_wide} using \texttt{pivot\_longer()}, a user would write:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\NormalTok{df\_long\_PL }\OtherTok{\textless{}{-}} \FunctionTok{pivot\_longer}\NormalTok{(df\_wide,}
                           
                           \CommentTok{\# columns that contain the }
                           \CommentTok{\# values to be lengthened }
                           \CommentTok{\# (can use {-}c() to negate variables)}
                           \AttributeTok{cols =} \SpecialCharTok{{-}}\FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}id\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}sex\textquotesingle{}}\NormalTok{), }
                           
                           \CommentTok{\# desired name of column in long data }
                           \CommentTok{\# that will identify each value\textquotesingle{}s context}
                           \AttributeTok{names\_to =} \StringTok{\textquotesingle{}week\textquotesingle{}}\NormalTok{,}
                           
                           \CommentTok{\# desired name of column in long data }
                           \CommentTok{\# that will contain values}
                           \AttributeTok{values\_to =} \StringTok{\textquotesingle{}val\textquotesingle{}}\NormalTok{) }
\NormalTok{df\_long\_PL}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 9 x 4
##      id sex   week    val
##   <int> <chr> <chr> <int>
## 1     1 m     wk1      16
## 2     1 m     wk2       7
## 3     1 m     wk3      15
## 4     2 m     wk1      12
## 5     2 m     wk2      19
## 6     2 m     wk3      10
## 7     3 f     wk1       8
## 8     3 f     wk2      15
## 9     3 f     wk3       7
\end{verbatim}

\texttt{pivot\_longer()} is particularly useful (a) when dealing with wide data that contain multiple sets of repeated measures in each row that need to be lengthened separately (e.g., two monthly height measurements and two monthly weight measurements for each person) and (b) when column names and/or column values in the long data need to be extracted from column names of the wide data using regular expressions.

For example, say we begin with a wide data frame, \texttt{animals\_wide}, in which every row contains two values for each of two different measures:

\begin{verbatim}
##      animal lives_in_water jan_playfulness feb_playfulness jan_excitement
## 1   dolphin           TRUE             6.0             5.5            7.0
## 2 porcupine          FALSE             3.5             4.5            3.5
## 3  capybara          FALSE             4.0             5.0            4.0
##   feb_excitement
## 1            7.0
## 2            3.5
## 3            4.0
\end{verbatim}

\texttt{pivot\_longer()} can be used to convert this data frame to a long format where there is one column for each of the measures, playfulness and excitement:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{animals\_long\_1 }\OtherTok{\textless{}{-}} \FunctionTok{pivot\_longer}\NormalTok{(animals\_wide,}
                             \AttributeTok{cols =} \SpecialCharTok{{-}}\FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}animal\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}lives\_in\_water\textquotesingle{}}\NormalTok{),}
                             
                             \CommentTok{\# ".value" is placeholder for strings }
                             \CommentTok{\# that will be extracted from wide column names }
                             \AttributeTok{names\_to =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}.value\textquotesingle{}}\NormalTok{),}
                             
                             \CommentTok{\# specify structure of wide column names }
                             \CommentTok{\# with regex from which long column names }
                             \CommentTok{\# will be extracted}
                             \AttributeTok{names\_pattern =} \StringTok{\textquotesingle{}(.+)\_(.+)\textquotesingle{}}\NormalTok{) }
\NormalTok{animals\_long\_1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 5
##   animal    lives_in_water month playfulness excitement
##   <chr>     <lgl>          <chr>       <dbl>      <dbl>
## 1 dolphin   TRUE           jan           6          7  
## 2 dolphin   TRUE           feb           5.5        7  
## 3 porcupine FALSE          jan           3.5        3.5
## 4 porcupine FALSE          feb           4.5        3.5
## 5 capybara  FALSE          jan           4          4  
## 6 capybara  FALSE          feb           5          4
\end{verbatim}

Alternatively, \texttt{pivot\_longer()} can be used to convert this data frame to a long format where there is one column containing all the playfulness and excitement values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{animals\_long\_2 }\OtherTok{\textless{}{-}} \FunctionTok{pivot\_longer}\NormalTok{(animals\_wide,}
                               \AttributeTok{cols =} \SpecialCharTok{{-}}\FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}animal\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}lives\_in\_water\textquotesingle{}}\NormalTok{),}
                               \AttributeTok{names\_to =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}measure\textquotesingle{}}\NormalTok{),}
                               \AttributeTok{names\_pattern =} \StringTok{\textquotesingle{}(.+)\_(.+)\textquotesingle{}}\NormalTok{,}
                               \AttributeTok{values\_to =} \StringTok{\textquotesingle{}val\textquotesingle{}}\NormalTok{)}
\NormalTok{animals\_long\_2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 5
##    animal    lives_in_water month measure       val
##    <chr>     <lgl>          <chr> <chr>       <dbl>
##  1 dolphin   TRUE           jan   playfulness   6  
##  2 dolphin   TRUE           feb   playfulness   5.5
##  3 dolphin   TRUE           jan   excitement    7  
##  4 dolphin   TRUE           feb   excitement    7  
##  5 porcupine FALSE          jan   playfulness   3.5
##  6 porcupine FALSE          feb   playfulness   4.5
##  7 porcupine FALSE          jan   excitement    3.5
##  8 porcupine FALSE          feb   excitement    3.5
##  9 capybara  FALSE          jan   playfulness   4  
## 10 capybara  FALSE          feb   playfulness   5  
## 11 capybara  FALSE          jan   excitement    4  
## 12 capybara  FALSE          feb   excitement    4
\end{verbatim}

\hypertarget{long-to-wide}{%
\subsection{Long to wide}\label{long-to-wide}}

\hypertarget{python-33}{%
\subsubsection*{Python}\label{python-33}}
\addcontentsline{toc}{subsubsection}{Python}

To reshape a DataFrame from long to wide, we can use the pandas \texttt{pivot\_table()} function.

The following is an example of a long DataFrame.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}

\NormalTok{data }\OperatorTok{=}\NormalTok{ \{}\StringTok{"id"}\NormalTok{: np.concatenate([([i]}\OperatorTok{*}\DecValTok{3}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{]], axis}\OperatorTok{=}\DecValTok{0}\NormalTok{),}
        \StringTok{"week"}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{] }\OperatorTok{*} \DecValTok{3}\NormalTok{,}
        \StringTok{"observations"}\NormalTok{: np.random.choice(}\BuiltInTok{range}\NormalTok{(}\DecValTok{20}\NormalTok{), }\DecValTok{9}\NormalTok{)\}}

\NormalTok{df\_long }\OperatorTok{=}\NormalTok{ pd.DataFrame(data)}
\BuiltInTok{print}\NormalTok{(df\_long)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    id  week  observations
## 0   1     1             9
## 1   1     2             0
## 2   1     3            14
## 3   2     1             0
## 4   2     2            15
## 5   2     3            19
## 6   3     1            14
## 7   3     2             4
## 8   3     3             0
\end{verbatim}

The following code uses the pandas \texttt{pivot\_table()} function to reshape the DataFrame from long to wide.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_wide }\OperatorTok{=}\NormalTok{ pd.pivot\_table(df\_long,}
\NormalTok{          index}\OperatorTok{=}\StringTok{\textquotesingle{}id\textquotesingle{}}\NormalTok{,}
\NormalTok{          columns}\OperatorTok{=}\StringTok{\textquotesingle{}week\textquotesingle{}}\NormalTok{,}
\NormalTok{          values}\OperatorTok{=}\StringTok{\textquotesingle{}observations\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(df\_wide)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## week   1   2   3
## id              
## 1      9   0  14
## 2      0  15  19
## 3     14   4   0
\end{verbatim}

\hypertarget{r-33}{%
\subsubsection*{R}\label{r-33}}
\addcontentsline{toc}{subsubsection}{R}

Say we begin with a long data frame, \texttt{df\_long}, that looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_long}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       id sex week val
## 1.m.1  1   m    1  16
## 2.m.1  2   m    1  12
## 3.f.1  3   f    1   8
## 1.m.2  1   m    2   7
## 2.m.2  2   m    2  19
## 3.f.2  3   f    2  15
## 1.m.3  1   m    3  15
## 2.m.3  2   m    3  10
## 3.f.3  3   f    3   7
\end{verbatim}

To take data from long to wide with base R's \texttt{reshape()}, a user would write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_wide }\OtherTok{\textless{}{-}} \FunctionTok{reshape}\NormalTok{(df\_long,}
                   \AttributeTok{direction =} \StringTok{\textquotesingle{}wide\textquotesingle{}}\NormalTok{,}
                   \AttributeTok{idvar =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}id\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}sex\textquotesingle{}}\NormalTok{), }\CommentTok{\# column(s) that determine which rows should be grouped together in the wide data}
                   \AttributeTok{v.names =} \StringTok{\textquotesingle{}val\textquotesingle{}}\NormalTok{, }\CommentTok{\# column containing values to widen}
                   \AttributeTok{timevar =} \StringTok{\textquotesingle{}week\textquotesingle{}}\NormalTok{, }\CommentTok{\# column from which resulting wide column names are pulled}
                   \AttributeTok{sep =} \StringTok{\textquotesingle{}\_\textquotesingle{}}\NormalTok{) }\CommentTok{\# the \textasciigrave{}sep\textasciigrave{} argument allows a user to specify how the contents of \textasciigrave{}timevar\textasciigrave{} should be joined with the name of the \textasciigrave{}v.names\textasciigrave{} variable to form wide column names}
\NormalTok{df\_wide}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       id sex val_1 val_2 val_3
## 1.m.1  1   m    16     7    15
## 2.m.1  2   m    12    19    10
## 3.f.1  3   f     8    15     7
\end{verbatim}

The \textbf{tidyverse} function for taking data from long to wide is \texttt{pivot\_wider()}. To widen \texttt{df\_long} using \texttt{pivot\_longer()}, a user would write:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\NormalTok{df\_wide\_PW }\OtherTok{\textless{}{-}} \FunctionTok{pivot\_wider}\NormalTok{(df\_long,}
                          \AttributeTok{id\_cols =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}id\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}sex\textquotesingle{}}\NormalTok{),}
                          \AttributeTok{values\_from =} \StringTok{\textquotesingle{}val\textquotesingle{}}\NormalTok{,}
                          \AttributeTok{names\_from =} \StringTok{\textquotesingle{}week\textquotesingle{}}\NormalTok{,}
                          \AttributeTok{names\_prefix =} \StringTok{\textquotesingle{}week\_\textquotesingle{}}\NormalTok{) }\CommentTok{\# \textasciigrave{}names\_prefix\textasciigrave{} specifies a string to paste in front of the contents of \textquotesingle{}week\textquotesingle{} in the resulting wide column names}
\NormalTok{df\_wide\_PW}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 5
##      id sex   week_1 week_2 week_3
##   <int> <chr>  <int>  <int>  <int>
## 1     1 m         16      7     15
## 2     2 m         12     19     10
## 3     3 f          8     15      7
\end{verbatim}

\texttt{pivot\_wider()} offers a lot of usability when widening relatively complicated long data structures. For example, say we want to widen both of the long versions of the animals data frame created above.

To widen the version of the long data that has a column for each of the measures (playfulness and excitement):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{animals\_long\_1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 5
##   animal    lives_in_water month playfulness excitement
##   <chr>     <lgl>          <chr>       <dbl>      <dbl>
## 1 dolphin   TRUE           jan           6          7  
## 2 dolphin   TRUE           feb           5.5        7  
## 3 porcupine FALSE          jan           3.5        3.5
## 4 porcupine FALSE          feb           4.5        3.5
## 5 capybara  FALSE          jan           4          4  
## 6 capybara  FALSE          feb           5          4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{animals\_wide }\OtherTok{\textless{}{-}} \FunctionTok{pivot\_wider}\NormalTok{(animals\_long\_1,}
                            \AttributeTok{id\_cols =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}animal\textquotesingle{}}\NormalTok{, }
                                        \StringTok{\textquotesingle{}lives\_in\_water\textquotesingle{}}\NormalTok{),}
                            \AttributeTok{values\_from =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}playfulness\textquotesingle{}}\NormalTok{,}
                                            \StringTok{\textquotesingle{}excitement\textquotesingle{}}\NormalTok{),}
                            \AttributeTok{names\_from =} \StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{,}
                            \AttributeTok{names\_glue =} \StringTok{\textquotesingle{}\{month\}\_\{.value\}\textquotesingle{}}\NormalTok{) }
                            \CommentTok{\# \textasciigrave{}names\_glue\textasciigrave{} allows for customization }
                            \CommentTok{\# of column names using "glue";}
                            \CommentTok{\# see https://glue.tidyverse.org/}
\NormalTok{animals\_wide}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 6
##   animal    lives_in_water jan_playfulness feb_playfulness jan_excitement
##   <chr>     <lgl>                    <dbl>           <dbl>          <dbl>
## 1 dolphin   TRUE                       6               5.5            7  
## 2 porcupine FALSE                      3.5             4.5            3.5
## 3 capybara  FALSE                      4               5              4  
## # ... with 1 more variable: feb_excitement <dbl>
\end{verbatim}

To widen the version of the long data that has one column containing all the values of playfulness and excitement together:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{animals\_long\_2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 5
##    animal    lives_in_water month measure       val
##    <chr>     <lgl>          <chr> <chr>       <dbl>
##  1 dolphin   TRUE           jan   playfulness   6  
##  2 dolphin   TRUE           feb   playfulness   5.5
##  3 dolphin   TRUE           jan   excitement    7  
##  4 dolphin   TRUE           feb   excitement    7  
##  5 porcupine FALSE          jan   playfulness   3.5
##  6 porcupine FALSE          feb   playfulness   4.5
##  7 porcupine FALSE          jan   excitement    3.5
##  8 porcupine FALSE          feb   excitement    3.5
##  9 capybara  FALSE          jan   playfulness   4  
## 10 capybara  FALSE          feb   playfulness   5  
## 11 capybara  FALSE          jan   excitement    4  
## 12 capybara  FALSE          feb   excitement    4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{animals\_wide }\OtherTok{\textless{}{-}} \FunctionTok{pivot\_wider}\NormalTok{(animals\_long\_2,}
                            \AttributeTok{id\_cols =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}animal\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}lives\_in\_water\textquotesingle{}}\NormalTok{),}
                            \AttributeTok{values\_from =} \StringTok{\textquotesingle{}val\textquotesingle{}}\NormalTok{,}
                            \AttributeTok{names\_from =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}measure\textquotesingle{}}\NormalTok{),}
                            \AttributeTok{names\_sep =} \StringTok{\textquotesingle{}\_\textquotesingle{}}\NormalTok{)}
\NormalTok{animals\_wide}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 6
##   animal    lives_in_water jan_playfulness feb_playfulness jan_excitement
##   <chr>     <lgl>                    <dbl>           <dbl>          <dbl>
## 1 dolphin   TRUE                       6               5.5            7  
## 2 porcupine FALSE                      3.5             4.5            3.5
## 3 capybara  FALSE                      4               5              4  
## # ... with 1 more variable: feb_excitement <dbl>
\end{verbatim}

\hypertarget{mergejoin}{%
\section{Merge/Join}\label{mergejoin}}

The merge/join examples below all make use of the following sample data frames:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   merge_var val_x
## 1         a    12
## 2         b    94
## 3         c    92
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   merge_var val_y
## 1         c    78
## 2         d    32
## 3         e    30
\end{verbatim}

\hypertarget{left-join}{%
\subsection{Left Join}\label{left-join}}

A left join of \emph{x} and \emph{y} keeps all rows of \emph{x} and merges rows of \emph{y} into \emph{x} where possible based on the merge criterion:

\includegraphics[width=17.25in]{images/left_join}

\hypertarget{python-34}{%
\subsubsection*{Python}\label{python-34}}
\addcontentsline{toc}{subsubsection}{Python}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\NormalTok{pd.merge(x, y, how }\OperatorTok{=} \StringTok{\textquotesingle{}left\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   merge_var  val_x  val_y
## 0         a   12.0    NaN
## 1         b   94.0    NaN
## 2         c   92.0   78.0
\end{verbatim}

\hypertarget{r-34}{%
\subsubsection*{R}\label{r-34}}
\addcontentsline{toc}{subsubsection}{R}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# all.x = T results in a left join}
\FunctionTok{merge}\NormalTok{(x, y, }\AttributeTok{by =} \StringTok{\textquotesingle{}merge\_var\textquotesingle{}}\NormalTok{, }\AttributeTok{all.x =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   merge_var val_x val_y
## 1         a    12    NA
## 2         b    94    NA
## 3         c    92    78
\end{verbatim}

\hypertarget{right-join}{%
\subsection{Right Join}\label{right-join}}

A right join of \emph{x} and \emph{y} keeps all rows of \emph{y} and merges rows of \emph{x} into \emph{y} wherever possible based on the merge criterion:

\includegraphics[width=17.25in]{images/right_join}

\hypertarget{python-35}{%
\subsubsection*{Python}\label{python-35}}
\addcontentsline{toc}{subsubsection}{Python}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\NormalTok{pd.merge(x, y, how }\OperatorTok{=} \StringTok{\textquotesingle{}right\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   merge_var  val_x  val_y
## 0         c   92.0   78.0
## 1         d    NaN   32.0
## 2         e    NaN   30.0
\end{verbatim}

\hypertarget{r-35}{%
\subsubsection*{R}\label{r-35}}
\addcontentsline{toc}{subsubsection}{R}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# all.y = T results in a right join}
\FunctionTok{merge}\NormalTok{(x, y, }\AttributeTok{by =} \StringTok{\textquotesingle{}merge\_var\textquotesingle{}}\NormalTok{, }\AttributeTok{all.y =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   merge_var val_x val_y
## 1         c    92    78
## 2         d    NA    32
## 3         e    NA    30
\end{verbatim}

\hypertarget{inner-join}{%
\subsection{Inner Join}\label{inner-join}}

An inner join of \emph{x} and \emph{y} returns merged rows for which a match can be found on the merge criterion \emph{in both tables}:

\includegraphics[width=17.25in]{images/inner_join}

\hypertarget{python-36}{%
\subsubsection*{Python}\label{python-36}}
\addcontentsline{toc}{subsubsection}{Python}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\NormalTok{pd.merge(x, y, how }\OperatorTok{=} \StringTok{\textquotesingle{}inner\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   merge_var  val_x  val_y
## 0         c   92.0   78.0
\end{verbatim}

\hypertarget{r-36}{%
\subsubsection*{R}\label{r-36}}
\addcontentsline{toc}{subsubsection}{R}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# with its default arguments, merge() executes an inner join}
\CommentTok{\# (more specifically, a natural join, which is a kind of}
\CommentTok{\# inner join in which the merge{-}criterion column is not}
\CommentTok{\# repeated, despite being initially present in both tables)}
\FunctionTok{merge}\NormalTok{(x, y, }\AttributeTok{by =} \StringTok{\textquotesingle{}merge\_var\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   merge_var val_x val_y
## 1         c    92    78
\end{verbatim}

\hypertarget{outer-join}{%
\subsection{Outer Join}\label{outer-join}}

An outer join of \emph{x} and \emph{y} keeps all rows from both tables, merging rows wherever possible based on the merge criterion:

\includegraphics[width=17.25in]{images/outer_join}

\hypertarget{python-37}{%
\subsubsection*{Python}\label{python-37}}
\addcontentsline{toc}{subsubsection}{Python}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\NormalTok{pd.merge(x, y, how }\OperatorTok{=} \StringTok{\textquotesingle{}outer\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   merge_var  val_x  val_y
## 0         a   12.0    NaN
## 1         b   94.0    NaN
## 2         c   92.0   78.0
## 3         d    NaN   32.0
## 4         e    NaN   30.0
\end{verbatim}

\hypertarget{r-37}{%
\subsubsection*{R}\label{r-37}}
\addcontentsline{toc}{subsubsection}{R}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# all = T (or all.x = T AND all.y = T) results in an outer join}
\FunctionTok{merge}\NormalTok{(x, y, }\AttributeTok{by =} \StringTok{\textquotesingle{}merge\_var\textquotesingle{}}\NormalTok{, }\AttributeTok{all =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   merge_var val_x val_y
## 1         a    12    NA
## 2         b    94    NA
## 3         c    92    78
## 4         d    NA    32
## 5         e    NA    30
\end{verbatim}

\hypertarget{aggregation-and-group-operations}{%
\chapter{Aggregation and Group Operations}\label{aggregation-and-group-operations}}

This chapter looks at manipulating and summarizing data by groups.

\hypertarget{cross-tabulation}{%
\section{Cross tabulation}\label{cross-tabulation}}

Cross tabulation is the process of determining frequencies per group (or determining values based on frequencies, like proportions), with groups delineated by one or more variables (e.g., nationality and sex).

The Python and R examples of cross tabulation below both make use of the following dataset, \texttt{dat}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   nationality sex
## 1    Canadian   m
## 2      French   f
## 3      French   f
## 4    Egyptian   m
## 5    Canadian   f
\end{verbatim}

\hypertarget{python-38}{%
\subsubsection*{Python}\label{python-38}}
\addcontentsline{toc}{subsubsection}{Python}

The \textbf{pandas} package contains a \texttt{crosstab()} function for cross tabulation with two or more variables. Alternatively, the \texttt{groupby()} function, also in \textbf{pandas}, facilitates cross tabulation by one or more variables when used in combination with \texttt{count()}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\NormalTok{pd.crosstab(dat.nationality, dat.sex)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## sex          f  m
## nationality      
## Canadian     1  1
## Egyptian     0  1
## French       2  0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat.groupby(by }\OperatorTok{=} \StringTok{\textquotesingle{}nationality\textquotesingle{}}\NormalTok{).nationality.count()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## nationality
## Canadian    2
## Egyptian    1
## French      2
## Name: nationality, dtype: int64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}nationality\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}sex\textquotesingle{}}\NormalTok{]).nationality.count()}
\CommentTok{\# Or: dat.groupby(by = [\textquotesingle{}nationality\textquotesingle{}, \textquotesingle{}sex\textquotesingle{}]).sex.count()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## nationality  sex
## Canadian     f      1
##              m      1
## Egyptian     m      1
## French       f      2
## Name: nationality, dtype: int64
\end{verbatim}

\hypertarget{r-38}{%
\subsubsection*{R}\label{r-38}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{table()} function performs cross tabulation in R. A user can enter a single grouping variable or enter multiple grouping variables separated by a comma(s). The \texttt{xtabs()} function also computes cross-tabs; a user enters the variables to be used for grouping in formula notation.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{table}\NormalTok{(dat}\SpecialCharTok{$}\NormalTok{nationality)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Canadian Egyptian   French 
##        2        1        2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{table}\NormalTok{(dat}\SpecialCharTok{$}\NormalTok{nationality, dat}\SpecialCharTok{$}\NormalTok{sex)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           
##            f m
##   Canadian 1 1
##   Egyptian 0 1
##   French   2 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{xtabs}\NormalTok{(}\AttributeTok{formula =} \SpecialCharTok{\textasciitilde{}}\NormalTok{nationality }\SpecialCharTok{+}\NormalTok{ sex, }\AttributeTok{data =}\NormalTok{ dat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##            sex
## nationality f m
##    Canadian 1 1
##    Egyptian 0 1
##    French   2 0
\end{verbatim}

\hypertarget{group-summaries}{%
\section{Group summaries}\label{group-summaries}}

Computing statistical summaries per group.

\hypertarget{python-39}{%
\subsubsection*{Python}\label{python-39}}
\addcontentsline{toc}{subsubsection}{Python}

The \texttt{groupby()} function from \textbf{Pandas} splits up a data set based on one or more grouping variables. Summarizing functions---like \texttt{mean()}, \texttt{sum()}, and so on---can then be applied to those groups. In the first example below, we use \texttt{groupby()} to group rows of the \texttt{mtcars} dataset by the number of cylinders each car has; from there, we select just the \texttt{mpg} column and call \texttt{mean()}, thus producing the average miles per gallon within each cylinder group. In the second example, we again group observations by \texttt{cyl}, but instead of then selecting just the \texttt{mpg} column, we directly call \texttt{mean()}; this gives the mean for each variable in the data set within each cylinder group. Finally, in the third example, we group by two variables---\texttt{cyl} and \texttt{vs}---and then use the \texttt{describe()} function to generate a set of descriptive statistics for \texttt{mpg} within each \texttt{cylinder}*\texttt{vs} group (e.g., mean, SD, minimum, etc.).

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}

\NormalTok{mean\_mpg\_by\_cyl }\OperatorTok{=}\NormalTok{ mtcars.groupby(by }\OperatorTok{=} \StringTok{\textquotesingle{}cyl\textquotesingle{}}\NormalTok{)[}\StringTok{\textquotesingle{}mpg\textquotesingle{}}\NormalTok{].mean()}
\BuiltInTok{print}\NormalTok{(mean\_mpg\_by\_cyl)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## cyl
## 4.0    26.663636
## 6.0    19.742857
## 8.0    15.100000
## Name: mpg, dtype: float64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{means\_all\_vars }\OperatorTok{=}\NormalTok{ mtcars.groupby(by }\OperatorTok{=} \StringTok{\textquotesingle{}cyl\textquotesingle{}}\NormalTok{).mean()}
\BuiltInTok{print}\NormalTok{(means\_all\_vars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##            mpg        disp          hp  ...        am      gear      carb
## cyl                                     ...                              
## 4.0  26.663636  105.136364   82.636364  ...  0.727273  4.090909  1.545455
## 6.0  19.742857  183.314286  122.285714  ...  0.428571  3.857143  3.428571
## 8.0  15.100000  353.100000  209.214286  ...  0.142857  3.285714  3.500000
## 
## [3 rows x 10 columns]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mpg\_by\_cyl\_vs }\OperatorTok{=}\NormalTok{ mtcars.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}cyl\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}vs\textquotesingle{}}\NormalTok{])[}\StringTok{\textquotesingle{}mpg\textquotesingle{}}\NormalTok{].describe()}
\BuiltInTok{print}\NormalTok{(mpg\_by\_cyl\_vs)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          count       mean       std   min     25%    50%    75%   max
## cyl vs                                                               
## 4.0 0.0    1.0  26.000000       NaN  26.0  26.000  26.00  26.00  26.0
##     1.0   10.0  26.730000  4.748111  21.4  22.800  25.85  30.40  33.9
## 6.0 0.0    3.0  20.566667  0.750555  19.7  20.350  21.00  21.00  21.0
##     1.0    4.0  19.125000  1.631717  17.8  18.025  18.65  19.75  21.4
## 8.0 0.0   14.0  15.100000  2.560048  10.4  14.400  15.20  16.25  19.2
\end{verbatim}

\hypertarget{r-39}{%
\subsubsection*{R}\label{r-39}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{aggregate()} function can be used to generate by-group statistical summaries based on one or more grouping variables. Grouping variables can be declared as a list in the function's \texttt{by} argument. Alternatively, the grouping variable(s) and the variable to be summarized can be passed to \texttt{aggregate()} in formula notation: \texttt{var\_to\_be\_aggregated\ \textasciitilde{}\ grouping\_var\_1\ +\ ...\ +\ grouping\_var\_N}. The summarizing function (e.g., \texttt{mean()}; \texttt{median()}; etc.) is declared in the \texttt{FUN} argument.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# One grouping variable}
\CommentTok{\# Calculating mean of \textasciigrave{}mpg\textasciigrave{} in each \textasciigrave{}cyl\textasciigrave{} group}
\FunctionTok{aggregate}\NormalTok{(}\AttributeTok{x =}\NormalTok{ mtcars}\SpecialCharTok{$}\NormalTok{mpg, }
          \AttributeTok{by =} \FunctionTok{list}\NormalTok{(}\AttributeTok{cyl =}\NormalTok{ mtcars}\SpecialCharTok{$}\NormalTok{cyl), }
          \AttributeTok{FUN =} \StringTok{"mean"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   cyl        x
## 1   4 26.66364
## 2   6 19.74286
## 3   8 15.10000
\end{verbatim}

Adding \texttt{drop=FALSE} ensures all combinations of levels are returned even if no data exist at that combination. Below the final row is \texttt{NA} since there are no 8-cylinder cars with a ``straight'' engine (vs = 1).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Two or more grouping variables}
\CommentTok{\# Calculating max of \textasciigrave{}mpg\textasciigrave{} in each \textasciigrave{}cyl\textasciigrave{}*\textasciigrave{}vs\textasciigrave{} group}
\FunctionTok{aggregate}\NormalTok{(}\AttributeTok{x =}\NormalTok{ mtcars}\SpecialCharTok{$}\NormalTok{mpg, }
          \AttributeTok{by =} \FunctionTok{list}\NormalTok{(}\AttributeTok{cyl =}\NormalTok{ mtcars}\SpecialCharTok{$}\NormalTok{cyl, }\AttributeTok{vs =}\NormalTok{ mtcars}\SpecialCharTok{$}\NormalTok{vs), }
          \AttributeTok{FUN =} \StringTok{"max"}\NormalTok{, }\AttributeTok{drop =} \ConstantTok{FALSE}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   cyl vs    x
## 1   4  0 26.0
## 2   6  0 21.0
## 3   8  0 19.2
## 4   4  1 33.9
## 5   6  1 21.4
## 6   8  1   NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Or, specify the variable to summarize and the grouping variables in formula notation}
\FunctionTok{aggregate}\NormalTok{(mpg }\SpecialCharTok{\textasciitilde{}}\NormalTok{ cyl }\SpecialCharTok{+}\NormalTok{ vs, }\AttributeTok{data =}\NormalTok{ mtcars, }\AttributeTok{FUN =}\NormalTok{ max)}
\end{Highlighting}
\end{Shaded}

The \textbf{tidyverse} also offers a summarizing function, \texttt{summarize()} (or \texttt{summarise()}, for the Britons), which is in the \textbf{dplyr} package. After grouping a data frame/tibble (with, e.g., \textbf{dplyr}'s \texttt{group\_by()} function), a user passes it to \texttt{summarize()}, specifying in the function call how the summary statistic should be calculated.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dplyr)}
\NormalTok{mtcars }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{group\_by}\NormalTok{(cyl, vs) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg\_mpg =} \FunctionTok{mean}\NormalTok{(mpg))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` has grouped output by 'cyl'. You can override using the `.groups`
## argument.
\end{verbatim}

\begin{verbatim}
## # A tibble: 5 x 3
## # Groups:   cyl [3]
##     cyl    vs avg_mpg
##   <dbl> <dbl>   <dbl>
## 1     4     0    26  
## 2     4     1    26.7
## 3     6     0    20.6
## 4     6     1    19.1
## 5     8     0    15.1
\end{verbatim}

\texttt{summarize()} makes it easy to specify relatively complicated summary calculations without needing to write an external function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{group\_by}\NormalTok{(cyl, vs) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg\_mpg =} \FunctionTok{mean}\NormalTok{(mpg),}
            \AttributeTok{complicated\_summary\_calculation =} 
              \FunctionTok{min}\NormalTok{(mpg)}\SpecialCharTok{\^{}}\FloatTok{0.5} \SpecialCharTok{*} 
              \FunctionTok{mean}\NormalTok{(wt)}\SpecialCharTok{\^{}}\FloatTok{0.5} \SpecialCharTok{+} 
              \FunctionTok{mean}\NormalTok{(disp)}\SpecialCharTok{\^{}}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\FunctionTok{mean}\NormalTok{(hp)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` has grouped output by 'cyl'. You can override using the `.groups`
## argument.
\end{verbatim}

\begin{verbatim}
## # A tibble: 5 x 4
## # Groups:   cyl [3]
##     cyl    vs avg_mpg complicated_summary_calculation
##   <dbl> <dbl>   <dbl>                           <dbl>
## 1     4     0    26                              8.51
## 2     4     1    26.7                            8.07
## 3     6     0    20.6                            8.41
## 4     6     1    19.1                            8.81
## 5     8     0    15.1                            7.48
\end{verbatim}

\hypertarget{centering-and-scaling}{%
\section{Centering and Scaling}\label{centering-and-scaling}}

\emph{Centering} refers to subtracting a constant, such as the mean, from every one of set of values. This is sometimes performed to aid interpretation of linear model coefficients.

\emph{Scaling} refers to rescaling a column or vector of values such that their mean is zero and their standard deviation is one. This is sometimes performed to put multiple variables on the same scale and is often recommended for procedures such as principal components analysis (PCA).

\hypertarget{python-40}{%
\subsubsection*{Python}\label{python-40}}
\addcontentsline{toc}{subsubsection}{Python}

The \texttt{scale()} function from the \textbf{preprocessing} module of the \textbf{scikit-learn} package provides one-step centering and scaling. To center a variable at zero without scaling it, use \texttt{scale()} with \texttt{with\_mean\ =\ True} and \texttt{with\_std\ =\ False} (both are \texttt{True} by default).

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ sklearn }\ImportTok{import}\NormalTok{ preprocessing}

\NormalTok{centered\_mpg }\OperatorTok{=}\NormalTok{ preprocessing.scale(mtcars.mpg, with\_mean }\OperatorTok{=} \VariableTok{True}\NormalTok{, with\_std }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{centered\_mpg.mean()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## -3.1086244689504383e-15
\end{verbatim}

To scale a variable after centering it (so that its mean is zero and its standard deviation is one), use \texttt{scale()} with \texttt{with\_mean\ =\ True} and \texttt{with\_std\ =\ True}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ sklearn }\ImportTok{import}\NormalTok{ preprocessing}

\NormalTok{scaled\_mpg }\OperatorTok{=}\NormalTok{ preprocessing.scale(mtcars.mpg, with\_mean }\OperatorTok{=} \VariableTok{True}\NormalTok{, with\_std }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{scaled\_mpg.mean()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## -4.996003610813204e-16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scaled\_mpg.std()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1.0
\end{verbatim}

\hypertarget{r-40}{%
\subsubsection*{R}\label{r-40}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{scale()} function can both center and scale variables.

To center a variable without scaling it, call \texttt{scale()} with the \texttt{center} argument set to \texttt{TRUE} and the \texttt{scale} argument set to \texttt{FALSE}. The variable's mean will be subtracted off of each of the variable values. (Note: If desired, the \texttt{center} argument can be set to a numeric value instead of \texttt{TRUE}/\texttt{FALSE}; in that case, each variable value will have the argument value subtracted off of it.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{centered\_mpg }\OtherTok{\textless{}{-}} \FunctionTok{scale}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{mpg, }\AttributeTok{center =}\NormalTok{ T, }\AttributeTok{scale =}\NormalTok{ F)}
\FunctionTok{mean}\NormalTok{(centered\_mpg)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4.440892e-16
\end{verbatim}

To scale a variable (while also centering it), call \texttt{scale()} with the \texttt{center} and \texttt{scale} arguments set to \texttt{TRUE} (these are the default argument values). The variable's mean will be subtracted off of each of the variable values, and each value will then be divided by the variable's standard deviation. (Note: As with the \texttt{center} argument, the \texttt{scale} argument can also be set to a numeric value instead of \texttt{TRUE}/\texttt{FALSE}; in that case, the divisor will be the argument value instead of the standard deviation.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scaled\_mpg }\OtherTok{\textless{}{-}} \FunctionTok{scale}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{mpg, }\AttributeTok{center =}\NormalTok{ T, }\AttributeTok{scale =}\NormalTok{ T)}
\FunctionTok{mean}\NormalTok{(scaled\_mpg)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7.112366e-17
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sd}\NormalTok{(scaled\_mpg)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\hypertarget{basic-plotting-and-visualization}{%
\chapter{Basic Plotting and Visualization}\label{basic-plotting-and-visualization}}

This chapter looks at creating basic plots to explore and understand data. Visualization in Python and R is a gigantic and evolving topic. We don't pretend to present a comprehensive comparison.

The plots below make use of the \href{https://allisonhorst.github.io/palmerpenguins/}{\textbf{palmerpenguins}} data set, which contains various measurements for 344 penguins across three islands in the Antarctic Palmer Archipelago. The data were collected by \href{https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php}{Kristen Gorman} and colleagues, and they were made available under a \href{https://creativecommons.org/share-your-work/public-domain/cc0/}{CC0 public domain license} by Allison Horst, Alison Hill, and Kristen Gorman.

For the R sections below, we show how to make each plot with base R and with \textbf{ggplot2}.

Here's a glimpse at the data set:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(penguins)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 8
##   species island bill_length_mm bill_depth_mm flipper_length_~ body_mass_g sex  
##   <fct>   <fct>           <dbl>         <dbl>            <int>       <int> <fct>
## 1 Adelie  Torge~           39.1          18.7              181        3750 male 
## 2 Adelie  Torge~           39.5          17.4              186        3800 fema~
## 3 Adelie  Torge~           40.3          18                195        3250 fema~
## 4 Adelie  Torge~           NA            NA                 NA          NA <NA> 
## 5 Adelie  Torge~           36.7          19.3              193        3450 fema~
## 6 Adelie  Torge~           39.3          20.6              190        3650 male 
## # ... with 1 more variable: year <int>
\end{verbatim}

\hypertarget{histograms}{%
\section{Histograms}\label{histograms}}

Visualizing the distribution of numeric data.

\hypertarget{python-41}{%
\subsubsection*{Python}\label{python-41}}
\addcontentsline{toc}{subsubsection}{Python}

The Python library \textbf{Matplotlib} provides the \texttt{hist()} function to compute and plot a histogram. There are many parameters that can be specified within the \texttt{hist()} function so that you can customize the output histogram plot to best fit your needs. Some parameters include the number of bins, the upper and lower bounds on each bin, weights, colors, and more.

Below we show a histogram of the bill lengths from the penguins dataset. We specified 30 bins, each of which is light blue with a black outline of \texttt{linewidth\ =\ 1}. The \texttt{hist()} function defaults to no outline, which can make it difficult to distinguish bins clearly, so we add in the bin outlines here.

One thing to note is that the bins are left inclusive and right exclusive. For example, if a particular bin spans the range of 1 to 3, the bin will include the value 1 but will exclude the value 3 (and will include all values between 1 and 3). In short, bin ranges are as follows {[}x1,x2) where x1 is the starting point of the bin and x2 is the ending point of the bin.

Notice the semicolon at the end of the \texttt{plt.hist()} function. This suppresses the printing of the array generated to create the histogram.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{plt.clf() }\CommentTok{\# clear the current figure}
\NormalTok{plt.hist(penguins.bill\_length\_mm, bins}\OperatorTok{=}\DecValTok{30}\NormalTok{, }\BuiltInTok{range}\OperatorTok{=}\NormalTok{(}\DecValTok{30}\NormalTok{,}\DecValTok{60}\NormalTok{),}
\NormalTok{         color}\OperatorTok{=}\StringTok{\textquotesingle{}lightblue\textquotesingle{}}\NormalTok{, edgecolor}\OperatorTok{=}\StringTok{\textquotesingle{}k\textquotesingle{}}\NormalTok{, linewidth}\OperatorTok{=}\DecValTok{1}\NormalTok{)}\OperatorTok{;}
\NormalTok{plt.title(}\StringTok{"Penguin Bill Lengths"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Bill Length (mm)"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Count"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-274-1.pdf}

\hypertarget{r-41}{%
\subsubsection*{R}\label{r-41}}
\addcontentsline{toc}{subsubsection}{R}

Base R's \texttt{hist()} function generates histograms, and features of the histogram---like the bar color, number of bins/breaks, and so on---can be easily customized as below.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{hist}\NormalTok{(penguins}\SpecialCharTok{$}\NormalTok{bill\_length\_mm, }\AttributeTok{breaks =} \DecValTok{25}\NormalTok{, }\AttributeTok{col =} \StringTok{\textquotesingle{}lightblue\textquotesingle{}}\NormalTok{, }
     \AttributeTok{xlim =} \FunctionTok{c}\NormalTok{(}\DecValTok{30}\NormalTok{, }\DecValTok{60}\NormalTok{),}
     \AttributeTok{main =} \StringTok{\textquotesingle{}Penguin Bill Lengths\textquotesingle{}}\NormalTok{, }
     \AttributeTok{xlab =} \StringTok{\textquotesingle{}Bill Length (mm)\textquotesingle{}}\NormalTok{, }\AttributeTok{ylab =} \StringTok{\textquotesingle{}Count\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-275-3.pdf}

The \textbf{ggplot2} method for generating histograms follows the standard \textbf{ggplot2} syntax: Initialize a plot with \texttt{ggplot()}, and then add layers thereto. Here, the layer to add is \texttt{geom\_histogram()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(penguins, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ bill\_length\_mm)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{fill =} \StringTok{\textquotesingle{}lightblue\textquotesingle{}}\NormalTok{, }\AttributeTok{color =} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, }\AttributeTok{bins =} \DecValTok{25}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{xlim}\NormalTok{(}\DecValTok{30}\NormalTok{, }\DecValTok{60}\NormalTok{) }\SpecialCharTok{+} 
  \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{\textquotesingle{}Penguin Bill Lengths\textquotesingle{}}\NormalTok{, }
       \AttributeTok{x =} \StringTok{\textquotesingle{}Bill Length (mm)\textquotesingle{}}\NormalTok{, }\AttributeTok{y =} \StringTok{\textquotesingle{}Count\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-276-1.pdf}

\hypertarget{barplots}{%
\section{Barplots}\label{barplots}}

Visualizing the distribution of categorical data.

\hypertarget{python-42}{%
\subsubsection*{Python}\label{python-42}}
\addcontentsline{toc}{subsubsection}{Python}

For this example, we will generate a bar plot showing how many of each species---Adelie, Chinstrap, Gentoo---we have in our dataset. We go through two ways of doing this here.

First, we use the \textbf{Matplotlib} plotting library to create the bar plot using the function \texttt{bar()}. To start, we determine the number of each species, then use that data to create the bar plot.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt }

\CommentTok{\# Determine the number of each species}
\NormalTok{adelie\_counts }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(penguins.loc[penguins[}\StringTok{"species"}\NormalTok{]}\OperatorTok{==}\StringTok{"Adelie"}\NormalTok{])}
\NormalTok{chinstrap\_counts }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(penguins.loc[penguins[}\StringTok{"species"}\NormalTok{]}\OperatorTok{==}\StringTok{"Chinstrap"}\NormalTok{])}
\NormalTok{gentoo\_counts }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(penguins.loc[penguins[}\StringTok{"species"}\NormalTok{]}\OperatorTok{==}\StringTok{"Gentoo"}\NormalTok{])}

\CommentTok{\# Save the counts information into arrays to be inputted into the bar() function}
\NormalTok{spec }\OperatorTok{=}\NormalTok{ [}\StringTok{"Adelie"}\NormalTok{,}\StringTok{"Chinstrap"}\NormalTok{,}\StringTok{"Gentoo"}\NormalTok{]}
\NormalTok{counts }\OperatorTok{=}\NormalTok{ [adelie\_counts,chinstrap\_counts,gentoo\_counts]}

\NormalTok{plt.clf() }\CommentTok{\# clears the figure to ensure that multiple plots are not overlaid}
\NormalTok{plt.bar(spec,counts)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <BarContainer object of 3 artists>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-277-1.pdf}

Our data is stored in a \texttt{pandas\ Dataframe}, which has its own built-in plotting module, \texttt{plot}. Here we create the same bar plot by using the pandas \texttt{bar()} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.clf()}
\NormalTok{penguins[}\StringTok{"species"}\NormalTok{].value\_counts().plot.bar()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-278-3.pdf}

One thing to note here is that we generated the same bar plot as we first made with way less effort. Using the built-in pandas plotting routine proved to be the more efficient method here.

\hypertarget{r-42}{%
\subsubsection*{R}\label{r-42}}
\addcontentsline{toc}{subsubsection}{R}

To form barplots, we'll first take the \textbf{penguins} data set and create a summary data frame containing the statistics we're looking to plot. Here, that's simply the sample size of each species in the data set.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{species\_counts }\OtherTok{\textless{}{-}} \FunctionTok{as.data.frame}\NormalTok{(}\FunctionTok{xtabs}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{ species, }\AttributeTok{data =}\NormalTok{ penguins))}
\NormalTok{species\_counts}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     species Freq
## 1    Adelie  152
## 2 Chinstrap   68
## 3    Gentoo  124
\end{verbatim}

We can plot those values using the \texttt{barplot()} function in base R, specifying arguments along the way to customize the title/axis labeling, bar colors, and range of the y axis. To add values above the bars, we can follow \texttt{barplot()} with a \texttt{text()} call as below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{penguin\_plot }\OtherTok{\textless{}{-}} \FunctionTok{barplot}\NormalTok{(Freq }\SpecialCharTok{\textasciitilde{}}\NormalTok{ species, }\AttributeTok{data =}\NormalTok{ species\_counts, }
                        \AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}lightblue\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}cornflowerblue\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}darkslateblue\textquotesingle{}}\NormalTok{),}
                        \AttributeTok{main =} \StringTok{\textquotesingle{}Species Sample Size\textquotesingle{}}\NormalTok{, }
                        \AttributeTok{xlab =} \StringTok{\textquotesingle{}Species\textquotesingle{}}\NormalTok{, }\AttributeTok{ylab =} \StringTok{\textquotesingle{}Count\textquotesingle{}}\NormalTok{, }\AttributeTok{ylim =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{200}\NormalTok{))}
\FunctionTok{text}\NormalTok{(}\AttributeTok{x =}\NormalTok{ penguin\_plot, }\AttributeTok{y =}\NormalTok{ species\_counts}\SpecialCharTok{$}\NormalTok{Freq }\SpecialCharTok{+} \DecValTok{10}\NormalTok{, }
     \AttributeTok{labels =}\NormalTok{ species\_counts}\SpecialCharTok{$}\NormalTok{Freq)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-280-1.pdf}

To recreate the barplot above with \textbf{ggplot2}, one can add a \texttt{geom\_bar()} layer to a plot initialized with \texttt{ggplot()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(species\_counts, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ species, }\AttributeTok{y =}\NormalTok{ Freq)) }\SpecialCharTok{+}
  \FunctionTok{geom\_bar}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{fill =}\NormalTok{ species), }\AttributeTok{stat =} \StringTok{\textquotesingle{}identity\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  
  \CommentTok{\# scale\_fill\_manual() is used here for bar{-}color customization}
  \FunctionTok{scale\_fill\_manual}\NormalTok{(}\AttributeTok{values =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}lightblue\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}cornflowerblue\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}darkslateblue\textquotesingle{}}\NormalTok{)) }\SpecialCharTok{+} 
  \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{\textquotesingle{}Species Sample Size\textquotesingle{}}\NormalTok{, }\AttributeTok{x =} \StringTok{\textquotesingle{}Species\textquotesingle{}}\NormalTok{, }\AttributeTok{y =} \StringTok{\textquotesingle{}Count\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  
  \CommentTok{\# For simplicity, we omit the legend }
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{legend.position =} \StringTok{\textquotesingle{}none\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+} 
  \FunctionTok{ylim}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{200}\NormalTok{) }\SpecialCharTok{+} 
  
  \CommentTok{\# geom\_text() is used here to add counts above the bars}
  \FunctionTok{geom\_text}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{label =}\NormalTok{ Freq, }\AttributeTok{vjust =} \SpecialCharTok{{-}}\FloatTok{0.5}\NormalTok{)) }
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-281-1.pdf}

\hypertarget{scatterplot}{%
\section{Scatterplot}\label{scatterplot}}

Visualizing the relationship between two numeric variables.

\hypertarget{python-43}{%
\subsubsection*{Python}\label{python-43}}
\addcontentsline{toc}{subsubsection}{Python}

The \texttt{scatter()} function, part of \textbf{matplotlib}, can produce scatterplots in Python. The \texttt{x} and \texttt{y} arguments specify the points to plot. In the example below, we also use the \texttt{c} and \texttt{marker} arguments to customize the point color and point shape, respectively. The \texttt{xlabel()}, \texttt{ylabel()}, and \texttt{title()} functions customize plot labels.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\CommentTok{\# remove NA rows, as we only want to plot present data}
\NormalTok{penguins\_no\_na }\OperatorTok{=}\NormalTok{ penguins.dropna() }

\NormalTok{plt.clf() }\CommentTok{\# clear the plotting space to prevent plot overlap}

\CommentTok{\# \textquotesingle{}d\textquotesingle{} generates diamond markers; }
\CommentTok{\# learn more about available marker shapes: }
\CommentTok{\# https://matplotlib.org/stable/api/markers\_api.html\#module{-}matplotlib.markers}
\NormalTok{plt.scatter(x }\OperatorTok{=}\NormalTok{ penguins\_no\_na[}\StringTok{\textquotesingle{}body\_mass\_g\textquotesingle{}}\NormalTok{], }
\NormalTok{            y }\OperatorTok{=}\NormalTok{ penguins\_no\_na[}\StringTok{\textquotesingle{}flipper\_length\_mm\textquotesingle{}}\NormalTok{], }
\NormalTok{            c }\OperatorTok{=} \StringTok{\textquotesingle{}lightblue\textquotesingle{}}\NormalTok{, marker }\OperatorTok{=} \StringTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{) }
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Body Mass (g)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Flipper Length (mm)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Scatterplot of Body Mass and Flipper Length\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-282-1.pdf}

\hypertarget{r-43}{%
\subsubsection*{R}\label{r-43}}
\addcontentsline{toc}{subsubsection}{R}

Scatterplots can be generated in base R with the \texttt{plot()} function. The \texttt{pch} argument below modifies the point shape (e.g., 20 = solid circle; 24 = unfilled triangle; etc.)

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(}\AttributeTok{x =}\NormalTok{ penguins}\SpecialCharTok{$}\NormalTok{body\_mass\_g, }\AttributeTok{y =}\NormalTok{ penguins}\SpecialCharTok{$}\NormalTok{flipper\_length\_mm, }
     \AttributeTok{col =} \StringTok{\textquotesingle{}navy\textquotesingle{}}\NormalTok{, }\AttributeTok{pch =} \DecValTok{20}\NormalTok{,}
     \AttributeTok{main =} \StringTok{\textquotesingle{}Scatterplot of Body Mass and Flipper Length\textquotesingle{}}\NormalTok{, }
     \AttributeTok{xlab =} \StringTok{\textquotesingle{}Body Mass (g)\textquotesingle{}}\NormalTok{, }\AttributeTok{ylab =} \StringTok{\textquotesingle{}Flipper Length (mm)\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-283-3.pdf}

To generate a scatterplot with \textbf{ggplot2}, initialize a plot with \texttt{ggplot()}, then add a layer of points with \texttt{geom\_point()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(penguins, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ body\_mass\_g, }\AttributeTok{y =}\NormalTok{ flipper\_length\_mm)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{color =} \StringTok{\textquotesingle{}navy\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{\textquotesingle{}Scatterplot of Body Mass and Flipper Length\textquotesingle{}}\NormalTok{, }
       \AttributeTok{x =} \StringTok{\textquotesingle{}Body Mass (g)\textquotesingle{}}\NormalTok{, }\AttributeTok{y =} \StringTok{\textquotesingle{}Flipper Length (mm)\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-284-1.pdf}

\hypertarget{stripcharts}{%
\section{Stripcharts}\label{stripcharts}}

Stripcharts, or strip plots, are one-dimensional scatterplots. Like boxplots, they reveal the distribution of a numeric variable within levels of a categorical variable.

\hypertarget{python-44}{%
\subsubsection*{Python}\label{python-44}}
\addcontentsline{toc}{subsubsection}{Python}

The \textbf{seaborn} package provides the \texttt{stripplot()} function. Specify which variables you want on the x and y axes. Below we specify island on the y axis to see the distribution of bill\_depth\_mm horizontally. Specify your Pandas data frame using the data argument. Finally create the plot using \texttt{plt.show()} from \textbf{matplotlib}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ seaborn }\ImportTok{as}\NormalTok{ sns}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\NormalTok{sns.stripplot(x}\OperatorTok{=}\StringTok{"bill\_depth\_mm"}\NormalTok{, y}\OperatorTok{=}\StringTok{"island"}\NormalTok{, data}\OperatorTok{=}\NormalTok{penguins)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-285-1.pdf}

The \href{https://seaborn.pydata.org/generated/seaborn.stripplot.html}{stripplot} help page provides more examples.

\hypertarget{r-44}{%
\subsubsection*{R}\label{r-44}}
\addcontentsline{toc}{subsubsection}{R}

Base R offers the \texttt{stripchart()} function. To indicate the numeric variable and the grouping variable, you can use formula notation: \texttt{numeric\_var\ \textasciitilde{}\ grouping\_var}. Adding \texttt{method\ =\ \textquotesingle{}jitter\textquotesingle{}} to the arguments spreads the points out slightly within each level of the grouping variable, making it easier to see points that might otherwise be obscured by overlap.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{stripchart}\NormalTok{(bill\_depth\_mm }\SpecialCharTok{\textasciitilde{}}\NormalTok{ island, }\AttributeTok{data =}\NormalTok{ penguins, }
           \AttributeTok{method =} \StringTok{\textquotesingle{}jitter\textquotesingle{}}\NormalTok{,}
           \AttributeTok{ylab =} \StringTok{\textquotesingle{}Island\textquotesingle{}}\NormalTok{, }\AttributeTok{xlab =} \StringTok{\textquotesingle{}Bill Depth (mm)\textquotesingle{}}\NormalTok{, }
           \AttributeTok{main =} \StringTok{\textquotesingle{}Stripchart of Bill Depth by Island\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-286-3.pdf}

Stripcharts can also be made with \textbf{ggplots2}'s \texttt{geom\_jitter()} function, as shown below. You can control the amount of jitter with a \texttt{position} argument in \texttt{geom\_jitter()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(penguins, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ island, }\AttributeTok{y =}\NormalTok{ bill\_depth\_mm)) }\SpecialCharTok{+}
  \FunctionTok{geom\_jitter}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{color =}\NormalTok{ island), }\AttributeTok{position =} \FunctionTok{position\_jitter}\NormalTok{(}\FloatTok{0.1}\NormalTok{)) }\SpecialCharTok{+}
  
  \CommentTok{\# scale\_fill\_manual() is used to manually specify group colors }
  \CommentTok{\# once aes(color = island) is specified in \textasciigrave{}geom\_jitter()\textasciigrave{}}
  \FunctionTok{scale\_color\_manual}\NormalTok{(}\AttributeTok{values =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}lightblue\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}cornflowerblue\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}darkslateblue\textquotesingle{}}\NormalTok{)) }\SpecialCharTok{+} 
  \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{\textquotesingle{}Stripchart of Bill Depth by Island\textquotesingle{}}\NormalTok{, }
       \AttributeTok{x =} \StringTok{\textquotesingle{}Island\textquotesingle{}}\NormalTok{, }\AttributeTok{y =} \StringTok{\textquotesingle{}Bill Depth (mm)\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{legend.position =} \StringTok{\textquotesingle{}none\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: Removed 2 rows containing missing values (geom_point).
\end{verbatim}

\includegraphics{_main_files/figure-latex/unnamed-chunk-287-1.pdf}

\hypertarget{boxplots}{%
\section{Boxplots}\label{boxplots}}

Visualizing the relationship between a numeric variable and a categorical variable via five-number summaries.

\hypertarget{python-45}{%
\subsubsection*{Python}\label{python-45}}
\addcontentsline{toc}{subsubsection}{Python}

The \texttt{boxplot()} function in seaborn generates boxplots, and matplotlib can be used for the aesthetics of the plot.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ seaborn }\ImportTok{as}\NormalTok{ sns}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\NormalTok{plt.figure()}
\NormalTok{sns.boxplot(x}\OperatorTok{=}\StringTok{"island"}\NormalTok{, y}\OperatorTok{=}\StringTok{"bill\_depth\_mm"}\NormalTok{, data}\OperatorTok{=}\NormalTok{penguins)}
\NormalTok{plt.xlabel(}\StringTok{"Island"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Bill Depth (mm)"}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{"Bill Depth by Island"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Traceback (most recent call last):
##   File "C:\Users\jcf2d\AppData\Roaming\Python\Python39\site-packages\matplotlib\backends\backend_qt.py", line 455, in _draw_idle
##     self.draw()
##   File "C:\Users\jcf2d\AppData\Roaming\Python\Python39\site-packages\matplotlib\backends\backend_agg.py", line 436, in draw
##     self.figure.draw(self.renderer)
##   File "C:\Users\jcf2d\AppData\Roaming\Python\Python39\site-packages\matplotlib\artist.py", line 73, in draw_wrapper
##     result = draw(artist, renderer, *args, **kwargs)
##   File "C:\Users\jcf2d\AppData\Roaming\Python\Python39\site-packages\matplotlib\artist.py", line 50, in draw_wrapper
##     return draw(artist, renderer)
##   File "C:\Users\jcf2d\AppData\Roaming\Python\Python39\site-packages\matplotlib\figure.py", line 2810, in draw
##     mimage._draw_list_compositing_images(
##   File "C:\Users\jcf2d\AppData\Roaming\Python\Python39\site-packages\matplotlib\image.py", line 132, in _draw_list_compositing_images
##     a.draw(renderer)
##   File "C:\Users\jcf2d\AppData\Roaming\Python\Python39\site-packages\matplotlib\artist.py", line 50, in draw_wrapper
##     return draw(artist, renderer)
##   File "C:\Users\jcf2d\AppData\Roaming\Python\Python39\site-packages\matplotlib\axes\_base.py", line 3046, in draw
##     self._update_title_position(renderer)
##   File "C:\Users\jcf2d\AppData\Roaming\Python\Python39\site-packages\matplotlib\axes\_base.py", line 2984, in _update_title_position
##     if (ax.xaxis.get_ticks_position() in ['top', 'unknown']
##   File "C:\Users\jcf2d\AppData\Roaming\Python\Python39\site-packages\matplotlib\axis.py", line 2232, in get_ticks_position
##     self._get_ticks_position()]
##   File "C:\Users\jcf2d\AppData\Roaming\Python\Python39\site-packages\matplotlib\axis.py", line 1936, in _get_ticks_position
##     major = self.majorTicks[0]
## IndexError: list index out of range
\end{verbatim}

\includegraphics{_main_files/figure-latex/unnamed-chunk-288-1.pdf}

\hypertarget{r-45}{%
\subsubsection*{R}\label{r-45}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{boxplot()} function in base R generates boxplots. A user specifies the grouping variable and the numeric variable to be plotted in formula notation: \texttt{y\ \textasciitilde{}\ grouping\_var}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{boxplot}\NormalTok{(bill\_depth\_mm }\SpecialCharTok{\textasciitilde{}}\NormalTok{ island, }\AttributeTok{data =}\NormalTok{ penguins, }
        \AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}lightblue\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}cornflowerblue\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}darkslateblue\textquotesingle{}}\NormalTok{),}
        \AttributeTok{main =} \StringTok{\textquotesingle{}Boxplot of Bill Depth by Island\textquotesingle{}}\NormalTok{, }
        \AttributeTok{xlab =} \StringTok{\textquotesingle{}Island\textquotesingle{}}\NormalTok{, }\AttributeTok{ylab =} \StringTok{\textquotesingle{}Bill Depth (mm)\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-289-3.pdf}

To generate a boxplot with \textbf{ggplot2}, add a \texttt{geom\_boxplot()} layer to a plot initialized with \texttt{ggplot()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(penguins, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ island, }\AttributeTok{y =}\NormalTok{ bill\_depth\_mm)) }\SpecialCharTok{+}
  \FunctionTok{geom\_boxplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{fill =}\NormalTok{ island)) }\SpecialCharTok{+}
  \FunctionTok{scale\_fill\_manual}\NormalTok{(}\AttributeTok{values =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}lightblue\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}cornflowerblue\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}darkslateblue\textquotesingle{}}\NormalTok{)) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{\textquotesingle{}Boxplot of Bill Depth by Island\textquotesingle{}}\NormalTok{, }
       \AttributeTok{x =} \StringTok{\textquotesingle{}Island\textquotesingle{}}\NormalTok{, }\AttributeTok{y =} \StringTok{\textquotesingle{}Bill Depth (mm)\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{legend.position =} \StringTok{\textquotesingle{}none\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-290-1.pdf}

\hypertarget{facet-plots}{%
\section{Facet plots}\label{facet-plots}}

Facet plots (also called trellis plots, lattice plots, and conditional plots) are comprised of multiple smaller plots, where each subplot contains a subset of the overall data, with subsets defined by one or more faceting variables.

\hypertarget{python-46}{%
\subsubsection*{Python}\label{python-46}}
\addcontentsline{toc}{subsubsection}{Python}

The seaborn package provides several functions for creating facet plots, including \texttt{relplot()}, \texttt{displot()}, \texttt{catplot()}, and \texttt{lmplot()}. Below we demonstrate the \texttt{lmplot()} function which allows you to create scatter plots at certain levels of categorical variable. Specify your x and y variables as character strings using the \texttt{x} and \texttt{y} arguments, respectively. Specing the grouping variable using either the \texttt{col} or \texttt{row} arguments. By default a linear-squares lines is added to the plot. Setting \texttt{ci\ =\ None} suppresses the confidence interval ribbon.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.clf()}
\NormalTok{sns.lmplot(x }\OperatorTok{=} \StringTok{"bill\_length\_mm"}\NormalTok{, y }\OperatorTok{=} \StringTok{"bill\_depth\_mm"}\NormalTok{, }
\NormalTok{           col }\OperatorTok{=} \StringTok{"species"}\NormalTok{,}
\NormalTok{           data }\OperatorTok{=}\NormalTok{ penguins, ci }\OperatorTok{=} \VariableTok{None}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-291-1.pdf}

To facet by two variables, provide variables to both the \texttt{col} and \texttt{row} arguments.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.clf()}
\NormalTok{sns.lmplot(x }\OperatorTok{=} \StringTok{"bill\_length\_mm"}\NormalTok{, y }\OperatorTok{=} \StringTok{"bill\_depth\_mm"}\NormalTok{, }
\NormalTok{           col }\OperatorTok{=} \StringTok{"species"}\NormalTok{, row }\OperatorTok{=} \StringTok{"sex"}\NormalTok{,}
\NormalTok{           data }\OperatorTok{=}\NormalTok{ penguins, ci }\OperatorTok{=} \VariableTok{None}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-292-3.pdf}

Set \texttt{lowess\ =\ True} for smooth trend lines. Notice also that color can be mapped to the same variable used for faceting.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.clf()}
\NormalTok{sns.lmplot(x }\OperatorTok{=} \StringTok{"bill\_length\_mm"}\NormalTok{, y }\OperatorTok{=} \StringTok{"bill\_depth\_mm"}\NormalTok{, }
\NormalTok{           col }\OperatorTok{=} \StringTok{"species"}\NormalTok{, hue }\OperatorTok{=} \StringTok{"species"}\NormalTok{,}
\NormalTok{           data }\OperatorTok{=}\NormalTok{ penguins, ci }\OperatorTok{=} \VariableTok{None}\NormalTok{, lowess }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-293-5.pdf}

The \href{https://seaborn.pydata.org/generated/seaborn.lmplot.html\#seaborn.lmplot}{lmplot} help page showcases other examples.

\hypertarget{r-46}{%
\subsubsection*{R}\label{r-46}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{coplot()} function in base R produces conditioning plots using formula notation: \texttt{y\ \textasciitilde{}\ x\ \textbar{}\ grouping\_var}. The \texttt{rows} and \texttt{columns} arguments control layout. Below we specify one row of plots. The \texttt{panel} argument controls what action is carried out in each plot. The default is a scatterplot. Below we use the base R \texttt{panel.smooth} function to create scatter plots with a smooth trend line.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{coplot}\NormalTok{(bill\_depth\_mm }\SpecialCharTok{\textasciitilde{}}\NormalTok{ bill\_length\_mm }\SpecialCharTok{|}\NormalTok{ species, }
       \AttributeTok{data =}\NormalTok{ penguins,}
       \AttributeTok{panel =}\NormalTok{ panel.smooth,}
       \AttributeTok{rows =} \DecValTok{1}\NormalTok{, }\AttributeTok{col =} \StringTok{"navy"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-294-7.pdf}

To condition on two variables, use formula notation with syntax: \texttt{y\ \textasciitilde{}\ x\ \textbar{}\ grp\_var1\ *\ grp\_var2}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{coplot}\NormalTok{(bill\_depth\_mm }\SpecialCharTok{\textasciitilde{}}\NormalTok{ bill\_length\_mm }\SpecialCharTok{|}\NormalTok{ species }\SpecialCharTok{*}\NormalTok{ sex, }
       \AttributeTok{data =}\NormalTok{ penguins,}
       \AttributeTok{panel =}\NormalTok{ panel.smooth,}
       \AttributeTok{col =} \StringTok{"navy"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-295-1.pdf}

The labels of the conditioning variables unfortunately use a lot of real estate in the margins, and there is no easy way to modify that. However, this design works quite well when we condition on a \emph{numeric variable}. The \texttt{coplot()} function automatically creates overlapping group intervals to condition on, and the stacked layout of the labels helps us visualize how the relationship between y and x changes between the groups. To manually set the number of groups, use the \texttt{number} argument. Below we specify 4 groups to be generated for ``bill\_length\_mm''.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{coplot}\NormalTok{(flipper\_length\_mm }\SpecialCharTok{\textasciitilde{}}\NormalTok{ body\_mass\_g }\SpecialCharTok{|}\NormalTok{ bill\_length\_mm, }
       \AttributeTok{data =}\NormalTok{ penguins,}
       \AttributeTok{panel =}\NormalTok{ panel.smooth,}
       \AttributeTok{number =} \DecValTok{4}\NormalTok{, }
       \AttributeTok{rows =} \DecValTok{1}\NormalTok{, }\AttributeTok{col =} \StringTok{"navy"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-296-1.pdf}

Alternatively, \textbf{ggplot2} provides a intuitive and easy-to-use method for generating facet plots: A user specifies the aesthetics of the plot using standard \textbf{ggplot2} syntax (i.e., as a series of added layers) and then adds an additional call, \texttt{facet\_wrap()} (or \texttt{facet\_grid()}; differences are discussed below), specifying the faceting variable(s) to split up the plots by.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(penguins, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ bill\_length\_mm, }\AttributeTok{y =}\NormalTok{ bill\_depth\_mm)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{color =} \StringTok{\textquotesingle{}navy\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  
  \CommentTok{\# Add least{-}squares line}
  \FunctionTok{geom\_smooth}\NormalTok{(}\AttributeTok{method =} \StringTok{\textquotesingle{}lm\textquotesingle{}}\NormalTok{, }\AttributeTok{se =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{color =} \StringTok{\textquotesingle{}salmon\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+} 
  
  \CommentTok{\# Use formula notation, a character vector, or vars() to }
  \CommentTok{\# specify faceting variables; e.g., \textasciitilde{}species, c(\textquotesingle{}species\textquotesingle{}), }
  \CommentTok{\# or vars(species)}
  \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{ species)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `geom_smooth()` using formula 'y ~ x'
\end{verbatim}

\includegraphics{_main_files/figure-latex/unnamed-chunk-297-1.pdf}

The number of rows and columns can be manually specified with \texttt{nrow} and \texttt{ncol} arguments in \texttt{facet\_wrap()}. By default, the x and y axes of all facet plots will be on the same scale. The axis ranges can be set to vary freely by adding \texttt{scales\ =\ \textquotesingle{}free\textquotesingle{}} as an argument (or, alternatively, \texttt{scales\ =\ \textquotesingle{}free\_x\textquotesingle{}} or \texttt{scales\ =\ \textquotesingle{}free\_y\textquotesingle{}} to free just the x or y axis).

Both \texttt{facet\_wrap()} and \texttt{facet\_grid()} can be used to make facet plots. When faceting based on multiple variables (e.g., species and sex), \texttt{facet\_wrap()} will drop group combinations for which there are no data points, whereas \texttt{facet\_grid()} will generate a plot for all possible group combinations:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(penguins, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ bill\_length\_mm, }\AttributeTok{y =}\NormalTok{ bill\_depth\_mm)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{color =} \StringTok{\textquotesingle{}navy\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_smooth}\NormalTok{(}\AttributeTok{method =} \StringTok{\textquotesingle{}lm\textquotesingle{}}\NormalTok{, }\AttributeTok{se =}\NormalTok{ F, }\AttributeTok{color =} \StringTok{\textquotesingle{}salmon\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{facet\_wrap}\NormalTok{(}\FunctionTok{vars}\NormalTok{(species, sex))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `geom_smooth()` using formula 'y ~ x'
\end{verbatim}

\includegraphics{_main_files/figure-latex/unnamed-chunk-298-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(penguins, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ bill\_length\_mm, }\AttributeTok{y =}\NormalTok{ bill\_depth\_mm)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{color =} \StringTok{\textquotesingle{}navy\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_smooth}\NormalTok{(}\AttributeTok{method =} \StringTok{\textquotesingle{}lm\textquotesingle{}}\NormalTok{, }\AttributeTok{se =}\NormalTok{ F, }\AttributeTok{color =} \StringTok{\textquotesingle{}salmon\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  
  \CommentTok{\# Note that facet\_grid() has separate \textasciigrave{}rows\textasciigrave{} and \textasciigrave{}cols\textasciigrave{} arguments }
  \CommentTok{\# for specifying faceting variables}
  \FunctionTok{facet\_grid}\NormalTok{(}\AttributeTok{rows =} \FunctionTok{vars}\NormalTok{(sex), }\AttributeTok{cols =} \FunctionTok{vars}\NormalTok{(species)) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `geom_smooth()` using formula 'y ~ x'
\end{verbatim}

\includegraphics{_main_files/figure-latex/unnamed-chunk-298-2.pdf}

\hypertarget{selected-topics-in-statistical-inference}{%
\chapter{Selected Topics in Statistical Inference}\label{selected-topics-in-statistical-inference}}

This chapter looks at performing selected statistical analyses. It is not comprehensive. The focus is on implementation using Python and R. Good statistical practice is more than knowing which function to use. At a minimum we recommend reading the article, \href{https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004961}{Ten Simple Rules for Effective Statistical Practice} \citep{kass_caffo_davidian_meng_yu_reid_2016}.

\hypertarget{comparing-group-means}{%
\section{Comparing group means}\label{comparing-group-means}}

Many research studies compare mean values of some quantity of interest between two or more groups. A t test analyzes two group means. An Analysis of Variance, or ANOVA, analyzes three or more group means. Both the t test and ANOVA are special cases of a linear model.

To demonstrate the t test, we examine fictitious data on 15 scores between two groups of subjects. The ``control'' group was tested as-is while the ``treated'' group experienced a particular intervention. Of interest is (1) whether or not the mean scores differ meaningfully between the treated and control groups, and (2) if they do differ, how are they different?

To demonstrate the ANOVA test, we use data from \emph{The Analysis of Biological Data (3rd ed)}\citep{whitlock_schluter_2020} on the mass of pine cones (in grams) from three different environments in North America. Of interest is (1) whether or not the mean mass of pine cones differ meaningfully between the three locations, and (2) if they do differ, how are they different?

We usually assess the first question in each scenario with a hypothesis test and p-value. The null hypothesis is no difference between the means. The p-value is the probability of the observed differences between the groups (or more extreme differences) assuming the null hypothesis is true. A small p-value, traditionally less then 0.05, provides evidence against the null. For example, a p-value of 0.01 says there's a 1\% chance of sampling data as different as this (or more different) if there really was no difference between the groups. Note that p-values don't tell you how two or more statistics differ. See \href{https://www.tandfonline.com/doi/full/10.1080/00031305.2016.1154108\#_i28}{the ASA Statement on p-values}.

We assess the second question in each scenario by calculating confidence intervals on the difference in means. This is more informative than a p-value. A confidence interval gives us information on the uncertainty, direction and magnitude of a difference in means. For example, a 95\% confidence interval of {[}2, 15{]} tells us the data is consistent with a difference anywhere between 2 and 15 and that the mean of one group appears to be at least 2 units larger than the mean of the other group. Note that a 95\% confidence interval does not mean there is a 95\% probability that the true value is in the interval. The confidence interval either captured the true value or it did not. We don't know. However the \emph{process} of calculating the confidence interval works roughly 95\% of the time.

\hypertarget{python-47}{%
\subsubsection*{Python}\label{python-47}}
\addcontentsline{toc}{subsubsection}{Python}

\textbf{t-test}

Our data is available as a \textbf{Pandas} dataframe. It's small enough to view in its entirety.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ch8\_d1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     score    group
## 0    77.0  control
## 1    81.0  control
## 2    77.0  control
## 3    86.0  control
## 4    81.0  control
## 5    77.0  control
## 6    82.0  control
## 7    83.0  control
## 8    82.0  control
## 9    79.0  control
## 10   86.0  control
## 11   82.0  control
## 12   78.0  control
## 13   71.0  control
## 14   84.0  control
## 15   85.0  treated
## 16   85.0  treated
## 17   89.0  treated
## 18   88.0  treated
## 19   87.0  treated
## 20   89.0  treated
## 21   88.0  treated
## 22   85.0  treated
## 23   77.0  treated
## 24   87.0  treated
## 25   85.0  treated
## 26   84.0  treated
## 27   79.0  treated
## 28   83.0  treated
## 29   87.0  treated
\end{verbatim}

A stripchart is one of many ways to visualize numeric data between two groups. Here we use the seaborn function \texttt{stripplot()}. It appears the treated group had higher scores.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ seaborn }\ImportTok{as}\NormalTok{ sns}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\NormalTok{plt.clf()}
\NormalTok{sns.stripplot(x}\OperatorTok{=}\StringTok{"score"}\NormalTok{, y}\OperatorTok{=}\StringTok{"group"}\NormalTok{, data}\OperatorTok{=}\NormalTok{ch8\_d1)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-303-1.pdf}

One way to perform a t test in Python is via the \texttt{CompareMeans()} function and its associated methods available in the \textbf{statsmodels} package. Below we import \textbf{statsmodels.stats.api} as ``sms''.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ statsmodels.stats.api }\ImportTok{as}\NormalTok{ sms}
\end{Highlighting}
\end{Shaded}

We first extract the data we want to compare as pandas Series.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_control }\OperatorTok{=}\NormalTok{ ch8\_d1.query(}\StringTok{\textquotesingle{}group == "control"\textquotesingle{}}\NormalTok{)[}\StringTok{\textquotesingle{}score\textquotesingle{}}\NormalTok{]}
\NormalTok{d\_treated }\OperatorTok{=}\NormalTok{ ch8\_d1.query(}\StringTok{\textquotesingle{}group == "treated"\textquotesingle{}}\NormalTok{)[}\StringTok{\textquotesingle{}score\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Next we create Descriptive statistics objects using the \texttt{DescrStatsW()} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{control }\OperatorTok{=}\NormalTok{ sms.DescrStatsW(d\_control)}
\NormalTok{treated }\OperatorTok{=}\NormalTok{ sms.DescrStatsW(d\_treated)}
\end{Highlighting}
\end{Shaded}

Descriptive statistics objects have attributes such as \texttt{mean} and \texttt{std} (standard deviation). Below we print the mean and standard deviation of each group. We also round the standard deviation to three decimal places and place a line break before printing the standard deviation.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"control mean:"}\NormalTok{, control.mean, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{control std:"}\NormalTok{, }\BuiltInTok{round}\NormalTok{(control.std, }\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## control mean: 80.4 
## control std: 3.844
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"treated mean:"}\NormalTok{, treated.mean, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{treated std:"}\NormalTok{, }\BuiltInTok{round}\NormalTok{(treated.std, }\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## treated mean: 85.2 
## treated std: 3.331
\end{verbatim}

Next we create a CompareMeans means object using the \texttt{CompareMeans()} function. The required inputs are Descriptive statistics objects. We save the result as ``ttest''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ttest }\OperatorTok{=}\NormalTok{ sms.CompareMeans(control, treated)}
\end{Highlighting}
\end{Shaded}

Now we can use various methods with the ``ttest'' object. To see the result of a two sample t test assuming unequal variances, along with a confidence interval on the differences, use the \texttt{summary} method with \texttt{usevar=\textquotesingle{}unequal\textquotesingle{}}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(ttest.summary(usevar}\OperatorTok{=}\StringTok{\textquotesingle{}unequal\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                           Test for equality of means                          
## ==============================================================================
##                  coef    std err          t      P>|t|      [0.025      0.975]
## ------------------------------------------------------------------------------
## subset #1     -4.8000      1.359     -3.531      0.001      -7.587      -2.013
## ==============================================================================
\end{verbatim}

The p-value of 0.001 is small, providing good evidence that the difference in means we witnessed reflects a real difference in the population. The confidence interval on the difference in means tells us the data is consistent with a difference between -7 and -2. It appears we can expect the control group to score at least 2 points lower than the treated group.

\textbf{ANOVA}

Our data is available as a \textbf{Pandas} dataframe. It's small enough to view in its entirety.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ch8\_d2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     mass location
## 0    9.6        1
## 1    9.4        1
## 2    8.9        1
## 3    8.8        1
## 4    8.5        1
## 5    8.2        1
## 6    6.8        2
## 7    6.6        2
## 8    6.0        2
## 9    5.7        2
## 10   5.3        2
## 11   6.7        3
## 12   6.4        3
## 13   6.2        3
## 14   5.7        3
## 15   5.6        3
\end{verbatim}

Again we use a stripchart to visualize the three groups of data. It appears the pine cones in location 1 have a higher mass.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.clf()}
\NormalTok{sns.stripplot(x}\OperatorTok{=}\StringTok{"mass"}\NormalTok{, y}\OperatorTok{=}\StringTok{"location"}\NormalTok{, data}\OperatorTok{=}\NormalTok{ch8\_d2)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-311-3.pdf}

We can calculate means using the \texttt{groupby} and \texttt{mean} methods.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ch8\_d2[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{].groupby(ch8\_d2[}\StringTok{\textquotesingle{}location\textquotesingle{}}\NormalTok{]).mean()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## location
## 1    8.90
## 2    6.08
## 3    6.12
## Name: mass, dtype: float64
\end{verbatim}

One way to perform an ANOVA test in Python is via the \texttt{anova\_oneway()} function, also available in the \textbf{statsmodels} package.

The \texttt{anova\_oneway()} function can perform an ANOVA on a pandas Dataframe with the first argument specifying the numeric data and the second argument the grouping variable. We also set \texttt{use\_var=\textquotesingle{}equal\textquotesingle{}} to replicate the R output below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sms.anova\_oneway(ch8\_d2.mass, ch8\_d2.location, use\_var}\OperatorTok{=}\StringTok{\textquotesingle{}equal\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <class 'statsmodels.stats.base.HolderTuple'>
## statistic = 50.085429769392036
## pvalue = 7.786760128813737e-07
## df = (2.0, 13.0)
## df_num = 2.0
## df_denom = 13.0
## nobs_t = 16.0
## n_groups = 3
## means = array([8.9 , 6.08, 6.12])
## nobs = array([6., 5., 5.])
## vars_ = array([0.28 , 0.387, 0.217])
## use_var = 'equal'
## welch_correction = True
## tuple = (50.085429769392036, 7.786760128813737e-07)
\end{verbatim}

The small p-value of 0.0000007 provides strong evidence that the difference in means we witnessed reflects a real difference in the population.

A common follow-up to an ANOVA is Tukey's Honestly Significant Differences (HSD), which computes differences between all possible pairs and returns adjusted p-values and confidence intervals to account for the multiple comparisons. To carry this out in the \textbf{statsmodels} package, we need to first create a MultiComparison object using the \texttt{multicomp.MultiComparison()} function. Then we use the \texttt{tukeyhsd()} method to compare the means with corrected p-values.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mc }\OperatorTok{=}\NormalTok{ sms.multicomp.MultiComparison(ch8\_d2.mass, ch8\_d2.location)}
\BuiltInTok{print}\NormalTok{(mc.tukeyhsd())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Multiple Comparison of Means - Tukey HSD, FWER=0.05 
## ====================================================
## group1 group2 meandiff p-adj   lower   upper  reject
## ----------------------------------------------------
##      1      2    -2.82    0.0 -3.6863 -1.9537   True
##      1      3    -2.78    0.0 -3.6463 -1.9137   True
##      2      3     0.04 0.9925 -0.8648  0.9448  False
## ----------------------------------------------------
\end{verbatim}

The difference in means between locations 2 and 1 (2 - 1) and locations 3 and 1 (3 - 1) are about -2.8. The difference in means between locations 3 and 2 (3 - 2) is inconclusive. It seems to be small but we're not sure if the difference is positive or negative.

\hypertarget{r-47}{%
\subsubsection*{R}\label{r-47}}
\addcontentsline{toc}{subsubsection}{R}

\textbf{t-test}

The \texttt{str()} function allows to take a quick look at the data frame \texttt{ch8\_d1}. One column contains the scores, the other column indicates which group the subject was in (control vs treated).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(ch8\_d1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    30 obs. of  2 variables:
##  $ score: num  77 81 77 86 81 77 82 83 82 79 ...
##  $ group: chr  "control" "control" "control" "control" ...
\end{verbatim}

A stripchart is one of many ways to visualize numeric data between two groups. Here we use the base R function \texttt{stripchart()}. The formula \texttt{score\ \textasciitilde{}\ group} says to plot score by group. The \texttt{las\ =\ 1} argument says to rotate the y-axis labels. The \texttt{method\ =\ "jitter"} arguments says to randomly scatter the points vertically so they don't overplot. It appears the treated group had higher scores.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{stripchart}\NormalTok{(score }\SpecialCharTok{\textasciitilde{}}\NormalTok{ group, }\AttributeTok{data =}\NormalTok{ ch8\_d1, }\AttributeTok{las =} \DecValTok{1}\NormalTok{, }\AttributeTok{method =} \StringTok{"jitter"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-316-1.pdf}

To calculate the means between the two groups we can use the \texttt{aggregate()} function. Again the formula \texttt{score\ \textasciitilde{}\ group} says to aggregate score by group. We specify \texttt{mean} so that we calculate the mean between the two groups. Some other functions we could specify include \texttt{median}, \texttt{sd}, or \texttt{sum}. The sample mean of the treated group is about 5 points higher than the control group.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{aggregate}\NormalTok{(score }\SpecialCharTok{\textasciitilde{}}\NormalTok{ group, }\AttributeTok{data =}\NormalTok{ ch8\_d1, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     group score
## 1 control  80.4
## 2 treated  85.2
\end{verbatim}

Is this difference meaningful? What if we took more samples? Would each sample result in similar differences in the means? A t test attempts to answer this.

The \texttt{t.test()} function accommodates formula notation allowing us to specify that we want to calculate mean score by group.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{t.test}\NormalTok{(score }\SpecialCharTok{\textasciitilde{}}\NormalTok{ group, }\AttributeTok{data =}\NormalTok{ ch8\_d1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Welch Two Sample t-test
## 
## data:  score by group
## t = -3.5313, df = 27.445, p-value = 0.001482
## alternative hypothesis: true difference in means between group control and group treated is not equal to 0
## 95 percent confidence interval:
##  -7.586883 -2.013117
## sample estimates:
## mean in group control mean in group treated 
##                  80.4                  85.2
\end{verbatim}

The p-value of 0.0015 is small, providing good evidence that the difference in means we witnessed reflects a real difference in the population. The confidence interval on the difference in means tells us the data is consistent with a difference between -7 and -2. It appears we can expect the control group to score at least 2 points lower than the treated group.

\textbf{ANOVA}

The \texttt{str()} function allows to take a quick look at the data frame \texttt{ch8\_d2}. One column contains the mass of the pine cones, the other column indicates which location the pine cone was found.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(ch8\_d2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    16 obs. of  2 variables:
##  $ mass    : num  9.6 9.4 8.9 8.8 8.5 8.2 6.8 6.6 6 5.7 ...
##  $ location: chr  "1" "1" "1" "1" ...
\end{verbatim}

Again we use a stripchart to visualize the three groups of data. It appears the pine cones in location 1 have a higher mass.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{stripchart}\NormalTok{(mass }\SpecialCharTok{\textasciitilde{}}\NormalTok{ location, }\AttributeTok{data =}\NormalTok{ ch8\_d2, }\AttributeTok{las =} \DecValTok{1}\NormalTok{, }\AttributeTok{method =} \StringTok{"jitter"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-320-1.pdf}

To calculate the means between the three groups we can use the \texttt{aggregate()} function. Again the formula \texttt{mass\ \textasciitilde{}\ location} says to aggregate mass by location. We specify \texttt{mean} so that we calculate the mean between the three groups.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{aggregate}\NormalTok{(mass }\SpecialCharTok{\textasciitilde{}}\NormalTok{ location, }\AttributeTok{data =}\NormalTok{ ch8\_d2, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   location mass
## 1        1 8.90
## 2        2 6.08
## 3        3 6.12
\end{verbatim}

Is this difference meaningful? ANOVA attempts to answer this.

The \texttt{aov()} function carries out the ANOVA test and also accommodates formula notation. It's usually preferable to save the ANOVA result into an object and call \texttt{summary()} on the object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{aov1 }\OtherTok{\textless{}{-}} \FunctionTok{aov}\NormalTok{(mass }\SpecialCharTok{\textasciitilde{}}\NormalTok{ location, }\AttributeTok{data =}\NormalTok{ ch8\_d2)}
\FunctionTok{summary}\NormalTok{(aov1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             Df Sum Sq Mean Sq F value   Pr(>F)    
## location     2 29.404  14.702   50.09 7.79e-07 ***
## Residuals   13  3.816   0.294                     
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}

The small p-value of 0.0000007 provides strong evidence that the difference in means we witnessed reflects a real difference in the population.

Unlike the \texttt{t.test()} output, the \texttt{aov()} summary does not provide confidence intervals on differences in means. That's because there are many kinds of differences we might want to assess. A common and easy procedure is Tukey's Honestly Significant Differences (HSD), which computes differences between all possible pairs and returns adjusted p-values and confidence intervals to account for the multiple comparisons. Base R provides the \texttt{TukeyHSD()} function for this task. Call it on the ANOVA object.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{TukeyHSD}\NormalTok{(aov1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Tukey multiple comparisons of means
##     95% family-wise confidence level
## 
## Fit: aov(formula = mass ~ location, data = ch8_d2)
## 
## $location
##      diff        lwr        upr     p adj
## 2-1 -2.82 -3.6862516 -1.9537484 0.0000028
## 3-1 -2.78 -3.6462516 -1.9137484 0.0000033
## 3-2  0.04 -0.8647703  0.9447703 0.9925198
\end{verbatim}

The difference in means between locations 2 and 1 (2 - 1) and locations 3 and 1 (3 - 1) are about -2.8. The difference in means between locations 3 and 2 (3 - 2) is inconclusive. It seems to be small but we're not sure if the difference is positive or negative.

\hypertarget{comparing-group-proportions}{%
\section{Comparing group proportions}\label{comparing-group-proportions}}

It is often of interest to compare proportions between two groups. Sometimes this is referred to as a two-sample proportion test. To demonstrate we use an exercise from the text \emph{Introductory Statistics with R} \citep{Dalgaard_2020} (p.154). We are told that 210 out of 747 patients died of Rocky Mountain spotted fever in the western United States. That's a proportion of 0.281. In the eastern United States, 122 out 661 patients died. That's a proportion of 0.185. Is the difference in proportions statistically significant? In other words, assuming there is no difference in the fatality rate between the two regions, is this difference in proportions surprising?

\hypertarget{python-48}{%
\subsubsection*{Python}\label{python-48}}
\addcontentsline{toc}{subsubsection}{Python}

A two-sample proportion test can be carried out in Python using the \texttt{test\_proportions\_2indep()} function from the \textbf{statsmodels} package. The two proportions being compared must be independent.

The first argument is the number of successes or occurrences for the first proportion. The second argument is the number of total trials for the first group. The third and fourth arguments are the occurrences and total number of trials for the second group, respectively.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ statsmodels.stats.api }\ImportTok{as}\NormalTok{ sms}
\NormalTok{ptest }\OperatorTok{=}\NormalTok{ sms.test\_proportions\_2indep(}\DecValTok{210}\NormalTok{, }\DecValTok{747}\NormalTok{, }\DecValTok{122}\NormalTok{, }\DecValTok{661}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can extract the p-value of the test and the difference in proportions using the \texttt{pvalue} and \texttt{diff} attributes, respectively.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ptest.pvalue}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1.632346798072468e-05
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# rounded to 4 decimal places}
\BuiltInTok{round}\NormalTok{(ptest.diff, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0.0966
\end{verbatim}

To calculate a 95\% confidence interval for the difference in proportions we need to use the \texttt{confint\_proportions\_2indep()} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pdiff }\OperatorTok{=}\NormalTok{ sms.confint\_proportions\_2indep(}\DecValTok{210}\NormalTok{, }\DecValTok{747}\NormalTok{, }\DecValTok{122}\NormalTok{, }\DecValTok{661}\NormalTok{)}
\NormalTok{pdiff}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## (0.05241555145475882, 0.13988087590630482)
\end{verbatim}

The result is returned as a tuple with an extreme amount of precision. We recommend rounding these values to few decimal places. Here's one way using f strings. Notice we extract each element of the ``pdiff'' tuple and round to 5 decimal places.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"(}\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{(pdiff[}\DecValTok{0}\NormalTok{],}\DecValTok{5}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{, }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{(pdiff[}\DecValTok{1}\NormalTok{],}\DecValTok{5}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## (0.05242, 0.13988)
\end{verbatim}

This results are slightly different from the R example below. That's because the \texttt{test\_proportions\_2indep()} and \texttt{confint\_proportions\_2indep()} functions use different methods. See their respective help pages to learn more about the methods available and other function arguments.

\href{https://www.statsmodels.org/dev/generated/statsmodels.stats.proportion.test_proportions_2indep.html\#statsmodels.stats.proportion.test_proportions_2indep}{test\_proportions\_2indep} help page\\
\href{https://www.statsmodels.org/dev/generated/statsmodels.stats.proportion.confint_proportions_2indep.html\#statsmodels.stats.proportion.confint_proportions_2indep}{confint\_proportions\_2indep} help page

\hypertarget{r-48}{%
\subsubsection*{R}\label{r-48}}
\addcontentsline{toc}{subsubsection}{R}

A two-sample proportion test in R can be carried out with the \texttt{prop.test()} function. The first argument, \texttt{x}, is the number of ``successes'' or ``occurrences'' of some event for each group. The second argument, \texttt{n}, is the number of total trials for each group.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{prop.test}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\DecValTok{210}\NormalTok{, }\DecValTok{122}\NormalTok{), }\AttributeTok{n =} \FunctionTok{c}\NormalTok{(}\DecValTok{747}\NormalTok{, }\DecValTok{661}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  2-sample test for equality of proportions with continuity correction
## 
## data:  c(210, 122) out of c(747, 661)
## X-squared = 17.612, df = 1, p-value = 2.709e-05
## alternative hypothesis: two.sided
## 95 percent confidence interval:
##  0.05138139 0.14172994
## sample estimates:
##    prop 1    prop 2 
## 0.2811245 0.1845688
\end{verbatim}

The proportion of patients who died in the western US is about 0.28. The proportion who died in the eastern US is about 0.18. The small p-value says there is a very small chance of seeing a difference as large as this (or larger) if there really was no difference in the proportions. The confidence interval on the difference of proportions ranges from 0.05 to 0.14, indicating that this fever seems to kill at least 5\% more patients in the western US.

Sometimes data is presented in a 2-way table with successes and failures. We can present the preceding data in a table as follows using the \texttt{matrix()} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fever }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{210}\NormalTok{, }\DecValTok{122}\NormalTok{,}
                  \DecValTok{747{-}210}\NormalTok{, }\DecValTok{661{-}122}\NormalTok{), }\AttributeTok{ncol =} \DecValTok{2}\NormalTok{)}
\FunctionTok{rownames}\NormalTok{(fever) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"western US"}\NormalTok{, }\StringTok{"eastern US"}\NormalTok{)}
\FunctionTok{colnames}\NormalTok{(fever) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"died"}\NormalTok{, }\StringTok{"lived"}\NormalTok{)}
\NormalTok{fever}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##            died lived
## western US  210   537
## eastern US  122   539
\end{verbatim}

When the table is constructed in this fashion with ``successes'' in the first column and ``failures'' in the second column, we can feed the table directly to the \texttt{prop.test()} function. (Obviously ``success'' here means ``experienced the event of interest''.)

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{prop.test}\NormalTok{(fever)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  2-sample test for equality of proportions with continuity correction
## 
## data:  fever
## X-squared = 17.612, df = 1, p-value = 2.709e-05
## alternative hypothesis: two.sided
## 95 percent confidence interval:
##  0.05138139 0.14172994
## sample estimates:
##    prop 1    prop 2 
## 0.2811245 0.1845688
\end{verbatim}

The chi-squared test statistic is reported as \texttt{X-squared\ =\ 17.612}. This is the same statistic reported if we ran a chi-squared test of association using the \texttt{chisq.test()} function.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{chisq.test}\NormalTok{(fever)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Pearson's Chi-squared test with Yates' continuity correction
## 
## data:  fever
## X-squared = 17.612, df = 1, p-value = 2.709e-05
\end{verbatim}

This tests the null hypothesis of no association between location in the US and fatality of the fever. The result is identical to \texttt{prop.test()} output, however there is no indication of the nature of association.

\hypertarget{linear-modeling}{%
\section{Linear modeling}\label{linear-modeling}}

Linear modeling attempts to assess if or how the variability a numeric variable depends on one or more predictor variables. This is often referred to as \emph{regression modeling} or \emph{multiple regression}. While it is relatively easy to ``fit a model'' and generate lots of output, the model we fit may not be very good. There are many decisions we have to make when proposing a model. Which predictors do we include? Will they interact? Do we allow for non-linear effects? Answering these kinds of questions require subject matter expertise.

We walk through a somewhat simple example using data on weekly gas consumption. The data is courtesy of the R package \textbf{MASS} \citep{MASS}. The documentation describes the data as follows:

``Mr Derek Whiteside of the UK Building Research Station recorded the weekly gas consumption and average external temperature at his own house in south-east England for two heating seasons, one of 26 weeks before, and one of 30 weeks after cavity-wall insulation was installed. The object of the exercise was to assess the effect of the insulation on gas consumption.''

The \texttt{whiteside} data frame has 56 rows and 3 columns:

\begin{itemize}
\tightlist
\item
  \texttt{Insul}: A factor, before or after insulation.
\item
  \texttt{Temp}: average outside temperature in degrees Celsius.
\item
  \texttt{Gas}: weekly gas consumption in 1000s of cubic feet.
\end{itemize}

Below we demonstrate modeling \texttt{Gas} as a function of \texttt{Insul}, \texttt{Temp}, and their interaction.

Obviously this is not a comprehensive treatment of linear modeling.

\hypertarget{python-49}{%
\subsubsection*{Python}\label{python-49}}
\addcontentsline{toc}{subsubsection}{Python}

In Python, the \texttt{OLS()} function in the statsmodels package fits a linear model.

In this example, we fit a linear model to predict gas prices from insulation, temperature, and the interaction between insulation and temperature.

The basic construction is to first list your dependent or response variable, then a tilde (\texttt{\textasciitilde{}}), and then your predictor variables, or terms, separated by plus operators (\texttt{+}). Listing two variables separated by a colon (\texttt{:}) indicates we wish to fit an interaction for those variables. The variables in the formula correspond to columns in a pandas DataFrame. Users specify the pandas DataFrame using the \texttt{data} argument.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ statsmodels.api }\ImportTok{as}\NormalTok{ sm}
\ImportTok{import}\NormalTok{ statsmodels.formula.api }\ImportTok{as}\NormalTok{ smf}

\NormalTok{model }\OperatorTok{=}\NormalTok{ smf.ols(}\StringTok{\textquotesingle{}Gas \textasciitilde{} Insul + Temp + Insul:Temp\textquotesingle{}}\NormalTok{, data}\OperatorTok{=}\NormalTok{whiteside)}
\NormalTok{results }\OperatorTok{=}\NormalTok{ model.fit() }\CommentTok{\# fit the linear model}
\end{Highlighting}
\end{Shaded}

Once you fit your model, you can extract information about it using several functions. The most commonly used include:

\begin{itemize}
\tightlist
\item
  \texttt{summary()}: summary of model coefficients with standard errors and test statistics
\item
  \texttt{params}: model coefficients
\item
  \texttt{conf\_int()}: 95\% confidence interval of model coefficients
\item
  statsmodels provides functions for diagnostic plots. A few examples are shown below.
\end{itemize}

The \texttt{summary()} function produces the standard regression summary one typically finds in a statistics textbook.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(results.summary())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                             OLS Regression Results                            
## ==============================================================================
## Dep. Variable:                    Gas   R-squared:                       0.928
## Model:                            OLS   Adj. R-squared:                  0.924
## Method:                 Least Squares   F-statistic:                     222.3
## Date:                Thu, 21 Apr 2022   Prob (F-statistic):           1.23e-29
## Time:                        12:03:57   Log-Likelihood:                -14.100
## No. Observations:                  56   AIC:                             36.20
## Df Residuals:                      52   BIC:                             44.30
## Df Model:                           3                                         
## Covariance Type:            nonrobust                                         
## =======================================================================================
##                           coef    std err          t      P>|t|      [0.025      0.975]
## ---------------------------------------------------------------------------------------
## Intercept               6.8538      0.136     50.409      0.000       6.581       7.127
## Insul[T.After]         -2.1300      0.180    -11.827      0.000      -2.491      -1.769
## Temp                   -0.3932      0.022    -17.487      0.000      -0.438      -0.348
## Insul[T.After]:Temp     0.1153      0.032      3.591      0.001       0.051       0.180
## ==============================================================================
## Omnibus:                        6.016   Durbin-Watson:                   1.854
## Prob(Omnibus):                  0.049   Jarque-Bera (JB):                4.998
## Skew:                          -0.626   Prob(JB):                       0.0822
## Kurtosis:                       3.757   Cond. No.                         31.6
## ==============================================================================
## 
## Notes:
## [1] Standard Errors assume that the covariance matrix of the errors is correctly specified.
\end{verbatim}

The following code produces a fitted vs residual plot for the model.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.figure()}
\NormalTok{smoothed\_line }\OperatorTok{=}\NormalTok{ sm.nonparametric.lowess(results.resid, results.fittedvalues)}
\NormalTok{plt.plot(results.fittedvalues, results.resid, }\StringTok{"."}\NormalTok{)}
\NormalTok{plt.plot(smoothed\_line[:,}\DecValTok{0}\NormalTok{], smoothed\_line[:,}\DecValTok{1}\NormalTok{],color }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"fitted values"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"residuals"}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{"residuals vs fitted"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-337-1.pdf}

For the model's Q-Q plot, use the \texttt{qqplot()} function.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{plt.figure()}
\NormalTok{sm.graphics.qqplot(results.get\_influence().resid\_studentized\_internal)}
\NormalTok{plt.title(}\StringTok{"q{-}q"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-338-3.pdf}

For the model's residuals vs leverage, or influence plot, use the influence\_plot() function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.figure()}
\NormalTok{sm.graphics.influence\_plot(results)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-339-5.pdf}

The following code plots ``Temp'' values and corresponding model predictions using the \texttt{plot\_fit()} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.figure()}
\NormalTok{sm.graphics.plot\_fit(results, }\StringTok{\textquotesingle{}Temp\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-340-7.pdf}

The following code plots model predictions. Each curve on the plot represents a level of the variable ``Insul''.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{from}\NormalTok{ statsmodels.sandbox.predict\_functional }\ImportTok{import}\NormalTok{ predict\_functional}

\CommentTok{\# create DataFrame (wrt Inusl == "Before") to pass into predict function}
\NormalTok{temp }\OperatorTok{=}\NormalTok{ np.linspace(whiteside[}\StringTok{"Temp"}\NormalTok{].}\BuiltInTok{min}\NormalTok{(), whiteside[}\StringTok{"Temp"}\NormalTok{].}\BuiltInTok{max}\NormalTok{())}
\NormalTok{insul\_before }\OperatorTok{=}\NormalTok{ [}\StringTok{"Before"}\NormalTok{]}\OperatorTok{*}\NormalTok{temp.shape[}\DecValTok{0}\NormalTok{]}
\CommentTok{\# whiteside\_before = pd.DataFrame(\{"Temp": temp, "Insul": insul\_before\})}
\NormalTok{whiteside\_before }\OperatorTok{=}\NormalTok{ \{}\StringTok{"Temp"}\NormalTok{: temp, }\StringTok{"Insul"}\NormalTok{: insul\_before, }\StringTok{"Insul:Temp"}\NormalTok{:[}\DecValTok{0}\NormalTok{]}\OperatorTok{*}\NormalTok{temp.shape[}\DecValTok{0}\NormalTok{]\}}
\CommentTok{\# pr, cb, fv = predict\_functional(results, "Temp", values=whiteside\_before, ci\_method=\textquotesingle{}scheffe\textquotesingle{})}
\NormalTok{before\_predict\_object }\OperatorTok{=}\NormalTok{ results.get\_prediction(whiteside\_before)}
\NormalTok{before\_predictions }\OperatorTok{=}\NormalTok{ before\_predict\_object.predicted\_mean}
\NormalTok{before\_ci }\OperatorTok{=}\NormalTok{ before\_predict\_object.conf\_int()}

\CommentTok{\# create DataFrame (wrt Inusl == "After") to pass into predict function}
\NormalTok{insul\_after }\OperatorTok{=}\NormalTok{ [}\StringTok{"After"}\NormalTok{]}\OperatorTok{*}\NormalTok{temp.shape[}\DecValTok{0}\NormalTok{]}
\NormalTok{whiteside\_after }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{"Temp"}\NormalTok{: temp, }\StringTok{"Insul"}\NormalTok{: insul\_after, }\StringTok{"Insul:Temp"}\NormalTok{:temp\})}
\NormalTok{after\_predictions\_object }\OperatorTok{=}\NormalTok{ results.get\_prediction(whiteside\_after)}
\NormalTok{after\_predictions }\OperatorTok{=}\NormalTok{ after\_predictions\_object.predicted\_mean}
\NormalTok{after\_ci }\OperatorTok{=}\NormalTok{ after\_predictions\_object.conf\_int()}

\CommentTok{\# plot results}
\NormalTok{plt.figure()}
\NormalTok{plt.plot(temp, before\_predictions, color }\OperatorTok{=} \StringTok{"red"}\NormalTok{, label}\OperatorTok{=}\StringTok{"Before"}\NormalTok{)}
\NormalTok{plt.fill\_between(temp, before\_ci[:,}\DecValTok{0}\NormalTok{], before\_ci[:,}\DecValTok{1}\NormalTok{], color }\OperatorTok{=} \StringTok{"red"}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.1}\NormalTok{)}
\NormalTok{plt.plot(temp, after\_predictions, color}\OperatorTok{=}\StringTok{"blue"}\NormalTok{, label}\OperatorTok{=}\StringTok{"After"}\NormalTok{)}
\NormalTok{plt.fill\_between(temp, after\_ci[:,}\DecValTok{0}\NormalTok{], after\_ci[:,}\DecValTok{1}\NormalTok{], color }\OperatorTok{=} \StringTok{"blue"}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.1}\NormalTok{)}
\NormalTok{plt.legend(title}\OperatorTok{=}\StringTok{"Insul"}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{"Predicted values of Gas"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Temp"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Gas"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-341-9.pdf}

\hypertarget{r-49}{%
\subsubsection*{R}\label{r-49}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{lm()} function fits a linear model in R using whatever model we propose. We specify models using a special syntax. The basic construction is to first list your dependent or response variable, then a tilde (\texttt{\textasciitilde{}}), and then your predictor variables, or terms, separated by plus operators (\texttt{+}). Listing two variables separated by a colon (\texttt{:}) indicates we wish to fit an interaction for those variables. See \texttt{?formula} for further details on formula syntax.

It's considered best practice to reference variables in a data frame and indicate the data frame using the \texttt{data} argument. Though not required, you'll almost always want to save the result to an object for further inquiry.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(Gas }\SpecialCharTok{\textasciitilde{}}\NormalTok{ Insul }\SpecialCharTok{+}\NormalTok{ Temp }\SpecialCharTok{+}\NormalTok{ Insul}\SpecialCharTok{:}\NormalTok{Temp, }\AttributeTok{data =}\NormalTok{ whiteside)}
\end{Highlighting}
\end{Shaded}

Once you fit your model, you can extract information about it using several functions. The most commonly used include:

\begin{itemize}
\tightlist
\item
  \texttt{summary()}: summary of model coefficients with standard errors and test statistics
\item
  \texttt{coef()}: model coefficients
\item
  \texttt{confint()}: 95\% confidence interval of model coefficients
\item
  \texttt{plot()}: a set of four diagnostic plots
\end{itemize}

The \texttt{summary()} function produces the standard regression summary one typically finds described in a statistics textbook.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Call:
## lm(formula = Gas ~ Insul + Temp + Insul:Temp, data = whiteside)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.97802 -0.18011  0.03757  0.20930  0.63803 
## 
## Coefficients:
##                 Estimate Std. Error t value Pr(>|t|)    
## (Intercept)      6.85383    0.13596  50.409  < 2e-16 ***
## InsulAfter      -2.12998    0.18009 -11.827 2.32e-16 ***
## Temp            -0.39324    0.02249 -17.487  < 2e-16 ***
## InsulAfter:Temp  0.11530    0.03211   3.591 0.000731 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.323 on 52 degrees of freedom
## Multiple R-squared:  0.9277, Adjusted R-squared:  0.9235 
## F-statistic: 222.3 on 3 and 52 DF,  p-value: < 2.2e-16
\end{verbatim}

Calling \texttt{plot()} on a model object produces four different diagnostic plots by default. Using the \texttt{which} argument we can specify which of six possible plots to create. The first one checks the constant variance assumption (ie, that our model is not dramatically over- or under-predicting values.) We hope to see residuals evenly scattered around 0. (See \texttt{?plot.lm} for more details on the diagnostic plots.)

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-344-1.pdf} \includegraphics{_main_files/figure-latex/unnamed-chunk-344-2.pdf} \includegraphics{_main_files/figure-latex/unnamed-chunk-344-3.pdf} \includegraphics{_main_files/figure-latex/unnamed-chunk-344-4.pdf}

Once we fit a model and we're reasonably confident that it's a good model, we may want to visualize it. Three packages in R that help with this are \textbf{emmeans}, \textbf{effects}, and \textbf{ggeffects}. We briefly demonstrate the \textbf{ggeffects} package.

You need to first install the \textbf{ggeffects} package as it does not come with the base R installation. Once installed, load using the \texttt{library()} function.

Once loaded, we can get a basic visualization of our model by using the \texttt{plot()} and \texttt{ggpredict()} functions. This is particularly useful for models with interactions. Use the \texttt{terms} argument to specify which variables to plot. Below we list ``Temp'' first, which will plot ``Temp'' on the x axis. Then we list ``Insul'', the grouping variable, to indicate we want a separate fit for each level of ``Insul''.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# install.pacakges("ggeffects")}
\FunctionTok{library}\NormalTok{(ggeffects)}
\FunctionTok{plot}\NormalTok{(}\FunctionTok{ggpredict}\NormalTok{(m, }\AttributeTok{terms =} \FunctionTok{c}\NormalTok{(}\StringTok{"Temp"}\NormalTok{, }\StringTok{"Insul"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-345-1.pdf}

We see that after installing insulation, gas consumption fell considerably, and that the effect of temperature on gas consumption is less pronounced.

\hypertarget{logistic-regression}{%
\section{Logistic regression}\label{logistic-regression}}

Logistic regression attempts to assess if or how the variability a binary variable depends on one or more predictor variables. It is a type of Generalized Linear Model and is commonly used to model the \emph{probability} of an event occurring. While it is relatively easy to ``fit a model'' and generate lots of output, the model we fit may not be very good. There are many decisions we have to make when proposing a model. Which predictors do we include? Will they interact? Do we allow for non-linear effects? Answering these kinds of questions require subject matter expertise.

We walk through a basic example using data on low infant birth weight. The data is courtesy of the R package \textbf{MASS} \citep{MASS}. According to the documentation, ``the data were collected at Baystate Medical Center, Springfield, Mass during 1986.''

We use the data as prepared in the example code found at \texttt{?birthwt}.

The \texttt{birthwt} data frame has 189 rows and 9 columns:

\begin{itemize}
\tightlist
\item
  \texttt{low}: 1 if birth weight less than 2.5 kg, 0 otherwise
\item
  \texttt{age}: mother's age in years
\item
  \texttt{lwt}: mother's weight in pounds at last menstrual period
\item
  \texttt{race}: mother's race (white, black, other)
\item
  \texttt{smoke}: smoking status during pregnancy (1 = yes, 0 = no)
\item
  \texttt{ptd}: previous premature labors (1 = yes, 0 = no)
\item
  \texttt{ht}: history of hypertension (1 = yes, 0 = no)
\item
  \texttt{ui}: presence of uterine irritability (1 = yes, 0 = no)
\item
  \texttt{ftv}: number of physician visits during the first trimester (0, 1, 2+)
\end{itemize}

Below we demonstrate modeling \texttt{low} as a function of all other predictors.

Obviously this is not a comprehensive treatment of logistic regression.

\hypertarget{python-50}{%
\subsubsection*{Python}\label{python-50}}
\addcontentsline{toc}{subsubsection}{Python}

The Python statistics library \texttt{statsmodels.formula.api} provides the \texttt{glm} function for fitting generalized linear models. We specify how we want to model our data as a formula string in the first argument of the \texttt{glm} function. The format is as follows: dependent/response variable followed by a tilde (\texttt{\textasciitilde{}}), then the predictor variables separated by a plus sign (\texttt{+}). To indicate we want to fit a logistic regression model we specify \texttt{family=sm.families.Binomial()} since our dependent variable is binary. We also specify our data set in the argument as well.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ statsmodels.api }\ImportTok{as}\NormalTok{ sm}
\ImportTok{import}\NormalTok{ statsmodels.formula.api }\ImportTok{as}\NormalTok{ smf}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\NormalTok{formula }\OperatorTok{=} \StringTok{"low \textasciitilde{} age + lwt + race + smoke + ptd + ht + ui + ftv"}
\NormalTok{mod1 }\OperatorTok{=}\NormalTok{ smf.glm(formula}\OperatorTok{=}\NormalTok{formula, data}\OperatorTok{=}\NormalTok{birthwt,}
\NormalTok{               family}\OperatorTok{=}\NormalTok{sm.families.Binomial()).fit()}
\BuiltInTok{print}\NormalTok{(mod1.summary())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                  Generalized Linear Model Regression Results                  
## ==============================================================================
## Dep. Variable:                    low   No. Observations:                  189
## Model:                            GLM   Df Residuals:                      178
## Model Family:                Binomial   Df Model:                           10
## Link Function:                  Logit   Scale:                          1.0000
## Method:                          IRLS   Log-Likelihood:                -97.738
## Date:                Thu, 21 Apr 2022   Deviance:                       195.48
## Time:                        12:04:10   Pearson chi2:                     179.
## No. Iterations:                     5   Pseudo R-squ. (CS):             0.1873
## Covariance Type:            nonrobust                                         
## =================================================================================
##                     coef    std err          z      P>|z|      [0.025      0.975]
## ---------------------------------------------------------------------------------
## Intercept         0.8230      1.245      0.661      0.508      -1.617       3.263
## race[T.black]     1.1924      0.536      2.225      0.026       0.142       2.243
## race[T.other]     0.7407      0.462      1.604      0.109      -0.164       1.646
## smoke[T.1]        0.7555      0.425      1.778      0.075      -0.078       1.589
## ptd[T.1]          1.3438      0.481      2.796      0.005       0.402       2.286
## ht[T.1]           1.9132      0.721      2.654      0.008       0.501       3.326
## ui[T.1]           0.6802      0.464      1.465      0.143      -0.230       1.590
## ftv[T.1]         -0.4364      0.479     -0.910      0.363      -1.376       0.503
## ftv[T.2+]         0.1790      0.456      0.392      0.695      -0.715       1.074
## age              -0.0372      0.039     -0.962      0.336      -0.113       0.039
## lwt              -0.0157      0.007     -2.211      0.027      -0.030      -0.002
## =================================================================================
\end{verbatim}

Once we fit a model and we're reasonably confident that it's a good model, we may want to visualize it. For example, how does \texttt{ptd} affect the probability of low infant birth weight?

To begin, we create a Pandas DataFrame for our predictors. This needs to be a Pandas DataFrame since we used the formula option when fitting the model. Notice the only variable that changes is \texttt{ptd}. All other variables are held constant. What values you choose to hold them at is up to you, but typical choices are means or medians for numeric predictors, and most populous group for categorical predictors.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# create dictionary of values}
\NormalTok{d }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}age\textquotesingle{}}\NormalTok{: }\DecValTok{23}\NormalTok{, }\StringTok{\textquotesingle{}lwt\textquotesingle{}}\NormalTok{: }\DecValTok{123}\NormalTok{, }\StringTok{\textquotesingle{}race\textquotesingle{}}\NormalTok{: }\StringTok{"white"}\NormalTok{,}
     \StringTok{\textquotesingle{}smoke\textquotesingle{}}\NormalTok{ : }\StringTok{"0"}\NormalTok{, }\StringTok{\textquotesingle{}ptd\textquotesingle{}}\NormalTok{ : [}\StringTok{"0"}\NormalTok{,}\StringTok{"1"}\NormalTok{], }\StringTok{\textquotesingle{}ht\textquotesingle{}}\NormalTok{: }\StringTok{"0"}\NormalTok{, }
     \StringTok{\textquotesingle{}ui\textquotesingle{}}\NormalTok{: }\StringTok{"0"}\NormalTok{, }\StringTok{\textquotesingle{}ftv\textquotesingle{}}\NormalTok{: }\StringTok{"0"}\NormalTok{\}}
\CommentTok{\# convert dictionary to Pandas DataFrame.}
\NormalTok{nd }\OperatorTok{=}\NormalTok{ pd.DataFrame(data}\OperatorTok{=}\NormalTok{d)}
\end{Highlighting}
\end{Shaded}

Now plug in our new data (nd) into our model using the \texttt{get\_prediction} method. See \href{https://www.statsmodels.org/devel/generated/statsmodels.genmod.generalized_linear_model.GLMResults.html\#statsmodels.genmod.generalized_linear_model.GLMResults}{this page}. This returns the predictions as a \texttt{PredictionResults} class. We can access the predicted probabilities using the \texttt{predicted\_mean} property. See \href{https://www.statsmodels.org/devel/generated/statsmodels.tsa.base.prediction.PredictionResults.html}{this page}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pred }\OperatorTok{=}\NormalTok{ mod1.get\_prediction(exog}\OperatorTok{=}\NormalTok{nd)}
\NormalTok{prob }\OperatorTok{=}\NormalTok{ pred.predicted\_mean}
\BuiltInTok{print}\NormalTok{(prob)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [0.12360891 0.35093623]
\end{verbatim}

We can use the \texttt{conf\_int} method to extract the confidence intervals for the predicted probabilities.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ci }\OperatorTok{=}\NormalTok{ pred.conf\_int()}
\BuiltInTok{print}\NormalTok{(ci)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[0.05166761 0.26746827]
##  [0.12724595 0.66722908]]
\end{verbatim}

Now we use the matplotlib \texttt{errorbar} function to create the plot. The \texttt{errorbar} function requires \emph{margin of error}, not the lower and upper limits. So we have to do some subtraction to get the lower and upper margin of errors.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lower }\OperatorTok{=}\NormalTok{ [prob[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ ci[}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{], prob[}\DecValTok{1}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ ci[}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{]]}
\NormalTok{upper }\OperatorTok{=}\NormalTok{ [ci[}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ prob[}\DecValTok{0}\NormalTok{], ci[}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ prob[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

Finally we can make the plot.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\NormalTok{plt.clf()}
\NormalTok{plt.errorbar(x }\OperatorTok{=}\NormalTok{ [}\StringTok{"0"}\NormalTok{,}\StringTok{"1"}\NormalTok{], y }\OperatorTok{=}\NormalTok{ prob, }
\NormalTok{             yerr}\OperatorTok{=}\NormalTok{[lower, upper], fmt}\OperatorTok{=}\StringTok{\textquotesingle{}ok\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <ErrorbarContainer object of 3 artists>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}ptd\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Predicted probabilities of low\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-353-1.pdf}

\hypertarget{r-50}{%
\subsubsection*{R}\label{r-50}}
\addcontentsline{toc}{subsubsection}{R}

The \texttt{glm()} function fits a generalized linear model in R using whatever model we propose. We specify models using a special syntax. The basic construction is to first list your dependent or response variable, then a tilde (\texttt{\textasciitilde{}}), and then your predictor variables, or terms, separated by plus operators (\texttt{+}). Listing two variables separated by a colon (\texttt{:}) indicates we wish to fit an interaction for those variables. See \texttt{?formula} for further details on formula syntax.

In addition, \texttt{glm()} requires we specify a family argument to specify the error distribution for the dependent variable. The default is \texttt{gaussian}. For a logistic regression model, we need to specify \texttt{binomial} since our dependent variable is binary.

It's considered best practice to reference variables in a data frame and indicate the data frame using the \texttt{data} argument. Though not required, you'll almost always want to save the result to an object for further inquiry.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod }\OtherTok{\textless{}{-}} \FunctionTok{glm}\NormalTok{(low }\SpecialCharTok{\textasciitilde{}}\NormalTok{ age }\SpecialCharTok{+}\NormalTok{ lwt }\SpecialCharTok{+}\NormalTok{ race }\SpecialCharTok{+} 
\NormalTok{             smoke }\SpecialCharTok{+}\NormalTok{ ptd }\SpecialCharTok{+}\NormalTok{ ht }\SpecialCharTok{+} 
\NormalTok{             ui }\SpecialCharTok{+}\NormalTok{ ftv, }
           \AttributeTok{data =}\NormalTok{ birthwt, }\AttributeTok{family =}\NormalTok{ binomial)}
\end{Highlighting}
\end{Shaded}

Since we're modeling \texttt{low} as a function of all other variables in the data frame, we could have used the following syntax, where the period symbolizes all other remaining variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod }\OtherTok{\textless{}{-}} \FunctionTok{glm}\NormalTok{(low }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{data =}\NormalTok{ birthwt, }\AttributeTok{family =}\NormalTok{ binomial)}
\end{Highlighting}
\end{Shaded}

Once you fit your logistic regression model, you can extract information about it using several functions. The most commonly used include:

\begin{itemize}
\tightlist
\item
  \texttt{summary()}: summary of model coefficients with standard errors and test statistics
\item
  \texttt{coef()}: model coefficients
\item
  \texttt{confint()}: 95\% confidence interval of model coefficients
\end{itemize}

The \texttt{summary()} function produces the standard regression summary one typically finds described in a statistics textbook.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(mod)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Call:
## glm(formula = low ~ age + lwt + race + smoke + ptd + ht + ui + 
##     ftv, family = binomial, data = birthwt)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -1.7038  -0.8068  -0.5008   0.8835   2.2152  
## 
## Coefficients:
##             Estimate Std. Error z value Pr(>|z|)   
## (Intercept)  0.82302    1.24471   0.661  0.50848   
## age         -0.03723    0.03870  -0.962  0.33602   
## lwt         -0.01565    0.00708  -2.211  0.02705 * 
## raceblack    1.19241    0.53597   2.225  0.02609 * 
## raceother    0.74069    0.46174   1.604  0.10869   
## smoke1       0.75553    0.42502   1.778  0.07546 . 
## ptd1         1.34376    0.48062   2.796  0.00518 **
## ht1          1.91317    0.72074   2.654  0.00794 **
## ui1          0.68019    0.46434   1.465  0.14296   
## ftv1        -0.43638    0.47939  -0.910  0.36268   
## ftv2+        0.17901    0.45638   0.392  0.69488   
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 234.67  on 188  degrees of freedom
## Residual deviance: 195.48  on 178  degrees of freedom
## AIC: 217.48
## 
## Number of Fisher Scoring iterations: 4
\end{verbatim}

Exponentiating coefficients in a logistic regression model produces odds ratios. To get the odds ratio for the previous premature labors variable, \texttt{ptd}, we do the following:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{exp}\NormalTok{(}\FunctionTok{coef}\NormalTok{(mod)[}\StringTok{"ptd1"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     ptd1 
## 3.833443
\end{verbatim}

This says the odds of having an infant with low birth weight are about 3.8 times higher for women who experienced previous premature labors versus women who did not, assuming all other variables equal.

The 3.8 value is just an estimate. We can use the \texttt{confint()} function to get a 95\% confidence interval on the odds ratio.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{exp}\NormalTok{(}\FunctionTok{confint}\NormalTok{(mod)[}\StringTok{"ptd1"}\NormalTok{,])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     2.5 %    97.5 % 
##  1.516837 10.128974
\end{verbatim}

It appears the odds ratio is at least 1.5, possibly as high as 10.1 (assuming we believe this model).

Once we fit a model and we're reasonably confident that it's a good model, we may want to visualize it. Three packages in R that help with this are \textbf{emmeans}, \textbf{effects}, and \textbf{ggeffects}. We briefly demonstrate the \textbf{ggeffects} package.

You need to first install the \textbf{ggeffects} package as it does not come with the base R installation. Once installed, load using the \texttt{library()} function.

Once loaded, we can get a basic visualization of our model by using the \texttt{plot()} and \texttt{ggpredict()} functions. This is particularly useful for logistic regression models because it produces model predictions on a probability scale.

Use the \texttt{terms} argument to specify which variables to plot. Below we create two plots: one for \texttt{ptd} (previous premature labors) and one for \texttt{lwt} (mother's weight at last menstrual period).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# install.packages("ggeffects")}
\FunctionTok{library}\NormalTok{(ggeffects)}
\FunctionTok{plot}\NormalTok{(}\FunctionTok{ggpredict}\NormalTok{(mod, }\AttributeTok{terms =} \StringTok{"ptd"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-359-1.pdf}

It looks like the probability of low infant birth weight jumps from about 12\% to over 35\% for mothers who previously experienced premature labors, though the error bars on the expected values are quite large.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(}\FunctionTok{ggpredict}\NormalTok{(mod, }\AttributeTok{terms =} \StringTok{"lwt"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-360-1.pdf}

It appears the probability of low infant birth weight drops from about 15\% when a mother weighs 100 lbs to about 5\% when a mother weighs around 200 lbs. The regions with the larger confidence ribbon indicate regions of higher uncertainty. There are clearly not many mothers in our data who weigh less than 100 lbs.

  \bibliography{book.bib,packages.bib}

\end{document}
